***********************************************************************
*
*	CODE GENERATION LISTING FOR: sw37
*	COMPILER VERSION: 6.0.0.52
*
***********************************************************************

**************************************************
	List function block: R_TRIG
**************************************************

FUNCTION_BLOCK R_TRIG

	{ DE:"<HTML>The output Q will remain FALSE as long as the input variable CLK is FALSE.<br>
As soon as CLK returns TRUE, Q will first return TRUE.<br><br>
This means each time the function is called up, Q will return FALSE until CLK has falling edge followed by an rising edge.<br><br>
<img src= r_trig.png>" }

        VAR_INPUT
clk : BOOL;	{ DE:"Input for edge detection" }
	END_VAR

        VAR_OUTPUT
q : BOOL;	{ DE:"Raising edge output" }
	END_VAR

        VAR
m : BOOL := FALSE;
	END_VAR

END_FUNCTION_BLOCK

08594490  55                            push ebp
08594491  8B EB                         mov ebp, ebx
08594493  57                            push edi

#0		{SRC:R_TRIG}
#1		
#2			LD		clk
(*) UNDEF
08594494  33 C0                         xor eax, eax
08594496  8A 45 01                      mov al, 1[ebp]

#3			ANDN	m
(*) BOOL
08594499  33 C9                         xor ecx, ecx
0859449B  8A 4D 00                      mov cl, [ebp]
0859449E  84 C9                         test cl, cl
085944A0  0F 94 C1                      sete cl
085944A3  23 C1                         and eax, ecx

#4			ST		q
(*) BOOL
085944A5  84 C0                         test al, al
085944A7  0F 95 45 02                   setne 2[ebp]

#5		
#6			LD		clk
(*) UNDEF
085944AB  33 C0                         xor eax, eax
085944AD  8A 45 01                      mov al, 1[ebp]

#7			ST		m
(*) BOOL
085944B0  84 C0                         test al, al
085944B2  0F 95 45 00                   setne [ebp]

085944B6  5F                            pop edi
085944B7  5D                            pop ebp

085944B8  C3                            ret


Frame allocation (hex):

	0000 bit  0: VAR m
	0001 bit  0: VAR clk
	0002 bit  0: VAR q

END_FUNCTION_BLOCK
**************************************************
	List function block: TON
**************************************************

FUNCTION_BLOCK TON

	{ DE:"<HTML>The TON block produces a delayed output Q of the input IN. The delay time is expressed in milliseconds on the PT input.</br></br>
<img src= tonscheme.png>
<ul>
<li>if IN is FALSE Q is false</li>
<li>Q becomes TRUE as IN remains TRUE for PT milliseconds</li>
<li>Q remains TRUE until IN remains TRUE</li>
</ul>" }

        VAR_INPUT
IN : BOOL;	{ DE:"Timer input source" }
PT : UDINT;	{ DE:"Preset time value (ms)" }
	END_VAR

        VAR_OUTPUT
Q : BOOL;	{ DE:"Timer output" }
ET : UDINT;	{ DE:"Timer current value (ms)" }
	END_VAR

        VAR_EXTERNAL
	{G:"System_Timers"}
sysTimer AT %MD0.0 : UDINT;	{ DE:"System timer [ms]" }
	END_VAR

        VAR
timStart : UDINT;	{ DE:"Time value at start of counting" }
	END_VAR

END_FUNCTION_BLOCK

085944B9  55                            push ebp
085944BA  8B EB                         mov ebp, ebx
085944BC  57                            push edi

#0		{SRC:TON}
#1		
#2			(*	Check if in counting	*)
#3		
#4			LD		IN
(*) UNDEF
085944BD  33 C0                         xor eax, eax
085944BF  8A 45 04                      mov al, 4[ebp]

#5			JMPCN	lReset
(-) BOOL
085944C2  84 C0                         test al, al
085944C4  90 74 61 90 90 90             je 08594528H

#6		
#7			(*	Check if Q is TRUE *)
#8			LD		Q
(*) UNDEF
085944CA  33 C0                         xor eax, eax
085944CC  8A 45 09                      mov al, 9[ebp]

#9			RETC
#10			
(-) BOOL
085944CF  84 C0                         test al, al
085944D1  90 75 6A 90 90 90             jne 0859453EH

#11			(*	Check if already in counting *)
#12			LD		timStart
(*) UNDEF
085944D7  8B 45 00                      mov eax, [ebp]

#13			EQ		0
(*) UDINT
085944DA  3D 00 00 00 00                cmp eax, 0
085944DF  0F 94 C0                      sete al
085944E2  25 FF 00 00 00                and eax, 0FFh

#14			JMPCN	lUpdate
(-) BOOL
085944E7  84 C0                         test al, al
085944E9  90 74 0C 90 90 90             je 085944F8H

#15		
#16			(*	Start of counting *)
#17			LD		sysTimer
(*) UNDEF
085944EF  8B 05 CC CC CC CC             mov eax, [CCCCCCCCH] ; %M0+0

#18			ST		timStart
(*) UDINT
085944F5  89 45 00                      mov [ebp], eax

#19			
#20		lUpdate:
#21		
#22			(*	Update timer and check if time elapsed *)
#23			LD		sysTimer
(*) UNDEF
085944F8  8B 05 CC CC CC CC             mov eax, [CCCCCCCCH] ; %M0+0

#24			SUB		timStart
(*) UDINT
085944FE  2B 45 00                      sub eax, [ebp]

#25			ST		ET
(*) UDINT
08594501  89 45 0A                      mov 10[ebp], eax

#26			GE		PT
(*) UDINT
08594504  3B 45 05                      cmp eax, [ebp+5]
08594507  0F 93 C0                      setae al
0859450A  25 FF 00 00 00                and eax, 0FFh

#27			ST		Q
(*) BOOL
0859450F  84 C0                         test al, al
08594511  0F 95 45 09                   setne 9[ebp]

#28			RETCN
#29		
(-) BOOL
08594515  84 C0                         test al, al
08594517  90 74 24 90 90 90             je 0859453EH

#30			(*	Limit actual time value *)
#31			LD		PT
(*) UNDEF
0859451D  8B 45 05                      mov eax, 5[ebp]

#32			ST		ET
(*) UDINT
08594520  89 45 0A                      mov 10[ebp], eax

#33			RET
#34		
(-) UDINT
08594523  EB 19 90 90 90                jmp 0859453EH

#35		lReset:
#36		
#37			(*	Reset status *)
#38			LD		0
(*) UNDEF
08594528  B8 00 00 00 00                mov eax, 00H

#39			ST		ET
(*) USINT
0859452D  89 45 0A                      mov 10[ebp], eax

#40			ST		timStart
(*) UDINT
08594530  89 45 00                      mov [ebp], eax

#41			LD		FALSE
(*) UNDEF
08594533  B8 00 00 00 00                mov eax, 00H

#42			ST		Q
(*) BOOL
08594538  84 C0                         test al, al
0859453A  0F 95 45 09                   setne 9[ebp]

0859453E  5F                            pop edi
0859453F  5D                            pop ebp

08594540  C3                            ret


Frame allocation (hex):

	0000       : VAR timStart
	0004 bit  0: VAR IN
	0005       : VAR PT
	0009 bit  0: VAR Q
	000A       : VAR ET

END_FUNCTION_BLOCK
**************************************************
	List function block: CheckAlarmVal
**************************************************

FUNCTION_BLOCK CheckAlarmVal

        VAR_IN_OUT
di_val_open_state_fall_FB : INT^;
di_val_close_state_fall_FB : INT^;
di_val_open_state_R_FB : INT^;
di_val_close_state_R_FB : BOOL^;
Alarm_Val_FB : WORD^;
o_val_open_R_FB : BOOL^;
o_val_close_R_FB : BOOL^;
o_val_open_fall_FB : BOOL^;
o_val_close_fall_FB : BOOL^;
	END_VAR

        VAR_INPUT
start_check : BOOL;
	END_VAR

        VAR_OUTPUT
is_check_done : BOOL;
isOK : BOOL;
	END_VAR

        VAR
check_timer : TON;	{ DE:"локальний FB таймера" }
should_run_timer : BOOL;
	END_VAR

END_FUNCTION_BLOCK

08594541  55                            push ebp
08594542  8B EB                         mov ebp, ebx
08594544  57                            push edi

#0		{SRC:CheckAlarmVal}
#1		(*$WAITSWITCH$*)
#2		
#3		
#4			(* IF check_timer.IN *)
#5			LD		check_timer.IN	{LNXT:3|-1|-1}
(*) UNDEF
08594545  33 C0                         xor eax, eax
08594547  8A 45 04                      mov al, 4[ebp]

#6			JMPCN	$label0	{LNXT:3|4|9}
(-) BOOL
0859454A  84 C0                         test al, al
0859454C  90 74 19 90 90 90             je 08594568H

#7		
#8			(* THEN *)
#9		
#10				(* isOK := TRUE; *)
#11				MOVE		TRUE,isOK	{LNXT:4|5|-1}
(*) BOOL
08594552  B8 01 00 00 00                mov eax, 01H
08594557  84 C0                         test al, al
08594559  0F 95 45 19                   setne 25[ebp]

#12		
#13				(* is_check_done := false; *)
#14				MOVE		false,is_check_done	{LNXT:5|9|-1}
(*) BOOL
0859455D  B8 00 00 00 00                mov eax, 00H
08594562  84 C0                         test al, al
08594564  0F 95 45 18                   setne 24[ebp]

#15		
#16		$label0:
#17			(* END_IF *)
#18		
#19		
#20			(* IF check_timer.Q *)
#21			LD		check_timer.Q	{LNXT:9|-1|-1}
(*) UNDEF
08594568  33 C0                         xor eax, eax
0859456A  8A 45 09                      mov al, 9[ebp]

#22			JMPCN	$label1	{LNXT:9|10|38}
(-) BOOL
0859456D  84 C0                         test al, al
0859456F  0F 84 23 01 00 00             je 08594698H

#23		
#24			(* THEN *)
#25		
#26				(* start_check:=false; *)
#27				MOVE		false,start_check	{LNXT:10|12|-1}
(*) BOOL
08594575  B8 00 00 00 00                mov eax, 00H
0859457A  84 C0                         test al, al
0859457C  0F 95 45 17                   setne 23[ebp]

#28		
#29		
#30				(* IF o_val_open_R_FB^ AND NOT di_val_open_state_R_FB^ *)
#31				LD		di_val_open_state_R_FB^	{LNXT:12|-1|-1}
(*) UNDEF
08594580  8B 55 22                      mov edx, 34[ebp]
08594583  0F BF 02                      movsx eax, word ptr [edx]

#32				NOT	{LNXT:12|-1|-1}
(*) INT
08594586  66 F7 D0                      not ax

#33				AND		o_val_open_R_FB^	{LNXT:12|-1|-1}
(*) INT
08594589  8B 55 2E                      mov edx, 46[ebp]
0859458C  33 C9                         xor ecx, ecx
0859458E  8A 0A                         mov cl, [edx]
08594590  23 C1                         and eax, ecx

#34				JMPCN	$label2	{LNXT:12|13|16}
(-) INT
08594592  66 85 C0                      test ax, ax
08594595  90 74 20 90 90 90             je 085945B8H

#35		
#36				(* THEN *)
#37		
#38					(* Alarm_Val_FB^.0 := TRUE; *)
#39					MOVE		TRUE,Alarm_Val_FB^.0	{LNXT:13|16|-1}
(*) INT
0859459B  B8 01 00 00 00                mov eax, 01H
085945A0  8B 55 2A                      mov edx, 42[ebp]
085945A3  84 C0                         test al, al
085945A5  90 75 0C 90 90 90             jne 0000000FH@
085945AB  0F BA 32 00                   btr [edx], 0
085945AF  EB 07 90 90 90                jmp 00000009H@
085945B4  0F BA 2A 00                   bts [edx], 0

#40		
#41		$label2:
#42				(* END_IF *)
#43		
#44		
#45				(* IF o_val_close_R_FB^ AND NOT di_val_close_state_R_FB^ *)
#46				LD		di_val_close_state_R_FB^	{LNXT:16|-1|-1}
(*) UNDEF
085945B8  8B 55 26                      mov edx, 38[ebp]
085945BB  33 C0                         xor eax, eax
085945BD  8A 02                         mov al, [edx]

#47				NOT	{LNXT:16|-1|-1}
(*) BOOL
085945BF  84 C0                         test al, al
085945C1  0F 94 C0                      sete al

#48				AND		o_val_close_R_FB^	{LNXT:16|-1|-1}
(*) BOOL
085945C4  8B 55 32                      mov edx, 50[ebp]
085945C7  8B 55 32                      mov edx, 50[ebp]
085945CA  33 C9                         xor ecx, ecx
085945CC  8A 0A                         mov cl, [edx]
085945CE  23 C1                         and eax, ecx

#49				JMPCN	$label3	{LNXT:16|17|20}
(-) BOOL
085945D0  84 C0                         test al, al
085945D2  90 74 20 90 90 90             je 085945F5H

#50		
#51				(* THEN *)
#52		
#53					(* Alarm_Val_FB^.1 := TRUE; *)
#54					MOVE		TRUE,Alarm_Val_FB^.1	{LNXT:17|20|-1}
(*) BOOL
085945D8  B8 01 00 00 00                mov eax, 01H
085945DD  8B 55 2A                      mov edx, 42[ebp]
085945E0  84 C0                         test al, al
085945E2  90 75 0C 90 90 90             jne 0000000FH@
085945E8  0F BA 32 01                   btr [edx], 1
085945EC  EB 07 90 90 90                jmp 00000009H@
085945F1  0F BA 2A 01                   bts [edx], 1

#55		
#56		$label3:
#57				(* END_IF *)
#58		
#59		
#60				(* IF o_val_open_fall_FB^ AND NOT di_val_open_state_fall_FB^ *)
#61				LD		di_val_open_state_fall_FB^	{LNXT:20|-1|-1}
(*) UNDEF
085945F5  8B 55 1A                      mov edx, 26[ebp]
085945F8  0F BF 02                      movsx eax, word ptr [edx]

#62				NOT	{LNXT:20|-1|-1}
(*) INT
085945FB  66 F7 D0                      not ax

#63				AND		o_val_open_fall_FB^	{LNXT:20|-1|-1}
(*) INT
085945FE  8B 55 36                      mov edx, 54[ebp]
08594601  33 C9                         xor ecx, ecx
08594603  8A 0A                         mov cl, [edx]
08594605  23 C1                         and eax, ecx

#64				JMPCN	$label4	{LNXT:20|21|24}
(-) INT
08594607  66 85 C0                      test ax, ax
0859460A  90 74 20 90 90 90             je 0859462DH

#65		
#66				(* THEN *)
#67		
#68					(* Alarm_Val_FB^.2 := TRUE; *)
#69					MOVE		TRUE,Alarm_Val_FB^.2	{LNXT:21|24|-1}
(*) INT
08594610  B8 01 00 00 00                mov eax, 01H
08594615  8B 55 2A                      mov edx, 42[ebp]
08594618  84 C0                         test al, al
0859461A  90 75 0C 90 90 90             jne 0000000FH@
08594620  0F BA 32 02                   btr [edx], 2
08594624  EB 07 90 90 90                jmp 00000009H@
08594629  0F BA 2A 02                   bts [edx], 2

#70		
#71		$label4:
#72				(* END_IF *)
#73		
#74		
#75				(* IF o_val_close_fall_FB^ AND NOT di_val_close_state_fall_FB^ *)
#76				LD		di_val_close_state_fall_FB^	{LNXT:24|-1|-1}
(*) UNDEF
0859462D  8B 55 1E                      mov edx, 30[ebp]
08594630  0F BF 02                      movsx eax, word ptr [edx]

#77				NOT	{LNXT:24|-1|-1}
(*) INT
08594633  66 F7 D0                      not ax

#78				AND		o_val_close_fall_FB^	{LNXT:24|-1|-1}
(*) INT
08594636  8B 55 3A                      mov edx, 58[ebp]
08594639  33 C9                         xor ecx, ecx
0859463B  8A 0A                         mov cl, [edx]
0859463D  23 C1                         and eax, ecx

#79				JMPCN	$label5	{LNXT:24|25|29}
(-) INT
0859463F  66 85 C0                      test ax, ax
08594642  90 74 20 90 90 90             je 08594665H

#80		
#81				(* THEN *)
#82		
#83					(* Alarm_Val_FB^.3 := TRUE; *)
#84					MOVE		TRUE,Alarm_Val_FB^.3	{LNXT:25|29|-1}
(*) INT
08594648  B8 01 00 00 00                mov eax, 01H
0859464D  8B 55 2A                      mov edx, 42[ebp]
08594650  84 C0                         test al, al
08594652  90 75 0C 90 90 90             jne 0000000FH@
08594658  0F BA 32 03                   btr [edx], 3
0859465C  EB 07 90 90 90                jmp 00000009H@
08594661  0F BA 2A 03                   bts [edx], 3

#85		
#86		$label5:
#87				(* END_IF *)
#88		
#89		
#90				(* IF Alarm_Val_FB^ > 0 *)
#91				LD		Alarm_Val_FB^	{LNXT:29|-1|-1}
(*) UNDEF
08594665  8B 55 2A                      mov edx, 42[ebp]
08594668  33 C0                         xor eax, eax
0859466A  66 8B 02                      mov ax, [edx]

#92				GT		0	{LNXT:29|-1|-1}
(*) WORD
0859466D  3D 00 00 00 00                cmp eax, 0
08594672  0F 9F C0                      setg al
08594675  25 FF 00 00 00                and eax, 0FFh

#93				JMPCN	$label6	{LNXT:29|30|33}
(-) BOOL
0859467A  84 C0                         test al, al
0859467C  90 74 0E 90 90 90             je 0859468DH

#94		
#95				(* THEN *)
#96		
#97					(* isOK := FALSE; *)
#98					MOVE		FALSE,isOK	{LNXT:30|33|-1}
(*) BOOL
08594682  B8 00 00 00 00                mov eax, 00H
08594687  84 C0                         test al, al
08594689  0F 95 45 19                   setne 25[ebp]

#99		
#100		$label6:
#101				(* END_IF *)
#102		
#103				(* is_check_done := TRUE; *)
#104				MOVE		TRUE,is_check_done	{LNXT:33|38|-1}
(*) BOOL
0859468D  B8 01 00 00 00                mov eax, 01H
08594692  84 C0                         test al, al
08594694  0F 95 45 18                   setne 24[ebp]

#105		
#106		$label1:
#107			(* END_IF *)
#108		
#109			(* check_timer *)
#110			MOVE		start_check,check_timer.IN	{LNXT:38|-1|-1}
(*) BOOL
08594698  33 C0                         xor eax, eax
0859469A  8A 45 17                      mov al, 23[ebp]
0859469D  84 C0                         test al, al
0859469F  0F 95 45 04                   setne 4[ebp]

#111			MOVE		10000,check_timer.PT	{LNXT:38|-1|-1}
(*) BOOL
085946A3  B8 10 27 00 00                mov eax, 2710H
085946A8  89 45 05                      mov 5[ebp], eax

#112			CAL		check_timer	{LNXT:38|-1|-1}
(*) UDINT
085946AB  50                            push eax
085946AC  8B DD                         mov ebx, ebp
085946AE  E8 06 FE FF FF                call 085944B9H ; $$CODE$$+17593
085946B3  58                            pop eax

085946B4  5F                            pop edi
085946B5  5D                            pop ebp

085946B6  C3                            ret


Frame allocation (hex):

	0000       : FB check_timer
	0016 bit  0: VAR should_run_timer
	0017 bit  0: VAR start_check
	0018 bit  0: VAR is_check_done
	0019 bit  0: VAR isOK
	001A       : VAR di_val_open_state_fall_FB
	001E       : VAR di_val_close_state_fall_FB
	0022       : VAR di_val_open_state_R_FB
	0026       : VAR di_val_close_state_R_FB
	002A       : VAR Alarm_Val_FB
	002E       : VAR o_val_open_R_FB
	0032       : VAR o_val_close_R_FB
	0036       : VAR o_val_open_fall_FB
	003A       : VAR o_val_close_fall_FB

END_FUNCTION_BLOCK
**************************************************
	List function block: CheckWashAndStart
**************************************************

FUNCTION_BLOCK CheckWashAndStart

        VAR_IN_OUT
sv_washing_FB : BOOL^;
o_val_open_R_FB : BOOL^;
o_val_close_R_FB : BOOL^;
o_val_open_fall_FB : BOOL^;
o_val_close_fall_FB : BOOL^;
q_start_ats_FB : BOOL^;
ep_time_wash_FB : INT^;
i_val_state_FB : INT^;
di_val_open_state_fall_FB : INT^;
di_val_close_state_fall_FB : INT^;
di_val_open_state_R_FB : INT^;
di_val_close_state_R_FB : BOOL^;
Alarm_Val_FB : WORD^;
	END_VAR

        VAR_OUTPUT
is_running_wash : BOOL;
	END_VAR

        VAR
washing_timer : TON;	{ DE:"локальний FB таймера" }
onWash : BOOL;
checkAlarmVal : CheckAlarmVal;
start_check : BOOL;
	END_VAR

END_FUNCTION_BLOCK

085946B7  55                            push ebp
085946B8  8B EB                         mov ebp, ebx
085946BA  57                            push edi

#0		{SRC:CheckWashAndStart}
#1		(*$WAITSWITCH$*)
#2		
#3		
#4			(* IF sv_washing_FB^ and i_val_state_FB^=1 *)
#5			LD		i_val_state_FB^	{LNXT:1|-1|-1}
(*) UNDEF
085946BB  8B 55 7B                      mov edx, 123[ebp]
085946BE  0F BF 02                      movsx eax, word ptr [edx]

#6			EQ		1	{LNXT:1|-1|-1}
(*) INT
085946C1  3D 01 00 00 00                cmp eax, 1
085946C6  0F 94 C0                      sete al
085946C9  25 FF 00 00 00                and eax, 0FFh

#7			AND		sv_washing_FB^	{LNXT:1|-1|-1}
(*) BOOL
085946CE  8B 55 5F                      mov edx, 95[ebp]
085946D1  8B 55 5F                      mov edx, 95[ebp]
085946D4  33 C9                         xor ecx, ecx
085946D6  8A 0A                         mov cl, [edx]
085946D8  23 C1                         and eax, ecx

#8			JMPCN	$label0	{LNXT:1|2|5}
(-) BOOL
085946DA  84 C0                         test al, al
085946DC  90 74 0E 90 90 90             je 085946EDH

#9		
#10			(* THEN *)
#11		
#12				(* onWash :=true; *)
#13				MOVE		true,onWash	{LNXT:2|5|-1}
(*) BOOL
085946E2  B8 01 00 00 00                mov eax, 01H
085946E7  84 C0                         test al, al
085946E9  0F 95 45 16                   setne 22[ebp]

#14		
#15		$label0:
#16			(* END_IF *)
#17		
#18		
#19			(* IF onWash *)
#20			LD		onWash	{LNXT:5|-1|-1}
(*) UNDEF
085946ED  33 C0                         xor eax, eax
085946EF  8A 45 16                      mov al, 22[ebp]

#21			JMPCN	$label1	{LNXT:5|6|37}
(-) BOOL
085946F2  84 C0                         test al, al
085946F4  0F 84 F0 00 00 00             je 085947EAH

#22		
#23			(* THEN *)
#24		
#25				(* is_running_wash :=true; *)
#26				MOVE		true,is_running_wash	{LNXT:6|7|-1}
(*) BOOL
085946FA  B8 01 00 00 00                mov eax, 01H
085946FF  84 C0                         test al, al
08594701  0F 95 45 5E                   setne 94[ebp]

#27		
#28				(* o_val_close_R_FB^:=true; *)
#29				MOVE		true,o_val_close_R_FB^	{LNXT:7|8|-1}
(*) BOOL
08594705  B8 01 00 00 00                mov eax, 01H
0859470A  8B 55 67                      mov edx, 103[ebp]
0859470D  84 C0                         test al, al
0859470F  0F 95 02                      setne [edx]

#30		
#31				(* o_val_open_R_FB^:=false; *)
#32				MOVE		false,o_val_open_R_FB^	{LNXT:8|10|-1}
(*) BOOL
08594712  B8 00 00 00 00                mov eax, 00H
08594717  8B 55 63                      mov edx, 99[ebp]
0859471A  84 C0                         test al, al
0859471C  0F 95 02                      setne [edx]

#33		
#34				(* o_val_open_fall_FB^:=true; *)
#35				MOVE		true,o_val_open_fall_FB^	{LNXT:10|11|-1}
(*) BOOL
0859471F  B8 01 00 00 00                mov eax, 01H
08594724  8B 55 6B                      mov edx, 107[ebp]
08594727  84 C0                         test al, al
08594729  0F 95 02                      setne [edx]

#36		
#37				(* o_val_close_fall_FB^:=false; *)
#38				MOVE		false,o_val_close_fall_FB^	{LNXT:11|15|-1}
(*) BOOL
0859472C  B8 00 00 00 00                mov eax, 00H
08594731  8B 55 6F                      mov edx, 111[ebp]
08594734  84 C0                         test al, al
08594736  0F 95 02                      setne [edx]

#39		
#40				(* checkAlarmVal *)
#41				MOVE		di_val_open_state_fall_FB,checkAlarmVal.di_val_open_state_fall_FB	{LNXT:15|-1|-1}
(*) BOOL
08594739  8B 55 7F                      mov edx, 127[ebp]
0859473C  8D 02                         lea eax, [edx]
0859473E  89 45 31                      mov 49[ebp], eax

#42				MOVE		di_val_close_state_fall_FB,checkAlarmVal.di_val_close_state_fall_FB	{LNXT:15|-1|-1}
(*) INT^
08594741  8B 95 83 00 00 00             mov edx, 131[ebp]
08594747  8D 02                         lea eax, [edx]
08594749  89 45 35                      mov 53[ebp], eax

#43				MOVE		di_val_open_state_R_FB,checkAlarmVal.di_val_open_state_R_FB	{LNXT:16|-1|-1}
(*) INT^
0859474C  8B 95 87 00 00 00             mov edx, 135[ebp]
08594752  8D 02                         lea eax, [edx]
08594754  89 45 39                      mov 57[ebp], eax

#44				MOVE		di_val_close_state_R_FB,checkAlarmVal.di_val_close_state_R_FB	{LNXT:17|-1|-1}
(*) INT^
08594757  8B 95 8B 00 00 00             mov edx, 139[ebp]
0859475D  8D 02                         lea eax, [edx]
0859475F  89 45 3D                      mov 61[ebp], eax

#45				MOVE		Alarm_Val_FB,checkAlarmVal.Alarm_Val_FB	{LNXT:18|-1|-1}
(*) BOOL^
08594762  8B 95 8F 00 00 00             mov edx, 143[ebp]
08594768  8D 02                         lea eax, [edx]
0859476A  89 45 41                      mov 65[ebp], eax

#46				MOVE		o_val_open_R_FB,checkAlarmVal.o_val_open_R_FB	{LNXT:19|-1|-1}
(*) WORD^
0859476D  8B 55 63                      mov edx, 99[ebp]
08594770  8D 02                         lea eax, [edx]
08594772  89 45 45                      mov 69[ebp], eax

#47				MOVE		o_val_close_R_FB,checkAlarmVal.o_val_close_R_FB	{LNXT:20|-1|-1}
(*) BOOL^
08594775  8B 55 67                      mov edx, 103[ebp]
08594778  8D 02                         lea eax, [edx]
0859477A  89 45 49                      mov 73[ebp], eax

#48				MOVE		o_val_open_fall_FB,checkAlarmVal.o_val_open_fall_FB	{LNXT:21|-1|-1}
(*) BOOL^
0859477D  8B 55 6B                      mov edx, 107[ebp]
08594780  8D 02                         lea eax, [edx]
08594782  89 45 4D                      mov 77[ebp], eax

#49				MOVE		o_val_close_fall_FB,checkAlarmVal.o_val_close_fall_FB	{LNXT:22|-1|-1}
(*) BOOL^
08594785  8B 55 6F                      mov edx, 111[ebp]
08594788  8D 02                         lea eax, [edx]
0859478A  89 45 51                      mov 81[ebp], eax

#50				MOVE		true,checkAlarmVal.start_check	{LNXT:23|-1|-1}
(*) BOOL^
0859478D  B8 01 00 00 00                mov eax, 01H
08594792  84 C0                         test al, al
08594794  0F 95 45 2E                   setne 46[ebp]

#51				CAL		checkAlarmVal	{LNXT:15|28|-1}
(*) BOOL
08594798  50                            push eax
08594799  8B DD                         mov ebx, ebp
0859479B  81 C3 17 00 00 00             add ebx, 23
085947A1  E8 9B FD FF FF                call 08594541H ; $$CODE$$+17729
085947A6  58                            pop eax

#52		
#53		
#54				(* IF checkAlarmVal.is_check_done and checkAlarmVal.isOK *)
#55				LD		checkAlarmVal.is_check_done	{LNXT:28|-1|-1}
(*) UNDEF
085947A7  33 C0                         xor eax, eax
085947A9  8A 45 2F                      mov al, 47[ebp]

#56				AND		checkAlarmVal.isOK	{LNXT:28|-1|-1}
(*) BOOL
085947AC  33 C9                         xor ecx, ecx
085947AE  8A 4D 30                      mov cl, 48[ebp]
085947B1  23 C1                         and eax, ecx

#57				JMPCN	$label3	{LNXT:28|29|31}
(-) BOOL
085947B3  84 C0                         test al, al
085947B5  90 74 15 90 90 90             je 085947CDH

#58		
#59				(* THEN *)
#60		
#61					(* q_start_ats_FB^:=true; *)
#62					MOVE		true,q_start_ats_FB^	{LNXT:29|33|-1}
(*) BOOL
085947BB  B8 01 00 00 00                mov eax, 01H
085947C0  8B 55 73                      mov edx, 115[ebp]
085947C3  84 C0                         test al, al
085947C5  0F 95 02                      setne [edx]

#63					JMP		$label4	{LNXT:28|29|31}
(-) BOOL
085947C8  EB 10 90 90 90                jmp 085947DAH

#64		$label3:
#65		
#66				(* ELSE *)
#67		
#68					(* q_start_ats_FB^:=false; *)
#69					MOVE		false,q_start_ats_FB^	{LNXT:31|33|-1}
(*) BOOL
085947CD  B8 00 00 00 00                mov eax, 00H
085947D2  8B 55 73                      mov edx, 115[ebp]
085947D5  84 C0                         test al, al
085947D7  0F 95 02                      setne [edx]

#70		
#71		$label4:
#72				(* END_IF *)
#73		
#74				(* start_check:=false; *)
#75				MOVE		false,start_check	{LNXT:33|41|-1}
(*) BOOL
085947DA  B8 00 00 00 00                mov eax, 00H
085947DF  84 C0                         test al, al
085947E1  0F 95 45 5D                   setne 93[ebp]

#76				JMP		$label2	{LNXT:5|6|37}
(-) BOOL
085947E5  EB 10 90 90 90                jmp 085947F7H

#77		$label1:
#78		
#79			(* ELSE *)
#80		
#81				(* q_start_ats_FB^:=true; *)
#82				MOVE		true,q_start_ats_FB^	{LNXT:37|41|-1}
(*) BOOL
085947EA  B8 01 00 00 00                mov eax, 01H
085947EF  8B 55 73                      mov edx, 115[ebp]
085947F2  84 C0                         test al, al
085947F4  0F 95 02                      setne [edx]

#83		
#84		$label2:
#85			(* END_IF *)
#86		
#87		
#88			(* IF washing_timer.Q *)
#89			LD		washing_timer.Q	{LNXT:41|-1|-1}
(*) UNDEF
085947F7  33 C0                         xor eax, eax
085947F9  8A 45 09                      mov al, 9[ebp]

#90			JMPCN	$label5	{LNXT:41|42|55}
(-) BOOL
085947FC  84 C0                         test al, al
085947FE  90 74 5A 90 90 90             je 0859485BH

#91		
#92			(* THEN *)
#93		
#94				(* sv_washing_FB^:=false; *)
#95				MOVE		false,sv_washing_FB^	{LNXT:42|43|-1}
(*) BOOL
08594804  B8 00 00 00 00                mov eax, 00H
08594809  8B 55 5F                      mov edx, 95[ebp]
0859480C  84 C0                         test al, al
0859480E  0F 95 02                      setne [edx]

#96		
#97				(* onWash :=false; *)
#98				MOVE		false,onWash	{LNXT:43|46|-1}
(*) BOOL
08594811  B8 00 00 00 00                mov eax, 00H
08594816  84 C0                         test al, al
08594818  0F 95 45 16                   setne 22[ebp]

#99		
#100				(* o_val_close_R_FB^:=false; *)
#101				MOVE		false,o_val_close_R_FB^	{LNXT:46|47|-1}
(*) BOOL
0859481C  B8 00 00 00 00                mov eax, 00H
08594821  8B 55 67                      mov edx, 103[ebp]
08594824  84 C0                         test al, al
08594826  0F 95 02                      setne [edx]

#102		
#103				(* o_val_open_fall_FB^:=false; *)
#104				MOVE		false,o_val_open_fall_FB^	{LNXT:47|49|-1}
(*) BOOL
08594829  B8 00 00 00 00                mov eax, 00H
0859482E  8B 55 6B                      mov edx, 107[ebp]
08594831  84 C0                         test al, al
08594833  0F 95 02                      setne [edx]

#105		
#106				(* o_val_open_R_FB^:=true; *)
#107				MOVE		true,o_val_open_R_FB^	{LNXT:49|50|-1}
(*) BOOL
08594836  B8 01 00 00 00                mov eax, 01H
0859483B  8B 55 63                      mov edx, 99[ebp]
0859483E  84 C0                         test al, al
08594840  0F 95 02                      setne [edx]

#108		
#109				(* o_val_close_fall_FB^:=true; *)
#110				MOVE		true,o_val_close_fall_FB^	{LNXT:50|52|-1}
(*) BOOL
08594843  B8 01 00 00 00                mov eax, 01H
08594848  8B 55 6F                      mov edx, 111[ebp]
0859484B  84 C0                         test al, al
0859484D  0F 95 02                      setne [edx]

#111		
#112				(* is_running_wash :=false; *)
#113				MOVE		false,is_running_wash	{LNXT:52|55|-1}
(*) BOOL
08594850  B8 00 00 00 00                mov eax, 00H
08594855  84 C0                         test al, al
08594857  0F 95 45 5E                   setne 94[ebp]

#114		
#115		$label5:
#116			(* END_IF *)
#117		
#118			(* washing_timer *)
#119			LD		onWash	{LNXT:55|-1|-1}
(*) UNDEF
0859485B  33 C0                         xor eax, eax
0859485D  8A 45 16                      mov al, 22[ebp]

#120			AND		q_start_ats_FB^	{LNXT:55|-1|-1}
(*) BOOL
08594860  8B 55 73                      mov edx, 115[ebp]
08594863  8B 55 73                      mov edx, 115[ebp]
08594866  33 C9                         xor ecx, ecx
08594868  8A 0A                         mov cl, [edx]
0859486A  23 C1                         and eax, ecx

#121			ST		washing_timer.IN	{LNXT:55|-1|-1}
(*) BOOL
0859486C  84 C0                         test al, al
0859486E  0F 95 45 04                   setne 4[ebp]

#122			MOVE		ep_time_wash_FB^,washing_timer.PT	{LNXT:55|-1|-1}
(*) BOOL
08594872  8B 55 77                      mov edx, 119[ebp]
08594875  0F BF 02                      movsx eax, word ptr [edx]
08594878  89 45 05                      mov 5[ebp], eax

#123			CAL		washing_timer	{LNXT:55|-1|-1}
(*) INT
0859487B  50                            push eax
0859487C  8B DD                         mov ebx, ebp
0859487E  E8 36 FC FF FF                call 085944B9H ; $$CODE$$+17593
08594883  58                            pop eax

08594884  5F                            pop edi
08594885  5D                            pop ebp

08594886  C3                            ret


Frame allocation (hex):

	0000       : FB washing_timer
	0016 bit  0: VAR onWash
	0017       : FB checkAlarmVal
	005D bit  0: VAR start_check
	005E bit  0: VAR is_running_wash
	005F       : VAR sv_washing_FB
	0063       : VAR o_val_open_R_FB
	0067       : VAR o_val_close_R_FB
	006B       : VAR o_val_open_fall_FB
	006F       : VAR o_val_close_fall_FB
	0073       : VAR q_start_ats_FB
	0077       : VAR ep_time_wash_FB
	007B       : VAR i_val_state_FB
	007F       : VAR di_val_open_state_fall_FB
	0083       : VAR di_val_close_state_fall_FB
	0087       : VAR di_val_open_state_R_FB
	008B       : VAR di_val_close_state_R_FB
	008F       : VAR Alarm_Val_FB

END_FUNCTION_BLOCK
**************************************************
	List program: ATS_mdb
**************************************************

PROGRAM ATS_mdb

        VAR
res_eta_lcr : UINT;
resp_eta_lcr : ARRAY[0..3] OF INT;
res : INT;
xTON : TON;
	END_VAR

END_PROGRAM

08594890  55                            push ebp
08594891  8B EC                         mov ebp, esp
08594893  60                            pushad

#0		{SRC:ATS_mdb}
#1		(*$WAITSWITCH$*)
#2		
#3			(* res := sysMbMRTU_FC03(	addr := 1, 
#4											base := 257, // 256
#5											no := 4, 
#6											object := ADR(resp_eta_lcr), 
#7											timeout := 200); *)
#8			ADR		resp_eta_lcr	{LNXT:2|8|-1}
(*) UDINT
08594894  B8 CC CC CC CC                mov eax, CCCCCCCCH ; $$DATA$$+12

#9			ST		$$TMP0	{LNXT:2|8|-1}
(*) @INT
08594899  89 05 CC CC CC CC             mov [CCCCCCCCH], eax ; $$DATA$$+20

#10			LDP0		1	{LNXT:2|8|-1}
(*) @INT
#11			sysMbMRTU_FC03		257, 4, $$TMP0, 200	{LNXT:2|8|-1}
(*) @INT
0859489F  68 C8 00 00 00                push 200
085948A4  FF 35 CC CC CC CC             push [CCCCCCCCH] ; $$DATA$$+20
085948AA  68 04 00 00 00                push 4
085948AF  68 01 01 00 00                push 257
085948B4  68 01 00 00 00                push 1
085948B9  B9 CC CC CC CC                mov ecx, CCCCCCCCH ; sysMbMRTU_FC03
085948BE  FF D1                         call ecx
085948C0  81 C4 14 00 00 00             add esp, 20

#12			ST		res	{LNXT:2|8|-1}
(*) UINT
085948C6  66 89 05 CC CC CC CC          mov [CCCCCCCCH], ax ; $$DATA$$+24

#13		
#14			(* ATS22_DUT.Ready 	:= to_bool(resp_eta_lcr[0] And 16#01); *)
#15			LD		resp_eta_lcr[0]	{LNXT:8|9|-1}
(*) UNDEF
085948CD  0F BF 05 CC CC CC CC          movsx eax, word ptr [CCCCCCCCH] ; $$DATA$$+12

#16			AND		16#01	{LNXT:8|9|-1}
(*) INT
085948D4  25 01 00 00 00                and eax, 00000001H

#17			to_bool	{LNXT:8|9|-1}
(*) INT
085948D9  66 85 C0                      test ax, ax
085948DC  0F 95 C0                      setne al

#18			ST		ATS22_DUT.Ready	{LNXT:8|9|-1}
(*) BOOL
085948DF  84 C0                         test al, al
085948E1  0F 95 05 CC CC CC CC          setne [CCCCCCCCH] ; $$DATA$$+26

#19		
#20			(* ATS22_DUT.On 		:= to_bool(resp_eta_lcr[0] And 16#02); *)
#21			LD		resp_eta_lcr[0]	{LNXT:9|10|-1}
(*) UNDEF
085948E8  0F BF 05 CC CC CC CC          movsx eax, word ptr [CCCCCCCCH] ; $$DATA$$+12

#22			AND		16#02	{LNXT:9|10|-1}
(*) INT
085948EF  25 02 00 00 00                and eax, 00000002H

#23			to_bool	{LNXT:9|10|-1}
(*) INT
085948F4  66 85 C0                      test ax, ax
085948F7  0F 95 C0                      setne al

#24			ST		ATS22_DUT.On	{LNXT:9|10|-1}
(*) BOOL
085948FA  84 C0                         test al, al
085948FC  0F 95 05 CC CC CC CC          setne [CCCCCCCCH] ; $$DATA$$+27

#25		
#26			(* ATS22_DUT.Trip 		:= to_bool(resp_eta_lcr[0] And 16#04); *)
#27			LD		resp_eta_lcr[0]	{LNXT:10|11|-1}
(*) UNDEF
08594903  0F BF 05 CC CC CC CC          movsx eax, word ptr [CCCCCCCCH] ; $$DATA$$+12

#28			AND		16#04	{LNXT:10|11|-1}
(*) INT
0859490A  25 04 00 00 00                and eax, 00000004H

#29			to_bool	{LNXT:10|11|-1}
(*) INT
0859490F  66 85 C0                      test ax, ax
08594912  0F 95 C0                      setne al

#30			ST		ATS22_DUT.Trip	{LNXT:10|11|-1}
(*) BOOL
08594915  84 C0                         test al, al
08594917  0F 95 05 CC CC CC CC          setne [CCCCCCCCH] ; $$DATA$$+28

#31		
#32			(* ATS22_DUT.Warning 	:= to_bool(resp_eta_lcr[0] And 16#08); *)
#33			LD		resp_eta_lcr[0]	{LNXT:11|12|-1}
(*) UNDEF
0859491E  0F BF 05 CC CC CC CC          movsx eax, word ptr [CCCCCCCCH] ; $$DATA$$+12

#34			AND		16#08	{LNXT:11|12|-1}
(*) INT
08594925  25 08 00 00 00                and eax, 00000008H

#35			to_bool	{LNXT:11|12|-1}
(*) INT
0859492A  66 85 C0                      test ax, ax
0859492D  0F 95 C0                      setne al

#36			ST		ATS22_DUT.Warning	{LNXT:11|12|-1}
(*) BOOL
08594930  84 C0                         test al, al
08594932  0F 95 05 CC CC CC CC          setne [CCCCCCCCH] ; $$DATA$$+29

#37		
#38			(* ATS22_DUT.LI3 		:= to_bool(resp_eta_lcr[0] And 16#20); *)
#39			LD		resp_eta_lcr[0]	{LNXT:12|13|-1}
(*) UNDEF
08594939  0F BF 05 CC CC CC CC          movsx eax, word ptr [CCCCCCCCH] ; $$DATA$$+12

#40			AND		16#20	{LNXT:12|13|-1}
(*) INT
08594940  25 20 00 00 00                and eax, 00000020H

#41			to_bool	{LNXT:12|13|-1}
(*) INT
08594945  66 85 C0                      test ax, ax
08594948  0F 95 C0                      setne al

#42			ST		ATS22_DUT.LI3	{LNXT:12|13|-1}
(*) BOOL
0859494B  84 C0                         test al, al
0859494D  0F 95 05 CC CC CC CC          setne [CCCCCCCCH] ; $$DATA$$+30

#43		
#44			(* ATS22_DUT.LI2 		:= to_bool(resp_eta_lcr[0] And 16#40); *)
#45			LD		resp_eta_lcr[0]	{LNXT:13|14|-1}
(*) UNDEF
08594954  0F BF 05 CC CC CC CC          movsx eax, word ptr [CCCCCCCCH] ; $$DATA$$+12

#46			AND		16#40	{LNXT:13|14|-1}
(*) INT
0859495B  25 40 00 00 00                and eax, 00000040H

#47			to_bool	{LNXT:13|14|-1}
(*) INT
08594960  66 85 C0                      test ax, ax
08594963  0F 95 C0                      setne al

#48			ST		ATS22_DUT.LI2	{LNXT:13|14|-1}
(*) BOOL
08594966  84 C0                         test al, al
08594968  0F 95 05 CC CC CC CC          setne [CCCCCCCCH] ; $$DATA$$+31

#49		
#50			(* ATS22_DUT.LI1 		:= to_bool(resp_eta_lcr[0] And 16#80); *)
#51			LD		resp_eta_lcr[0]	{LNXT:14|17|-1}
(*) UNDEF
0859496F  0F BF 05 CC CC CC CC          movsx eax, word ptr [CCCCCCCCH] ; $$DATA$$+12

#52			AND		16#80	{LNXT:14|17|-1}
(*) INT
08594976  25 80 00 00 00                and eax, 00000080H

#53			to_bool	{LNXT:14|17|-1}
(*) INT
0859497B  66 85 C0                      test ax, ax
0859497E  0F 95 C0                      setne al

#54			ST		ATS22_DUT.LI1	{LNXT:14|17|-1}
(*) BOOL
08594981  84 C0                         test al, al
08594983  0F 95 05 CC CC CC CC          setne [CCCCCCCCH] ; $$DATA$$+32

#55		
#56			(* ATS_State_bits.0 := ATS22_DUT.Ready; *)
#57			MOVE		ATS22_DUT.Ready,ATS_State_bits.0	{LNXT:17|18|-1}
(*) BOOL
0859498A  33 C0                         xor eax, eax
0859498C  8A 05 CC CC CC CC             mov al, [CCCCCCCCH] ; $$DATA$$+26
08594992  84 C0                         test al, al
08594994  90 75 11 90 90 90             jne 00000014H@
0859499A  66 0F BA 35 CC CC CC CC 00    btr word ptr [CCCCCCCCH], 0 ; %M110+16
085949A3  EB 0C 90 90 90                jmp 0000000EH@
085949A8  66 0F BA 2D CC CC CC CC 00    bts word ptr [CCCCCCCCH], 0 ; %M110+16

#58		
#59			(* ATS_State_bits.1 := ATS22_DUT.On And i_run_ats; *)
#60			LD		ATS22_DUT.On	{LNXT:18|19|-1}
(*) UNDEF
085949B1  33 C0                         xor eax, eax
085949B3  8A 05 CC CC CC CC             mov al, [CCCCCCCCH] ; $$DATA$$+27

#61			AND		i_run_ats	{LNXT:18|19|-1}
(*) BOOL
085949B9  33 C9                         xor ecx, ecx
085949BB  8A 0D CC CC CC CC             mov cl, [CCCCCCCCH] ; $$DATA$$+52
085949C1  23 C1                         and eax, ecx

#62			ST		ATS_State_bits.1	{LNXT:18|19|-1}
(*) BOOL
085949C3  84 C0                         test al, al
085949C5  90 75 11 90 90 90             jne 00000014H@
085949CB  66 0F BA 35 CC CC CC CC 01    btr word ptr [CCCCCCCCH], 1 ; %M110+16
085949D4  EB 0C 90 90 90                jmp 0000000EH@
085949D9  66 0F BA 2D CC CC CC CC 01    bts word ptr [CCCCCCCCH], 1 ; %M110+16

#63		
#64			(* ATS_State_bits.2 := ATS22_DUT.Trip Or Not i_no_alm_ats ; *)
#65			LD		i_no_alm_ats	{LNXT:19|20|-1}
(*) UNDEF
085949E2  33 C0                         xor eax, eax
085949E4  8A 05 CC CC CC CC             mov al, [CCCCCCCCH] ; $$DATA$$+53

#66			NOT	{LNXT:19|20|-1}
(*) BOOL
085949EA  84 C0                         test al, al
085949EC  0F 94 C0                      sete al

#67			OR		ATS22_DUT.Trip	{LNXT:19|20|-1}
(*) BOOL
085949EF  33 C9                         xor ecx, ecx
085949F1  8A 0D CC CC CC CC             mov cl, [CCCCCCCCH] ; $$DATA$$+28
085949F7  0B C1                         or eax, ecx

#68			ST		ATS_State_bits.2	{LNXT:19|20|-1}
(*) BOOL
085949F9  84 C0                         test al, al
085949FB  90 75 11 90 90 90             jne 00000014H@
08594A01  66 0F BA 35 CC CC CC CC 02    btr word ptr [CCCCCCCCH], 2 ; %M110+16
08594A0A  EB 0C 90 90 90                jmp 0000000EH@
08594A0F  66 0F BA 2D CC CC CC CC 02    bts word ptr [CCCCCCCCH], 2 ; %M110+16

#69		
#70			(* ATS_State_bits.3 := ATS22_DUT.Warning; *)
#71			MOVE		ATS22_DUT.Warning,ATS_State_bits.3	{LNXT:20|21|-1}
(*) BOOL
08594A18  33 C0                         xor eax, eax
08594A1A  8A 05 CC CC CC CC             mov al, [CCCCCCCCH] ; $$DATA$$+29
08594A20  84 C0                         test al, al
08594A22  90 75 11 90 90 90             jne 00000014H@
08594A28  66 0F BA 35 CC CC CC CC 03    btr word ptr [CCCCCCCCH], 3 ; %M110+16
08594A31  EB 0C 90 90 90                jmp 0000000EH@
08594A36  66 0F BA 2D CC CC CC CC 03    bts word ptr [CCCCCCCCH], 3 ; %M110+16

#72		
#73			(* ATS_State_bits.4 := ATS22_DUT.Local; *)
#74			MOVE		ATS22_DUT.Local,ATS_State_bits.4	{LNXT:21|22|-1}
(*) BOOL
08594A3F  33 C0                         xor eax, eax
08594A41  8A 05 CC CC CC CC             mov al, [CCCCCCCCH] ; $$DATA$$+34
08594A47  84 C0                         test al, al
08594A49  90 75 11 90 90 90             jne 00000014H@
08594A4F  66 0F BA 35 CC CC CC CC 04    btr word ptr [CCCCCCCCH], 4 ; %M110+16
08594A58  EB 0C 90 90 90                jmp 0000000EH@
08594A5D  66 0F BA 2D CC CC CC CC 04    bts word ptr [CCCCCCCCH], 4 ; %M110+16

#75		
#76			(* ATS_State_bits.5 := ATS22_DUT.Ramping; *)
#77			MOVE		ATS22_DUT.Ramping,ATS_State_bits.5	{LNXT:22|23|-1}
(*) BOOL
08594A66  33 C0                         xor eax, eax
08594A68  8A 05 CC CC CC CC             mov al, [CCCCCCCCH] ; $$DATA$$+35
08594A6E  84 C0                         test al, al
08594A70  90 75 11 90 90 90             jne 00000014H@
08594A76  66 0F BA 35 CC CC CC CC 05    btr word ptr [CCCCCCCCH], 5 ; %M110+16
08594A7F  EB 0C 90 90 90                jmp 0000000EH@
08594A84  66 0F BA 2D CC CC CC CC 05    bts word ptr [CCCCCCCCH], 5 ; %M110+16

#78		
#79			(* ATS_State_bits.6 := ATS22_DUT.LI1; *)
#80			MOVE		ATS22_DUT.LI1,ATS_State_bits.6	{LNXT:23|24|-1}
(*) BOOL
08594A8D  33 C0                         xor eax, eax
08594A8F  8A 05 CC CC CC CC             mov al, [CCCCCCCCH] ; $$DATA$$+32
08594A95  84 C0                         test al, al
08594A97  90 75 11 90 90 90             jne 00000014H@
08594A9D  66 0F BA 35 CC CC CC CC 06    btr word ptr [CCCCCCCCH], 6 ; %M110+16
08594AA6  EB 0C 90 90 90                jmp 0000000EH@
08594AAB  66 0F BA 2D CC CC CC CC 06    bts word ptr [CCCCCCCCH], 6 ; %M110+16

#81		
#82			(* ATS_State_bits.7 := ATS22_DUT.LI2; *)
#83			MOVE		ATS22_DUT.LI2,ATS_State_bits.7	{LNXT:24|25|-1}
(*) BOOL
08594AB4  33 C0                         xor eax, eax
08594AB6  8A 05 CC CC CC CC             mov al, [CCCCCCCCH] ; $$DATA$$+31
08594ABC  84 C0                         test al, al
08594ABE  90 75 11 90 90 90             jne 00000014H@
08594AC4  66 0F BA 35 CC CC CC CC 07    btr word ptr [CCCCCCCCH], 7 ; %M110+16
08594ACD  EB 0C 90 90 90                jmp 0000000EH@
08594AD2  66 0F BA 2D CC CC CC CC 07    bts word ptr [CCCCCCCCH], 7 ; %M110+16

#84		
#85			(* ATS_State_bits.8 := ATS22_DUT.LI3; *)
#86			MOVE		ATS22_DUT.LI3,ATS_State_bits.8	{LNXT:25|28|-1}
(*) BOOL
08594ADB  33 C0                         xor eax, eax
08594ADD  8A 05 CC CC CC CC             mov al, [CCCCCCCCH] ; $$DATA$$+30
08594AE3  84 C0                         test al, al
08594AE5  90 75 11 90 90 90             jne 00000014H@
08594AEB  66 0F BA 35 CC CC CC CC 08    btr word ptr [CCCCCCCCH], 8 ; %M110+16
08594AF4  EB 0C 90 90 90                jmp 0000000EH@
08594AF9  66 0F BA 2D CC CC CC CC 08    bts word ptr [CCCCCCCCH], 8 ; %M110+16

#87		
#88			(* ATS_State_bits.9 := i_pb_loc; *)
#89			MOVE		i_pb_loc,ATS_State_bits.9	{LNXT:28|29|-1}
(*) BOOL
08594B02  0F BF 05 CC CC CC CC          movsx eax, word ptr [CCCCCCCCH] ; $$DATA$$+54
08594B09  66 85 C0                      test ax, ax
08594B0C  90 75 11 90 90 90             jne 00000014H@
08594B12  66 0F BA 35 CC CC CC CC 09    btr word ptr [CCCCCCCCH], 9 ; %M110+16
08594B1B  EB 0C 90 90 90                jmp 0000000EH@
08594B20  66 0F BA 2D CC CC CC CC 09    bts word ptr [CCCCCCCCH], 9 ; %M110+16

#90		
#91			(* ATS_State_bits.10 := i_pb_rem; *)
#92			MOVE		i_pb_rem,ATS_State_bits.10	{LNXT:29|31|-1}
(*) INT
08594B29  0F BF 05 CC CC CC CC          movsx eax, word ptr [CCCCCCCCH] ; $$DATA$$+56
08594B30  66 85 C0                      test ax, ax
08594B33  90 75 11 90 90 90             jne 00000014H@
08594B39  66 0F BA 35 CC CC CC CC 0A    btr word ptr [CCCCCCCCH], 10 ; %M110+16
08594B42  EB 0C 90 90 90                jmp 0000000EH@
08594B47  66 0F BA 2D CC CC CC CC 0A    bts word ptr [CCCCCCCCH], 10 ; %M110+16

#93		
#94		
#95			(* IF i_pb_loc AND not i_pb_rem *)
#96			LD		i_pb_rem	{LNXT:31|-1|-1}
(*) UNDEF
08594B50  0F BF 05 CC CC CC CC          movsx eax, word ptr [CCCCCCCCH] ; $$DATA$$+56

#97			NOT	{LNXT:31|-1|-1}
(*) INT
08594B57  66 F7 D0                      not ax

#98			AND(		i_pb_loc	{LNXT:31|-1|-1}
(*) INT
08594B5A  50                            push eax
08594B5B  0F BF 05 CC CC CC CC          movsx eax, word ptr [CCCCCCCCH] ; $$DATA$$+54

#99			NOT	{LNXT:31|-1|-1}
(*) INT
08594B62  66 F7 D0                      not ax

#100			)	{LNXT:31|-1|-1}
(*) INT
08594B65  8B C8                         mov ecx, eax
08594B67  58                            pop eax
08594B68  23 C1                         and eax, ecx

#101			JMPCN	$label0	{LNXT:31|32|34}
(-) INT
08594B6A  66 85 C0                      test ax, ax
08594B6D  90 74 27 90 90 90             je 08594B97H

#102		
#103			(* THEN *)
#104		
#105				(* ATS_State_bits.11 := TRUE; *)
#106				MOVE		TRUE,ATS_State_bits.11	{LNXT:32|34|-1}
(*) INT
08594B73  B8 01 00 00 00                mov eax, 01H
08594B78  84 C0                         test al, al
08594B7A  90 75 11 90 90 90             jne 00000014H@
08594B80  66 0F BA 35 CC CC CC CC 0B    btr word ptr [CCCCCCCCH], 11 ; %M110+16
08594B89  EB 0C 90 90 90                jmp 0000000EH@
08594B8E  66 0F BA 2D CC CC CC CC 0B    bts word ptr [CCCCCCCCH], 11 ; %M110+16

#107		
#108		$label0:
#109			(* END_IF *)
#110		
#111		
#112			(* IF i_pb_loc AND i_pb_rem *)
#113			LD		i_pb_loc	{LNXT:34|-1|-1}
(*) UNDEF
08594B97  0F BF 05 CC CC CC CC          movsx eax, word ptr [CCCCCCCCH] ; $$DATA$$+54

#114			NOT	{LNXT:34|-1|-1}
(*) INT
08594B9E  66 F7 D0                      not ax

#115			AND		i_pb_rem	{LNXT:34|-1|-1}
(*) INT
08594BA1  0F BF 0D CC CC CC CC          movsx ecx, word ptr [CCCCCCCCH] ; $$DATA$$+56
08594BA8  23 C1                         and eax, ecx

#116			JMPCN	$label1	{LNXT:34|35|37}
(-) INT
08594BAA  66 85 C0                      test ax, ax
08594BAD  90 74 27 90 90 90             je 08594BD7H

#117		
#118			(* THEN *)
#119		
#120				(* ATS_State_bits.11 := FALSE; *)
#121				MOVE		FALSE,ATS_State_bits.11	{LNXT:35|37|-1}
(*) INT
08594BB3  B8 00 00 00 00                mov eax, 00H
08594BB8  84 C0                         test al, al
08594BBA  90 75 11 90 90 90             jne 00000014H@
08594BC0  66 0F BA 35 CC CC CC CC 0B    btr word ptr [CCCCCCCCH], 11 ; %M110+16
08594BC9  EB 0C 90 90 90                jmp 0000000EH@
08594BCE  66 0F BA 2D CC CC CC CC 0B    bts word ptr [CCCCCCCCH], 11 ; %M110+16

#122		
#123		$label1:
#124			(* END_IF *)
#125		
#126		
#127			(* IF i_pb_loc AND not i_pb_rem *)
#128			LD		i_pb_rem	{LNXT:37|-1|-1}
(*) UNDEF
08594BD7  0F BF 05 CC CC CC CC          movsx eax, word ptr [CCCCCCCCH] ; $$DATA$$+56

#129			NOT	{LNXT:37|-1|-1}
(*) INT
08594BDE  66 F7 D0                      not ax

#130			AND		i_pb_loc	{LNXT:37|-1|-1}
(*) INT
08594BE1  0F BF 0D CC CC CC CC          movsx ecx, word ptr [CCCCCCCCH] ; $$DATA$$+54
08594BE8  23 C1                         and eax, ecx

#131			JMPCN	$label2	{LNXT:37|38|43}
(-) INT
08594BEA  66 85 C0                      test ax, ax
08594BED  90 74 27 90 90 90             je 08594C17H

#132		
#133			(* THEN *)
#134		
#135				(* ATS_State_bits.11 := FALSE; *)
#136				MOVE		FALSE,ATS_State_bits.11	{LNXT:38|43|-1}
(*) INT
08594BF3  B8 00 00 00 00                mov eax, 00H
08594BF8  84 C0                         test al, al
08594BFA  90 75 11 90 90 90             jne 00000014H@
08594C00  66 0F BA 35 CC CC CC CC 0B    btr word ptr [CCCCCCCCH], 11 ; %M110+16
08594C09  EB 0C 90 90 90                jmp 0000000EH@
08594C0E  66 0F BA 2D CC CC CC CC 0B    bts word ptr [CCCCCCCCH], 11 ; %M110+16

#137		
#138		$label2:
#139			(* END_IF *)
#140		
#141			(* ATS22_DUT.EtaCurrent := to_byte(SHR(resp_eta_lcr[0] AND 16#3F00, 16#08) * 200 / 63); *)
#142			LD		resp_eta_lcr[0]	{LNXT:43|44|-1}
(*) UNDEF
08594C17  0F BF 05 CC CC CC CC          movsx eax, word ptr [CCCCCCCCH] ; $$DATA$$+12

#143			AND		16#3F00	{LNXT:43|44|-1}
(*) INT
08594C1E  25 00 3F 00 00                and eax, 00003F00H

#144			SHR		16#08	{LNXT:43|44|-1}
(*) INT
08594C23  C1 E8 08                      shr eax, 8

#145			MUL		200	{LNXT:43|44|-1}
(*) DINT
08594C26  B9 C8 00 00 00                mov ecx, 200
08594C2B  F7 E9                         imul ecx

#146			DIV		63	{LNXT:43|44|-1}
(*) DINT
08594C2D  99                            cdq
08594C2E  B9 3F 00 00 00                mov ecx, 63
08594C33  F7 F9                         idiv ecx

#147			to_byte	{LNXT:43|44|-1}
(*) DINT
#148			ST		ATS22_DUT.EtaCurrent	{LNXT:43|44|-1}
(*) BYTE
08594C35  88 05 CC CC CC CC             mov [CCCCCCCCH], al ; $$DATA$$+33

#149		
#150			(* ATS_Current_prsnt	 := ATS22_DUT.EtaCurrent; *)
#151			MOVE		ATS22_DUT.EtaCurrent,ATS_Current_prsnt	{LNXT:44|46|-1}
(*) BYTE
08594C3B  33 C0                         xor eax, eax
08594C3D  8A 05 CC CC CC CC             mov al, [CCCCCCCCH] ; $$DATA$$+33
08594C43  66 89 05 CC CC CC CC          mov [CCCCCCCCH], ax ; %M110+18

#152		
#153			(* ATS22_DUT.Local 	:= to_bool(resp_eta_lcr[0] And 16#4000); *)
#154			LD		resp_eta_lcr[0]	{LNXT:46|47|-1}
(*) UNDEF
08594C4A  0F BF 05 CC CC CC CC          movsx eax, word ptr [CCCCCCCCH] ; $$DATA$$+12

#155			AND		16#4000	{LNXT:46|47|-1}
(*) INT
08594C51  25 00 40 00 00                and eax, 00004000H

#156			to_bool	{LNXT:46|47|-1}
(*) INT
08594C56  66 85 C0                      test ax, ax
08594C59  0F 95 C0                      setne al

#157			ST		ATS22_DUT.Local	{LNXT:46|47|-1}
(*) BOOL
08594C5C  84 C0                         test al, al
08594C5E  0F 95 05 CC CC CC CC          setne [CCCCCCCCH] ; $$DATA$$+34

#158		
#159			(* ATS22_DUT.Ramping 	:= to_bool(resp_eta_lcr[0] And 16#8000); *)
#160			LD		resp_eta_lcr[0]	{LNXT:47|49|-1}
(*) UNDEF
08594C65  0F BF 05 CC CC CC CC          movsx eax, word ptr [CCCCCCCCH] ; $$DATA$$+12

#161			AND		16#8000	{LNXT:47|49|-1}
(*) INT
08594C6C  25 00 80 00 00                and eax, 00008000H

#162			to_bool	{LNXT:47|49|-1}
(*) INT
08594C71  66 85 C0                      test ax, ax
08594C74  0F 95 C0                      setne al

#163			ST		ATS22_DUT.Ramping	{LNXT:47|49|-1}
(*) BOOL
08594C77  84 C0                         test al, al
08594C79  0F 95 05 CC CC CC CC          setne [CCCCCCCCH] ; $$DATA$$+35

#164		
#165			(* ATS22_DUT.Lcr1 := resp_eta_lcr[1]; *)
#166			MOVE		resp_eta_lcr[1],ATS22_DUT.Lcr1	{LNXT:49|50|-1}
(*) BOOL
08594C80  0F BF 05 CC CC CC CC          movsx eax, word ptr [CCCCCCCCH] ; $$DATA$$+14
08594C87  66 89 05 CC CC CC CC          mov [CCCCCCCCH], ax ; $$DATA$$+36

#167		
#168			(* ATS22_DUT.Lcr2 := resp_eta_lcr[2]; *)
#169			MOVE		resp_eta_lcr[2],ATS22_DUT.Lcr2	{LNXT:50|51|-1}
(*) INT
08594C8E  0F BF 05 CC CC CC CC          movsx eax, word ptr [CCCCCCCCH] ; $$DATA$$+16
08594C95  66 89 05 CC CC CC CC          mov [CCCCCCCCH], ax ; $$DATA$$+38

#170		
#171			(* ATS22_DUT.Lcr3 := resp_eta_lcr[3]; *)
#172			MOVE		resp_eta_lcr[3],ATS22_DUT.Lcr3	{LNXT:51|53|-1}
(*) INT
08594C9C  0F BF 05 CC CC CC CC          movsx eax, word ptr [CCCCCCCCH] ; $$DATA$$+18
08594CA3  66 89 05 CC CC CC CC          mov [CCCCCCCCH], ax ; $$DATA$$+40

#173		
#174			(* ATS_Current_L1 := ATS22_DUT.Lcr1; *)
#175			MOVE		ATS22_DUT.Lcr1,ATS_Current_L1	{LNXT:53|54|-1}
(*) INT
08594CAA  0F BF 05 CC CC CC CC          movsx eax, word ptr [CCCCCCCCH] ; $$DATA$$+36
08594CB1  66 89 05 CC CC CC CC          mov [CCCCCCCCH], ax ; %M110+20

#176		
#177			(* ATS_Current_L2 := ATS22_DUT.Lcr2; *)
#178			MOVE		ATS22_DUT.Lcr2,ATS_Current_L2	{LNXT:54|55|-1}
(*) INT
08594CB8  0F BF 05 CC CC CC CC          movsx eax, word ptr [CCCCCCCCH] ; $$DATA$$+38
08594CBF  66 89 05 CC CC CC CC          mov [CCCCCCCCH], ax ; %M110+22

#179		
#180			(* ATS_Current_L3 := ATS22_DUT.Lcr3; *)
#181			MOVE		ATS22_DUT.Lcr3,ATS_Current_L3	{LNXT:55|57|-1}
(*) INT
08594CC6  0F BF 05 CC CC CC CC          movsx eax, word ptr [CCCCCCCCH] ; $$DATA$$+40
08594CCD  66 89 05 CC CC CC CC          mov [CCCCCCCCH], ax ; %M110+24

#182		
#183			(* res := sysMbMRTU_FC03(	addr := 1, 
#184											base := 261, // 260
#185											no := 1, 
#186											object := ADR(resp_eta_lcr), 
#187											timeout := 200); *)
#188			ADR		resp_eta_lcr	{LNXT:57|63|-1}
(*) INT
08594CD4  B8 CC CC CC CC                mov eax, CCCCCCCCH ; $$DATA$$+12

#189			ST		$$TMP0	{LNXT:57|63|-1}
(*) @INT
08594CD9  89 05 CC CC CC CC             mov [CCCCCCCCH], eax ; $$DATA$$+20

#190			LDP0		1	{LNXT:57|63|-1}
(*) @INT
#191			sysMbMRTU_FC03		261, 1, $$TMP0, 200	{LNXT:57|63|-1}
(*) @INT
08594CDF  68 C8 00 00 00                push 200
08594CE4  FF 35 CC CC CC CC             push [CCCCCCCCH] ; $$DATA$$+20
08594CEA  68 01 00 00 00                push 1
08594CEF  68 05 01 00 00                push 261
08594CF4  68 01 00 00 00                push 1
08594CF9  B9 CC CC CC CC                mov ecx, CCCCCCCCH ; sysMbMRTU_FC03
08594CFE  FF D1                         call ecx
08594D00  81 C4 14 00 00 00             add esp, 20

#192			ST		res	{LNXT:57|63|-1}
(*) UINT
08594D06  66 89 05 CC CC CC CC          mov [CCCCCCCCH], ax ; $$DATA$$+24

#193		
#194			(* ATS22_DUT.LcrVoltage	:= resp_eta_lcr[0]; *)
#195			MOVE		resp_eta_lcr[0],ATS22_DUT.LcrVoltage	{LNXT:63|64|-1}
(*) UINT
08594D0D  0F BF 05 CC CC CC CC          movsx eax, word ptr [CCCCCCCCH] ; $$DATA$$+12
08594D14  66 89 05 CC CC CC CC          mov [CCCCCCCCH], ax ; $$DATA$$+42

#196		
#197			(* ATS_Voltage := ATS22_DUT.LcrVoltage; *)
#198			MOVE		ATS22_DUT.LcrVoltage,ATS_Voltage	{LNXT:64|68|-1}
(*) INT
08594D1B  0F BF 05 CC CC CC CC          movsx eax, word ptr [CCCCCCCCH] ; $$DATA$$+42
08594D22  66 89 05 CC CC CC CC          mov [CCCCCCCCH], ax ; %M110+36

#199		
#200			(* res := sysMbMRTU_FC03(	addr := 1, 
#201											base := 280, // 279
#202											no := 1, 
#203											object := ADR(resp_eta_lcr), 
#204											timeout := 200); *)
#205			ADR		resp_eta_lcr	{LNXT:68|74|-1}
(*) INT
08594D29  B8 CC CC CC CC                mov eax, CCCCCCCCH ; $$DATA$$+12

#206			ST		$$TMP0	{LNXT:68|74|-1}
(*) @INT
08594D2E  89 05 CC CC CC CC             mov [CCCCCCCCH], eax ; $$DATA$$+20

#207			LDP0		1	{LNXT:68|74|-1}
(*) @INT
#208			sysMbMRTU_FC03		280, 1, $$TMP0, 200	{LNXT:68|74|-1}
(*) @INT
08594D34  68 C8 00 00 00                push 200
08594D39  FF 35 CC CC CC CC             push [CCCCCCCCH] ; $$DATA$$+20
08594D3F  68 01 00 00 00                push 1
08594D44  68 18 01 00 00                push 280
08594D49  68 01 00 00 00                push 1
08594D4E  B9 CC CC CC CC                mov ecx, CCCCCCCCH ; sysMbMRTU_FC03
08594D53  FF D1                         call ecx
08594D55  81 C4 14 00 00 00             add esp, 20

#209			ST		res	{LNXT:68|74|-1}
(*) UINT
08594D5B  66 89 05 CC CC CC CC          mov [CCCCCCCCH], ax ; $$DATA$$+24

#210		
#211			(* ATS22_DUT.LastFLT 	:= resp_eta_lcr[0]; *)
#212			MOVE		resp_eta_lcr[0],ATS22_DUT.LastFLT	{LNXT:74|75|-1}
(*) UINT
08594D62  0F BF 05 CC CC CC CC          movsx eax, word ptr [CCCCCCCCH] ; $$DATA$$+12
08594D69  66 89 05 CC CC CC CC          mov [CCCCCCCCH], ax ; $$DATA$$+44

#213		
#214			(* ATS_Last_FaultCode := ATS22_DUT.LastFLT; *)
#215			MOVE		ATS22_DUT.LastFLT,ATS_Last_FaultCode	{LNXT:75|78|-1}
(*) INT
08594D70  0F BF 05 CC CC CC CC          movsx eax, word ptr [CCCCCCCCH] ; $$DATA$$+44
08594D77  66 89 05 CC CC CC CC          mov [CCCCCCCCH], ax ; %M110+26

#216		
#217			(* res := sysMbMRTU_FC03(	addr := 1, 
#218											base := 274, // 273
#219											no := 3, 
#220											object := ADR(resp_eta_lcr), 
#221											timeout := 200); *)
#222			ADR		resp_eta_lcr	{LNXT:78|84|-1}
(*) INT
08594D7E  B8 CC CC CC CC                mov eax, CCCCCCCCH ; $$DATA$$+12

#223			ST		$$TMP0	{LNXT:78|84|-1}
(*) @INT
08594D83  89 05 CC CC CC CC             mov [CCCCCCCCH], eax ; $$DATA$$+20

#224			LDP0		1	{LNXT:78|84|-1}
(*) @INT
#225			sysMbMRTU_FC03		274, 3, $$TMP0, 200	{LNXT:78|84|-1}
(*) @INT
08594D89  68 C8 00 00 00                push 200
08594D8E  FF 35 CC CC CC CC             push [CCCCCCCCH] ; $$DATA$$+20
08594D94  68 03 00 00 00                push 3
08594D99  68 12 01 00 00                push 274
08594D9E  68 01 00 00 00                push 1
08594DA3  B9 CC CC CC CC                mov ecx, CCCCCCCCH ; sysMbMRTU_FC03
08594DA8  FF D1                         call ecx
08594DAA  81 C4 14 00 00 00             add esp, 20

#226			ST		res	{LNXT:78|84|-1}
(*) UINT
08594DB0  66 89 05 CC CC CC CC          mov [CCCCCCCCH], ax ; $$DATA$$+24

#227		
#228		
#229			(* IF res <> 0 *)
#230			LD		res	{LNXT:84|-1|-1}
(*) UNDEF
08594DB7  0F BF 05 CC CC CC CC          movsx eax, word ptr [CCCCCCCCH] ; $$DATA$$+24

#231			NE		0	{LNXT:84|-1|-1}
(*) INT
08594DBE  3D 00 00 00 00                cmp eax, 0
08594DC3  0F 95 C0                      setne al
08594DC6  25 FF 00 00 00                and eax, 0FFh

#232			JMPCN	$label3	{LNXT:84|84|86}
(-) BOOL
08594DCB  84 C0                         test al, al
08594DCD  90 74 27 90 90 90             je 08594DF7H

#233		
#234			(* THEN *)
#235		
#236				(* Alarms.6 := true; *)
#237				MOVE		true,Alarms.6	{LNXT:84|86|-1}
(*) BOOL
08594DD3  B8 01 00 00 00                mov eax, 01H
08594DD8  84 C0                         test al, al
08594DDA  90 75 11 90 90 90             jne 00000014H@
08594DE0  66 0F BA 35 CC CC CC CC 06    btr word ptr [CCCCCCCCH], 6 ; %M110+32
08594DE9  EB 0C 90 90 90                jmp 0000000EH@
08594DEE  66 0F BA 2D CC CC CC CC 06    bts word ptr [CCCCCCCCH], 6 ; %M110+32

#238		
#239		$label3:
#240			(* END_IF *)
#241		
#242			(* ATS22_DUT.MotRunTime 		:= resp_eta_lcr[0]; *)
#243			MOVE		resp_eta_lcr[0],ATS22_DUT.MotRunTime	{LNXT:86|87|-1}
(*) WORD
08594DF7  0F BF 05 CC CC CC CC          movsx eax, word ptr [CCCCCCCCH] ; $$DATA$$+12
08594DFE  66 89 05 CC CC CC CC          mov [CCCCCCCCH], ax ; $$DATA$$+46

#244		
#245			(* ATS22_DUT.MotStartCnt 		:= resp_eta_lcr[1]; *)
#246			MOVE		resp_eta_lcr[1],ATS22_DUT.MotStartCnt	{LNXT:87|88|-1}
(*) INT
08594E05  0F BF 05 CC CC CC CC          movsx eax, word ptr [CCCCCCCCH] ; $$DATA$$+14
08594E0C  66 89 05 CC CC CC CC          mov [CCCCCCCCH], ax ; $$DATA$$+48

#247		
#248			(* ATS22_DUT.MotLastStartTime 	:= resp_eta_lcr[2]; *)
#249			MOVE		resp_eta_lcr[2],ATS22_DUT.MotLastStartTime	{LNXT:88|90|-1}
(*) INT
08594E13  0F BF 05 CC CC CC CC          movsx eax, word ptr [CCCCCCCCH] ; $$DATA$$+16
08594E1A  66 89 05 CC CC CC CC          mov [CCCCCCCCH], ax ; $$DATA$$+50

#250		
#251			(* ATS_RunTime_Hors	:= to_word(ATS22_DUT.MotRunTime); *)
#252			LDP0		ATS22_DUT.MotRunTime	{LNXT:90|91|-1}
(*) INT
#253			to_word	{LNXT:90|91|-1}
(*) INT
08594E21  0F BF 05 CC CC CC CC          movsx eax, word ptr [CCCCCCCCH] ; $$DATA$$+46

#254			ST		ATS_RunTime_Hors	{LNXT:90|91|-1}
(*) WORD
08594E28  66 89 05 CC CC CC CC          mov [CCCCCCCCH], ax ; %M110+28

#255		
#256			(* ATS_OnTimes_Cnt		:= to_word(ATS22_DUT.MotStartCnt); *)
#257			LDP0		ATS22_DUT.MotStartCnt	{LNXT:91|2|-1}
(*) WORD
#258			to_word	{LNXT:91|2|-1}
(*) WORD
08594E2F  0F BF 05 CC CC CC CC          movsx eax, word ptr [CCCCCCCCH] ; $$DATA$$+48

#259			ST		ATS_OnTimes_Cnt	{LNXT:91|2|-1}
(*) WORD
08594E36  66 89 05 CC CC CC CC          mov [CCCCCCCCH], ax ; %M110+30

08594E3D  61                            popad
08594E3E  5D                            pop ebp

08594E3F  C3                            ret

END_PROGRAM


**************************************************
	Target variable image generation
**************************************************


*** INPUT:
08594E40  55                            push ebp
08594E41  8B EC                         mov ebp, esp

08594E43  8A 0D CC CC CC CC             mov cl, [CCCCCCCCH] ; %I0+7
08594E49  88 0D CC CC CC CC             mov [CCCCCCCCH], cl ; $$DATA$$+52

08594E4F  8A 0D CC CC CC CC             mov cl, [CCCCCCCCH] ; %I0+6
08594E55  88 0D CC CC CC CC             mov [CCCCCCCCH], cl ; $$DATA$$+53

08594E5B  66 8B 0D CC CC CC CC          mov cx, [CCCCCCCCH] ; %I1+12
08594E62  66 89 0D CC CC CC CC          mov [CCCCCCCCH], cx ; $$DATA$$+54

08594E69  66 8B 0D CC CC CC CC          mov cx, [CCCCCCCCH] ; %I1+14
08594E70  66 89 0D CC CC CC CC          mov [CCCCCCCCH], cx ; $$DATA$$+56

08594E77  8B E5                         mov esp, ebp
08594E79  5D                            pop ebp

08594E7A  C3                            ret


*** OUTPUT:
08594E7B  55                            push ebp
08594E7C  8B EC                         mov ebp, esp

08594E7E  8B E5                         mov esp, ebp
08594E80  5D                            pop ebp

08594E81  C3                            ret



**************************************************
	Task Background init code
**************************************************

08594E82  55                            push ebp
08594E83  8B EC                         mov ebp, esp

08594E85  8B E5                         mov esp, ebp
08594E87  5D                            pop ebp

08594E88  C3                            ret

**************************************************
	List program: sr_init_counters
**************************************************

PROGRAM sr_init_counters

END_PROGRAM

08594EA0  55                            push ebp
08594EA1  8B EC                         mov ebp, esp
08594EA3  60                            pushad

#0		{SRC:sr_init_counters}
#1		(*$WAITSWITCH$*)
#2		
#3			(* kw_counter 	:= epprom_kw_cnt; *)
#4			MOVE		epprom_kw_cnt,kw_counter	{LNXT:1|2|-1}
(*) UDINT
08594EA4  8B 05 CC CC CC CC             mov eax, [CCCCCCCCH] ; %M101+8
08594EAA  89 05 CC CC CC CC             mov [CCCCCCCCH], eax ; %M110+4

#5		
#6			(* q_counter	:= epprom_q_cnt; *)
#7			MOVE		epprom_q_cnt,q_counter	{LNXT:2|1|-1}
(*) DWORD
08594EB0  8B 05 CC CC CC CC             mov eax, [CCCCCCCCH] ; %M101+0
08594EB6  89 05 CC CC CC CC             mov [CCCCCCCCH], eax ; %M110+8

08594EBC  61                            popad
08594EBD  5D                            pop ebp

08594EBE  C3                            ret

END_PROGRAM


**************************************************
	Target variable image generation
**************************************************


*** INPUT:
08594EBF  C3                            ret


*** OUTPUT:
08594EC0  C3                            ret



**************************************************
	Task Boot init code
**************************************************

08594EC1  55                            push ebp
08594EC2  8B EC                         mov ebp, esp

08594EC4  8B E5                         mov esp, ebp
08594EC6  5D                            pop ebp

08594EC7  C3                            ret

**************************************************
	List program: init_val
**************************************************

PROGRAM init_val

END_PROGRAM

08594EE0  55                            push ebp
08594EE1  8B EC                         mov ebp, esp
08594EE3  60                            pushad

#0		{SRC:init_val}
#1		(*$WAITSWITCH$*)
#2		
#3		
#4			(* IF di_val_close_state_R *)
#5			LD		di_val_close_state_R	{LNXT:1|-1|-1}
(*) UNDEF
08594EE4  33 C0                         xor eax, eax
08594EE6  8A 05 CC CC CC CC             mov al, [CCCCCCCCH] ; %I0+0

#6			NOT	{LNXT:1|-1|-1}
(*) BOOL
08594EEC  84 C0                         test al, al
08594EEE  0F 94 C0                      sete al

#7			JMPCN	$label0	{LNXT:1|2|6}
(-) BOOL
08594EF1  84 C0                         test al, al
08594EF3  90 74 1F 90 90 90             je 08594F15H

#8		
#9			(* THEN *)
#10		
#11				(* o_val_close_R:=true; *)
#12				MOVE		true,o_val_close_R	{LNXT:2|3|-1}
(*) BOOL
08594EF9  B8 01 00 00 00                mov eax, 01H
08594EFE  84 C0                         test al, al
08594F00  0F 95 05 CC CC CC CC          setne [CCCCCCCCH] ; %Q1+3

#13		
#14				(* o_val_open_R:=false; *)
#15				MOVE		false,o_val_open_R	{LNXT:3|6|-1}
(*) BOOL
08594F07  B8 00 00 00 00                mov eax, 00H
08594F0C  84 C0                         test al, al
08594F0E  0F 95 05 CC CC CC CC          setne [CCCCCCCCH] ; %Q1+2

#16		
#17		$label0:
#18			(* END_IF *)
#19		
#20		
#21			(* IF di_val_close_state_fall = 0 *)
#22			LD		di_val_close_state_fall	{LNXT:6|-1|-1}
(*) UNDEF
08594F15  0F BF 05 CC CC CC CC          movsx eax, word ptr [CCCCCCCCH] ; %I1+8

#23			EQ		0	{LNXT:6|-1|-1}
(*) INT
08594F1C  3D 00 00 00 00                cmp eax, 0
08594F21  0F 94 C0                      sete al
08594F24  25 FF 00 00 00                and eax, 0FFh

#24			JMPCN	$label1	{LNXT:6|7|1}
(-) BOOL
08594F29  84 C0                         test al, al
08594F2B  90 74 1F 90 90 90             je 08594F4DH

#25		
#26			(* THEN *)
#27		
#28				(* o_val_close_fall:=true; *)
#29				MOVE		true,o_val_close_fall	{LNXT:7|8|-1}
(*) BOOL
08594F31  B8 01 00 00 00                mov eax, 01H
08594F36  84 C0                         test al, al
08594F38  0F 95 05 CC CC CC CC          setne [CCCCCCCCH] ; %Q1+1

#30		
#31				(* o_val_open_fall:=false; *)
#32				MOVE		false,o_val_open_fall	{LNXT:8|1|-1}
(*) BOOL
08594F3F  B8 00 00 00 00                mov eax, 00H
08594F44  84 C0                         test al, al
08594F46  0F 95 05 CC CC CC CC          setne [CCCCCCCCH] ; %Q1+0

08594F4D  61                            popad
08594F4E  5D                            pop ebp

08594F4F  C3                            ret

END_PROGRAM


**************************************************
	Target variable image generation
**************************************************


*** INPUT:
08594F50  C3                            ret


*** OUTPUT:
08594F51  C3                            ret



**************************************************
	Task Init init code
**************************************************

08594F52  55                            push ebp
08594F53  8B EC                         mov ebp, esp

08594F55  8B E5                         mov esp, ebp
08594F57  5D                            pop ebp

08594F58  C3                            ret

**************************************************
	List program: InitParDB
**************************************************

PROGRAM InitParDB

        VAR
warningsKiller : USINT;
dummyCrc32 : UDINT;
	END_VAR

END_PROGRAM

08594F70  55                            push ebp
08594F71  8B EC                         mov ebp, esp
08594F73  60                            pushad

#0		{SRC:InitParDB}
#1		(*$WAITSWITCH$*)
#2		
#3			(* dummyCrc32 := 541599759; *)
#4			MOVE		541599759,dummyCrc32	{LNXT:3|5|-1}
(*) UDINT
08594F74  B8 0F 28 48 20                mov eax, 2048280FH
08594F79  89 05 CC CC CC CC             mov [CCCCCCCCH], eax ; $$DATA$$+60

#5		
#6			(* warningsKiller := sysDBase_SetExtTable( ADR( $$ParDB ), $$ParDBLength ); *)
#7			ADR		$$ParDB	{LNXT:5|3|-1}
(*) UDINT
08594F7F  B8 CC CC CC CC                mov eax, CCCCCCCCH ; $$CODE$$+336

#8			sysDBase_SetExtTable		$$ParDBLength	{LNXT:5|3|-1}
(*) @USINT
08594F84  68 16 00 00 00                push 22
08594F89  8B C8                         mov ecx, eax
08594F8B  51                            push ecx
08594F8C  B9 CC CC CC CC                mov ecx, CCCCCCCCH ; sysDBase_SetExtTable
08594F91  FF D1                         call ecx
08594F93  81 C4 08 00 00 00             add esp, 8

#9			ST		warningsKiller	{LNXT:5|3|-1}
(*) USINT
08594F99  88 05 CC CC CC CC             mov [CCCCCCCCH], al ; $$DATA$$+59

08594F9F  61                            popad
08594FA0  5D                            pop ebp

08594FA1  C3                            ret

END_PROGRAM


**************************************************
	Target variable image generation
**************************************************


*** INPUT:
08594FA2  C3                            ret


*** OUTPUT:
08594FA3  C3                            ret



**************************************************
	Task Serv init code
**************************************************

08594FA4  55                            push ebp
08594FA5  8B EC                         mov ebp, esp

08594FA7  8B E5                         mov esp, ebp
08594FA9  5D                            pop ebp

08594FAA  C3                            ret

**************************************************
	List program: sr_pressure
**************************************************

PROGRAM sr_pressure

        VAR
tmp_test : INT;
	END_VAR

END_PROGRAM

08594FC0  55                            push ebp
08594FC1  8B EC                         mov ebp, esp
08594FC3  60                            pushad

#0		{SRC:sr_pressure}
#1		(*$WAITSWITCH$*)
#2		
#3			(* Pressure := to_int(to_real(i_adc_pressure )/10); *)
#4			LDP0		i_adc_pressure	{LNXT:2|2|-1}
(*) UDINT
#5			to_real	{LNXT:2|2|-1}
(*) UDINT
08594FC4  0F BF 05 CC CC CC CC          movsx eax, word ptr [CCCCCCCCH] ; $$DATA$$+240
08594FCB  50                            push eax
08594FCC  DB 04 24                      fild dword ptr [esp]
08594FCF  58                            pop eax

#6			DIV		10	{LNXT:2|2|-1}
(*) REAL
08594FD0  68 0A 00 00 00                push 10
08594FD5  DA 34 24                      fidiv [esp]
08594FD8  81 C4 04 00 00 00             add esp, 4

#7			to_int	{LNXT:2|2|-1}
(*) REAL
08594FDE  81 EC 08 00 00 00             sub esp, 8
08594FE4  DF 3C 24                      fistp qword ptr [esp]
08594FE7  58                            pop eax
08594FE8  81 C4 04 00 00 00             add esp, 4

#8			ST		Pressure	{LNXT:2|2|-1}
(*) INT
08594FEE  66 89 05 CC CC CC CC          mov [CCCCCCCCH], ax ; %M110+0

END_PROGRAM
**************************************************
	List program: sr_counters
**************************************************

PROGRAM sr_counters

        VAR
kw_trig : R_TRIG;
q_trig : R_TRIG;
kw_pulses_per_acs : UINT;
q_pulses_per_acs : UINT;
test_freq : UDINT;
	END_VAR

END_PROGRAM

#0		{SRC:sr_counters}
#1		(*$WAITSWITCH$*)
#2		
#3			(* kw_pulses_per_acs 	:= 8000; *)
#4			MOVE		8000,kw_pulses_per_acs	{LNXT:2|3|-1}
(*) UDINT
08594FF5  B8 40 1F 00 00                mov eax, 1F40H
08594FFA  66 89 05 CC CC CC CC          mov [CCCCCCCCH], ax ; $$DATA$$+236

#5		
#6			(* q_pulses_per_acs	:= 1; *)
#7			MOVE		1,q_pulses_per_acs	{LNXT:3|15|-1}
(*) UINT
08595001  B8 01 00 00 00                mov eax, 01H
08595006  66 89 05 CC CC CC CC          mov [CCCCCCCCH], ax ; $$DATA$$+238

#8		
#9		
#10			(* IF fdi_q_cnt >= q_pulses_per_acs *)
#11			LD		fdi_q_cnt	{LNXT:15|-1|-1}
(*) UNDEF
0859500D  8B 05 CC CC CC CC             mov eax, [CCCCCCCCH] ; %M500+0

#12			GE		q_pulses_per_acs	{LNXT:15|-1|-1}
(*) UDINT
08595013  33 C9                         xor ecx, ecx
08595015  66 8B 0D CC CC CC CC          mov cx, [CCCCCCCCH] ; $$DATA$$+238
0859501C  3B C1                         cmp eax, ecx
0859501E  0F 93 C0                      setae al
08595021  25 FF 00 00 00                and eax, 0FFh

#13			JMPCN	$label0	{LNXT:15|16|20}
(-) BOOL
08595026  84 C0                         test al, al
08595028  90 74 22 90 90 90             je 0859504DH

#14		
#15			(* THEN *)
#16		
#17				(* q_counter := q_counter + 1; *)
#18				LD		q_counter	{LNXT:16|17|-1}
(*) UNDEF
0859502E  8B 05 CC CC CC CC             mov eax, [CCCCCCCCH] ; %M110+8

#19				ADD		1	{LNXT:16|17|-1}
(*) DWORD
08595034  05 01 00 00 00                add eax, 1

#20				ST		q_counter	{LNXT:16|17|-1}
(*) DWORD
08595039  89 05 CC CC CC CC             mov [CCCCCCCCH], eax ; %M110+8

#21		
#22				(* fdi_q_reset := true; *)
#23				MOVE		true,fdi_q_reset	{LNXT:17|20|-1}
(*) DWORD
0859503F  B8 01 00 00 00                mov eax, 01H
08595044  84 C0                         test al, al
08595046  0F 95 05 CC CC CC CC          setne [CCCCCCCCH] ; %M550+0

#24		
#25		$label0:
#26			(* END_IF *)
#27		
#28			(* q_value := to_int((3600 * to_real(fdi_q_freq)) / (to_real(q_pulses_per_acs) / 1)); *)
#29			LDP0		fdi_q_freq	{LNXT:20|2|-1}
(*) BOOL
#30			to_real	{LNXT:20|2|-1}
(*) BOOL
0859504D  8B 05 CC CC CC CC             mov eax, [CCCCCCCCH] ; %M500+4
08595053  68 00 00 00 00                push 0
08595058  50                            push eax
08595059  DF 2C 24                      fild qword ptr [esp]
0859505C  81 C4 08 00 00 00             add esp, 8

#31			MUL		3600	{LNXT:20|2|-1}
(*) REAL
08595062  68 10 0E 00 00                push 3600
08595067  DA 0C 24                      fimul [esp]
0859506A  81 C4 04 00 00 00             add esp, 4

#32			DIV(		0	{LNXT:20|2|-1}
(*) REAL
08595070  81 EC 04 00 00 00             sub esp, 4
08595076  D9 1C 24                      fstp dword ptr [esp]
08595079  B8 00 00 00 00                mov eax, 00H

#33			LDP0		q_pulses_per_acs	{LNXT:20|2|-1}
(*) USINT
#34			to_real	{LNXT:20|2|-1}
(*) USINT
0859507E  33 C0                         xor eax, eax
08595080  66 8B 05 CC CC CC CC          mov ax, [CCCCCCCCH] ; $$DATA$$+238
08595087  68 00 00 00 00                push 0
0859508C  50                            push eax
0859508D  DF 2C 24                      fild qword ptr [esp]
08595090  81 C4 08 00 00 00             add esp, 8

#35			DIV		1	{LNXT:20|2|-1}
(*) REAL
08595096  68 01 00 00 00                push 1
0859509B  DA 34 24                      fidiv [esp]
0859509E  81 C4 04 00 00 00             add esp, 4

#36			)	{LNXT:20|2|-1}
(*) REAL
085950A4  81 EC 04 00 00 00             sub esp, 4
085950AA  D9 1C 24                      fstp dword ptr [esp]
085950AD  D9 44 24 04                   fld dword ptr 4[esp]
085950B1  D8 34 24                      fdiv dword ptr [esp]
085950B4  81 C4 08 00 00 00             add esp, 8

#37			to_int	{LNXT:20|2|-1}
(*) REAL
085950BA  81 EC 08 00 00 00             sub esp, 8
085950C0  DF 3C 24                      fistp qword ptr [esp]
085950C3  58                            pop eax
085950C4  81 C4 04 00 00 00             add esp, 4

#38			ST		q_value	{LNXT:20|2|-1}
(*) INT
085950CA  66 89 05 CC CC CC CC          mov [CCCCCCCCH], ax ; %M110+14

END_PROGRAM
**************************************************
	List program: sr_save_counters
**************************************************

PROGRAM sr_save_counters

        VAR
power_err : R_TRIG;
ton_start_up : TON;
res_q : BOOL;
res_kw : BOOL;
	END_VAR

END_PROGRAM

#0		{SRC:sr_save_counters}
#1		(*$WAITSWITCH$*)
#2		
#3			(* ton_start_up *)
#4			MOVE		true,ton_start_up.IN	{LNXT:1|-1|-1}
(*) UDINT
085950D1  B8 01 00 00 00                mov eax, 01H
085950D6  84 C0                         test al, al
085950D8  0F 95 05 CC CC CC CC          setne [CCCCCCCCH] ; $$DATA$$+246

#5			MOVE		5000,ton_start_up.PT	{LNXT:1|-1|-1}
(*) BOOL
085950DF  B8 88 13 00 00                mov eax, 1388H
085950E4  89 05 CC CC CC CC             mov [CCCCCCCCH], eax ; $$DATA$$+247

#6			CAL		ton_start_up	{LNXT:1|2|-1}
(*) UDINT
085950EA  50                            push eax
085950EB  BB CC CC CC CC                mov ebx, CCCCCCCCH ; $$DATA$$+242
085950F0  E8 C4 F3 FF FF                call 085944B9H ; $$CODE$$+17593
085950F5  58                            pop eax

#7		
#8			(* power_err *)
#9			LD		ton_start_up.Q	{LNXT:2|-1|-1}
(*) UNDEF
085950F6  33 C0                         xor eax, eax
085950F8  8A 05 CC CC CC CC             mov al, [CCCCCCCCH] ; $$DATA$$+251

#10			AND		i_rnpp	{LNXT:2|-1|-1}
(*) BOOL
085950FE  33 C9                         xor ecx, ecx
08595100  8A 0D CC CC CC CC             mov cl, [CCCCCCCCH] ; $$DATA$$+233
08595106  23 C1                         and eax, ecx

#11			ST		power_err.clk	{LNXT:2|-1|-1}
(*) BOOL
08595108  84 C0                         test al, al
0859510A  0F 95 05 CC CC CC CC          setne [CCCCCCCCH] ; $$DATA$$+265

#12			CAL		power_err	{LNXT:2|3|-1}
(*) BOOL
08595111  50                            push eax
08595112  BB CC CC CC CC                mov ebx, CCCCCCCCH ; $$DATA$$+264
08595117  E8 74 F3 FF FF                call 08594490H ; $$CODE$$+17552
0859511C  58                            pop eax

#13		
#14		
#15			(* IF power_err.q *)
#16			LD		power_err.q	{LNXT:3|-1|-1}
(*) UNDEF
0859511D  33 C0                         xor eax, eax
0859511F  8A 05 CC CC CC CC             mov al, [CCCCCCCCH] ; $$DATA$$+266

#17			JMPCN	$label0	{LNXT:3|4|1}
(-) BOOL
08595125  84 C0                         test al, al
08595127  0F 84 82 00 00 00             je 085951AFH

#18		
#19			(* THEN *)
#20		
#21		
#22				(* IF epprom_q_cnt <> q_counter *)
#23				LD		epprom_q_cnt	{LNXT:4|-1|-1}
(*) UNDEF
0859512D  8B 05 CC CC CC CC             mov eax, [CCCCCCCCH] ; %M101+0

#24				NE		q_counter	{LNXT:4|-1|-1}
(*) DWORD
08595133  3B 05 CC CC CC CC             cmp eax, [CCCCCCCCH] ; %M110+8
08595139  0F 95 C0                      setne al
0859513C  25 FF 00 00 00                and eax, 0FFh

#25				JMPCN	$label1	{LNXT:4|4|5}
(-) BOOL
08595141  84 C0                         test al, al
08595143  90 74 28 90 90 90             je 0859516EH

#26		
#27				(* THEN *)
#28		
#29					(* res_q := sysWriteParUINT(ADR(epprom_q_cnt), q_counter); *)
#30					ADR		epprom_q_cnt	{LNXT:4|5|-1}
(*) BOOL
08595149  B8 CC CC CC CC                mov eax, CCCCCCCCH ; %M101+0

#31					sysWriteParUINT		q_counter	{LNXT:4|5|-1}
(*) @DWORD
0859514E  8B 0D CC CC CC CC             mov ecx, [CCCCCCCCH] ; %M110+8
08595154  51                            push ecx
08595155  8B C8                         mov ecx, eax
08595157  51                            push ecx
08595158  B9 CC CC CC CC                mov ecx, CCCCCCCCH ; sysWriteParUINT
0859515D  FF D1                         call ecx
0859515F  81 C4 08 00 00 00             add esp, 8

#32					ST		res_q	{LNXT:4|5|-1}
(*) BOOL
08595165  84 C0                         test al, al
08595167  0F 95 05 CC CC CC CC          setne [CCCCCCCCH] ; $$DATA$$+235

#33		
#34		$label1:
#35				(* END_IF *)
#36		
#37		
#38				(* IF epprom_kw_cnt <> kw_counter *)
#39				LD		epprom_kw_cnt	{LNXT:5|-1|-1}
(*) UNDEF
0859516E  8B 05 CC CC CC CC             mov eax, [CCCCCCCCH] ; %M101+8

#40				NE		kw_counter	{LNXT:5|-1|-1}
(*) DWORD
08595174  3B 05 CC CC CC CC             cmp eax, [CCCCCCCCH] ; %M110+4
0859517A  0F 95 C0                      setne al
0859517D  25 FF 00 00 00                and eax, 0FFh

#41				JMPCN	$label2	{LNXT:5|5|1}
(-) BOOL
08595182  84 C0                         test al, al
08595184  90 74 28 90 90 90             je 085951AFH

#42		
#43				(* THEN *)
#44		
#45					(* res_kw := sysWriteParUINT(ADR(epprom_kw_cnt), kw_counter); *)
#46					ADR		epprom_kw_cnt	{LNXT:5|1|-1}
(*) BOOL
0859518A  B8 CC CC CC CC                mov eax, CCCCCCCCH ; %M101+8

#47					sysWriteParUINT		kw_counter	{LNXT:5|1|-1}
(*) @DWORD
0859518F  8B 0D CC CC CC CC             mov ecx, [CCCCCCCCH] ; %M110+4
08595195  51                            push ecx
08595196  8B C8                         mov ecx, eax
08595198  51                            push ecx
08595199  B9 CC CC CC CC                mov ecx, CCCCCCCCH ; sysWriteParUINT
0859519E  FF D1                         call ecx
085951A0  81 C4 08 00 00 00             add esp, 8

#48					ST		res_kw	{LNXT:5|1|-1}
(*) BOOL
085951A6  84 C0                         test al, al
085951A8  0F 95 05 CC CC CC CC          setne [CCCCCCCCH] ; $$DATA$$+275

END_PROGRAM
**************************************************
	List program: sr_ATS_Ctrl
**************************************************

PROGRAM sr_ATS_Ctrl

        VAR
TON_StartUp_1 : TON;
TON_StartUp_2 : TON;
stopping_timer : TON;
downtimeIN : BOOL;
washing_timer : TON;
checkWashAndStart : CheckWashAndStart;
isRunningWash : BOOL;
onWash : BOOL := false;
time_sec : INT := 4000;
	END_VAR

END_PROGRAM

#0		{SRC:sr_ATS_Ctrl}
#1		(*$WAITSWITCH$*)
#2		
#3		
#4			(* IF i_pb_rem = 1 And
#5		Not Alarms.0 And 
#6		Not Alarms.3 And 
#7		Not Alarms.4 And 
#8		Not Alarms.5 And 
#9		Not Alarms.7 *)
#10			LD		Alarms.7	{LNXT:2|-1|-1}
(*) UNDEF
085951AF  33 C0                         xor eax, eax
085951B1  66 8B 05 CC CC CC CC          mov ax, [CCCCCCCCH] ; %M110+32
085951B8  C1 E8 07                      shr eax, 7
085951BB  25 01 00 00 00                and eax, 1

#11			NOT	{LNXT:2|-1|-1}
(*) BOOL
085951C0  84 C0                         test al, al
085951C2  0F 94 C0                      sete al

#12			AND(		Alarms.5	{LNXT:2|-1|-1}
(*) BOOL
085951C5  50                            push eax
085951C6  33 C0                         xor eax, eax
085951C8  66 8B 05 CC CC CC CC          mov ax, [CCCCCCCCH] ; %M110+32
085951CF  C1 E8 05                      shr eax, 5
085951D2  25 01 00 00 00                and eax, 1

#13			NOT	{LNXT:2|-1|-1}
(*) BOOL
085951D7  84 C0                         test al, al
085951D9  0F 94 C0                      sete al

#14			AND(		Alarms.4	{LNXT:2|-1|-1}
(*) BOOL
085951DC  50                            push eax
085951DD  33 C0                         xor eax, eax
085951DF  66 8B 05 CC CC CC CC          mov ax, [CCCCCCCCH] ; %M110+32
085951E6  C1 E8 04                      shr eax, 4
085951E9  25 01 00 00 00                and eax, 1

#15			NOT	{LNXT:2|-1|-1}
(*) BOOL
085951EE  84 C0                         test al, al
085951F0  0F 94 C0                      sete al

#16			AND(		Alarms.3	{LNXT:2|-1|-1}
(*) BOOL
085951F3  50                            push eax
085951F4  33 C0                         xor eax, eax
085951F6  66 8B 05 CC CC CC CC          mov ax, [CCCCCCCCH] ; %M110+32
085951FD  C1 E8 03                      shr eax, 3
08595200  25 01 00 00 00                and eax, 1

#17			NOT	{LNXT:2|-1|-1}
(*) BOOL
08595205  84 C0                         test al, al
08595207  0F 94 C0                      sete al

#18			AND(		Alarms.0	{LNXT:2|-1|-1}
(*) BOOL
0859520A  50                            push eax
0859520B  33 C0                         xor eax, eax
0859520D  66 8B 05 CC CC CC CC          mov ax, [CCCCCCCCH] ; %M110+32
08595214  25 01 00 00 00                and eax, 1

#19			NOT	{LNXT:2|-1|-1}
(*) BOOL
08595219  84 C0                         test al, al
0859521B  0F 94 C0                      sete al

#20			AND(		i_pb_rem	{LNXT:2|-1|-1}
(*) BOOL
0859521E  50                            push eax
0859521F  0F BF 05 CC CC CC CC          movsx eax, word ptr [CCCCCCCCH] ; $$DATA$$+64

#21			EQ		1	{LNXT:2|-1|-1}
(*) INT
08595226  3D 01 00 00 00                cmp eax, 1
0859522B  0F 94 C0                      sete al
0859522E  25 FF 00 00 00                and eax, 0FFh

#22			)	{LNXT:2|-1|-1}
(*) BOOL
08595233  8B C8                         mov ecx, eax
08595235  58                            pop eax
08595236  23 C1                         and eax, ecx

#23			)	{LNXT:2|-1|-1}
(*) BOOL
08595238  8B C8                         mov ecx, eax
0859523A  58                            pop eax
0859523B  23 C1                         and eax, ecx

#24			)	{LNXT:2|-1|-1}
(*) BOOL
0859523D  8B C8                         mov ecx, eax
0859523F  58                            pop eax
08595240  23 C1                         and eax, ecx

#25			)	{LNXT:2|-1|-1}
(*) BOOL
08595242  8B C8                         mov ecx, eax
08595244  58                            pop eax
08595245  23 C1                         and eax, ecx

#26			)	{LNXT:2|-1|-1}
(*) BOOL
08595247  8B C8                         mov ecx, eax
08595249  58                            pop eax
0859524A  23 C1                         and eax, ecx

#27			JMPCN	$label0	{LNXT:2|9|30}
(-) BOOL
0859524C  84 C0                         test al, al
0859524E  0F 84 C9 00 00 00             je 0859531DH

#28		
#29			(* THEN *)
#30		
#31		
#32				(* IF CMD.0 *)
#33				LD		CMD.0	{LNXT:9|-1|-1}
(*) UNDEF
08595254  33 C0                         xor eax, eax
08595256  66 8B 05 CC CC CC CC          mov ax, [CCCCCCCCH] ; %M110+34
0859525D  25 01 00 00 00                and eax, 1

#34				JMPCN	$label2	{LNXT:9|10|26}
(-) BOOL
08595262  84 C0                         test al, al
08595264  0F 84 A0 00 00 00             je 0859530AH

#35		
#36				(* THEN *)
#37		
#38					(* checkWashAndStart *)
#39					MOVE		o_val_close_fall,checkWashAndStart.o_val_close_fall_FB	{LNXT:10|-1|-1}
(*) BOOL
0859526A  B8 CC CC CC CC                mov eax, CCCCCCCCH ; %Q1+1
0859526F  89 05 CC CC CC CC             mov [CCCCCCCCH], eax ; $$DATA$$+177

#40					MOVE		o_val_close_R,checkWashAndStart.o_val_close_R_FB	{LNXT:11|-1|-1}
(*) BOOL^
08595275  B8 CC CC CC CC                mov eax, CCCCCCCCH ; %Q1+3
0859527A  89 05 CC CC CC CC             mov [CCCCCCCCH], eax ; $$DATA$$+169

#41					MOVE		o_val_open_fall,checkWashAndStart.o_val_open_fall_FB	{LNXT:12|-1|-1}
(*) BOOL^
08595280  B8 CC CC CC CC                mov eax, CCCCCCCCH ; %Q1+0
08595285  89 05 CC CC CC CC             mov [CCCCCCCCH], eax ; $$DATA$$+173

#42					MOVE		o_val_open_R,checkWashAndStart.o_val_open_R_FB	{LNXT:13|-1|-1}
(*) BOOL^
0859528B  B8 CC CC CC CC                mov eax, CCCCCCCCH ; %Q1+2
08595290  89 05 CC CC CC CC             mov [CCCCCCCCH], eax ; $$DATA$$+165

#43					MOVE		sv_washing,checkWashAndStart.sv_washing_FB	{LNXT:14|-1|-1}
(*) BOOL^
08595296  B8 CC CC CC CC                mov eax, CCCCCCCCH ; %M110+38
0859529B  89 05 CC CC CC CC             mov [CCCCCCCCH], eax ; $$DATA$$+161

#44					MOVE		q_start_ats,checkWashAndStart.q_start_ats_FB	{LNXT:15|-1|-1}
(*) BOOL^
085952A1  B8 CC CC CC CC                mov eax, CCCCCCCCH ; %Q1+7
085952A6  89 05 CC CC CC CC             mov [CCCCCCCCH], eax ; $$DATA$$+181

#45					MOVE		time_sec,checkWashAndStart.ep_time_wash_FB	{LNXT:16|-1|-1}
(*) BOOL^
085952AC  B8 CC CC CC CC                mov eax, CCCCCCCCH ; $$DATA$$+222
085952B1  89 05 CC CC CC CC             mov [CCCCCCCCH], eax ; $$DATA$$+185

#46					MOVE		i_val_state,checkWashAndStart.i_val_state_FB	{LNXT:17|-1|-1}
(*) INT^
085952B7  B8 CC CC CC CC                mov eax, CCCCCCCCH ; $$DATA$$+224
085952BC  89 05 CC CC CC CC             mov [CCCCCCCCH], eax ; $$DATA$$+189

#47					MOVE		di_val_open_state_fall,checkWashAndStart.di_val_open_state_fall_FB	{LNXT:18|-1|-1}
(*) INT^
085952C2  B8 CC CC CC CC                mov eax, CCCCCCCCH ; $$DATA$$+226
085952C7  89 05 CC CC CC CC             mov [CCCCCCCCH], eax ; $$DATA$$+193

#48					MOVE		di_val_close_state_fall,checkWashAndStart.di_val_close_state_fall_FB	{LNXT:19|-1|-1}
(*) INT^
085952CD  B8 CC CC CC CC                mov eax, CCCCCCCCH ; $$DATA$$+228
085952D2  89 05 CC CC CC CC             mov [CCCCCCCCH], eax ; $$DATA$$+197

#49					MOVE		di_val_open_state_R,checkWashAndStart.di_val_open_state_R_FB	{LNXT:20|-1|-1}
(*) INT^
085952D8  B8 CC CC CC CC                mov eax, CCCCCCCCH ; $$DATA$$+230
085952DD  89 05 CC CC CC CC             mov [CCCCCCCCH], eax ; $$DATA$$+201

#50					MOVE		di_val_close_state_R,checkWashAndStart.di_val_close_state_R_FB	{LNXT:21|-1|-1}
(*) INT^
085952E3  B8 CC CC CC CC                mov eax, CCCCCCCCH ; $$DATA$$+58
085952E8  89 05 CC CC CC CC             mov [CCCCCCCCH], eax ; $$DATA$$+205

#51					MOVE		Alarms_Val,checkWashAndStart.Alarm_Val_FB	{LNXT:22|-1|-1}
(*) BOOL^
085952EE  B8 CC CC CC CC                mov eax, CCCCCCCCH ; %M110+40
085952F3  89 05 CC CC CC CC             mov [CCCCCCCCH], eax ; $$DATA$$+209

#52					CAL		checkWashAndStart	{LNXT:10|82|-1}
(*) WORD^
085952F9  50                            push eax
085952FA  BB CC CC CC CC                mov ebx, CCCCCCCCH ; $$DATA$$+66
085952FF  E8 B3 F3 FF FF                call 085946B7H ; $$CODE$$+18103
08595304  58                            pop eax

#53					JMP		$label3	{LNXT:9|10|26}
(-) WORD^
08595305  EB 11 90 90 90                jmp 08595318H

#54		$label2:
#55		
#56				(* ELSE *)
#57		
#58					(* q_start_ats := False; *)
#59					MOVE		False,q_start_ats	{LNXT:26|82|-1}
(*) WORD^
0859530A  B8 00 00 00 00                mov eax, 00H
0859530F  84 C0                         test al, al
08595311  0F 95 05 CC CC CC CC          setne [CCCCCCCCH] ; %Q1+7

#60		
#61		$label3:
#62				(* END_IF *)
#63				JMP		$label1	{LNXT:2|9|30}
(-) BOOL
08595318  EB 35 90 90 90                jmp 0859534FH

#64		$label0:
#65		
#66			(* ELSE *)
#67		
#68				(* CMD.0 := False; *)
#69				MOVE		False,CMD.0	{LNXT:30|31|-1}
(*) BOOL
0859531D  B8 00 00 00 00                mov eax, 00H
08595322  84 C0                         test al, al
08595324  90 75 11 90 90 90             jne 00000014H@
0859532A  66 0F BA 35 CC CC CC CC 00    btr word ptr [CCCCCCCCH], 0 ; %M110+34
08595333  EB 0C 90 90 90                jmp 0000000EH@
08595338  66 0F BA 2D CC CC CC CC 00    bts word ptr [CCCCCCCCH], 0 ; %M110+34

#70		
#71				(* q_start_ats := False; *)
#72				MOVE		False,q_start_ats	{LNXT:31|82|-1}
(*) WORD
08595341  B8 00 00 00 00                mov eax, 00H
08595346  84 C0                         test al, al
08595348  0F 95 05 CC CC CC CC          setne [CCCCCCCCH] ; %Q1+7

#73		
#74		$label1:
#75			(* END_IF *)
#76		
#77		
#78			(* IF q_start_ats *)
#79			LD		q_start_ats	{LNXT:82|-1|-1}
(*) UNDEF
0859534F  33 C0                         xor eax, eax
08595351  8A 05 CC CC CC CC             mov al, [CCCCCCCCH] ; %Q1+7

#80			NOT	{LNXT:82|-1|-1}
(*) BOOL
08595357  84 C0                         test al, al
08595359  0F 94 C0                      sete al

#81			JMPCN	$label4	{LNXT:82|83|85}
(-) BOOL
0859535C  84 C0                         test al, al
0859535E  90 74 16 90 90 90             je 08595377H

#82		
#83			(* THEN *)
#84		
#85				(* downtimeIN:=true; *)
#86				MOVE		true,downtimeIN	{LNXT:83|95|-1}
(*) BOOL
08595364  B8 01 00 00 00                mov eax, 01H
08595369  84 C0                         test al, al
0859536B  0F 95 05 CC CC CC CC          setne [CCCCCCCCH] ; $$DATA$$+221

#87				JMP		$label5	{LNXT:82|83|85}
(-) BOOL
08595372  EB 11 90 90 90                jmp 08595385H

#88		$label4:
#89		
#90			(* ELSE *)
#91		
#92				(* downtimeIN:=false; *)
#93				MOVE		false,downtimeIN	{LNXT:85|95|-1}
(*) BOOL
08595377  B8 00 00 00 00                mov eax, 00H
0859537C  84 C0                         test al, al
0859537E  0F 95 05 CC CC CC CC          setne [CCCCCCCCH] ; $$DATA$$+221

#94		
#95		$label5:
#96			(* END_IF *)
#97		
#98			(* Alarms.2 := i_sns_door; *)
#99			MOVE		i_sns_door,Alarms.2	{LNXT:95|98|-1}
(*) BOOL
08595385  33 C0                         xor eax, eax
08595387  8A 05 CC CC CC CC             mov al, [CCCCCCCCH] ; $$DATA$$+232
0859538D  84 C0                         test al, al
0859538F  90 75 11 90 90 90             jne 00000014H@
08595395  66 0F BA 35 CC CC CC CC 02    btr word ptr [CCCCCCCCH], 2 ; %M110+32
0859539E  EB 0C 90 90 90                jmp 0000000EH@
085953A3  66 0F BA 2D CC CC CC CC 02    bts word ptr [CCCCCCCCH], 2 ; %M110+32

#100		
#101			(* Alarms.3 := i_rnpp; *)
#102			MOVE		i_rnpp,Alarms.3	{LNXT:98|104|-1}
(*) BOOL
085953AC  33 C0                         xor eax, eax
085953AE  8A 05 CC CC CC CC             mov al, [CCCCCCCCH] ; $$DATA$$+233
085953B4  84 C0                         test al, al
085953B6  90 75 11 90 90 90             jne 00000014H@
085953BC  66 0F BA 35 CC CC CC CC 03    btr word ptr [CCCCCCCCH], 3 ; %M110+32
085953C5  EB 0C 90 90 90                jmp 0000000EH@
085953CA  66 0F BA 2D CC CC CC CC 03    bts word ptr [CCCCCCCCH], 3 ; %M110+32

#103		
#104			(* Alarms.5 := i_no_alm_ats; *)
#105			MOVE		i_no_alm_ats,Alarms.5	{LNXT:104|145|-1}
(*) BOOL
085953D3  33 C0                         xor eax, eax
085953D5  8A 05 CC CC CC CC             mov al, [CCCCCCCCH] ; $$DATA$$+234
085953DB  84 C0                         test al, al
085953DD  90 75 11 90 90 90             jne 00000014H@
085953E3  66 0F BA 35 CC CC CC CC 05    btr word ptr [CCCCCCCCH], 5 ; %M110+32
085953EC  EB 0C 90 90 90                jmp 0000000EH@
085953F1  66 0F BA 2D CC CC CC CC 05    bts word ptr [CCCCCCCCH], 5 ; %M110+32

#106		
#107		
#108			(* IF CMD.1 *)
#109			LD		CMD.1	{LNXT:145|-1|-1}
(*) UNDEF
085953FA  33 C0                         xor eax, eax
085953FC  66 8B 05 CC CC CC CC          mov ax, [CCCCCCCCH] ; %M110+34
08595403  C1 E8 01                      shr eax, 1
08595406  25 01 00 00 00                and eax, 1

#110			JMPCN	$label6	{LNXT:145|146|2}
(-) BOOL
0859540B  84 C0                         test al, al
0859540D  90 74 33 90 90 90             je 08595443H

#111		
#112			(* THEN *)
#113		
#114				(* Alarms := 0; *)
#115				MOVE		0,Alarms	{LNXT:146|147|-1}
(*) BOOL
08595413  B8 00 00 00 00                mov eax, 00H
08595418  66 89 05 CC CC CC CC          mov [CCCCCCCCH], ax ; %M110+32

#116		
#117				(* CMD.1 := False; *)
#118				MOVE		False,CMD.1	{LNXT:147|2|-1}
(*) WORD
0859541F  B8 00 00 00 00                mov eax, 00H
08595424  84 C0                         test al, al
08595426  90 75 11 90 90 90             jne 00000014H@
0859542C  66 0F BA 35 CC CC CC CC 01    btr word ptr [CCCCCCCCH], 1 ; %M110+34
08595435  EB 0C 90 90 90                jmp 0000000EH@
0859543A  66 0F BA 2D CC CC CC CC 01    bts word ptr [CCCCCCCCH], 1 ; %M110+34

08595443  61                            popad
08595444  5D                            pop ebp

08595445  C3                            ret

END_PROGRAM


**************************************************
	Target variable image generation
**************************************************


*** INPUT:
08595446  55                            push ebp
08595447  8B EC                         mov ebp, esp

08595449  66 8B 0D CC CC CC CC          mov cx, [CCCCCCCCH] ; %I1+14
08595450  66 89 0D CC CC CC CC          mov [CCCCCCCCH], cx ; $$DATA$$+64

08595457  66 8B 0D CC CC CC CC          mov cx, [CCCCCCCCH] ; %I1+4
0859545E  66 89 0D CC CC CC CC          mov [CCCCCCCCH], cx ; $$DATA$$+224

08595465  66 8B 0D CC CC CC CC          mov cx, [CCCCCCCCH] ; %I1+6
0859546C  66 89 0D CC CC CC CC          mov [CCCCCCCCH], cx ; $$DATA$$+226

08595473  66 8B 0D CC CC CC CC          mov cx, [CCCCCCCCH] ; %I1+8
0859547A  66 89 0D CC CC CC CC          mov [CCCCCCCCH], cx ; $$DATA$$+228

08595481  66 8B 0D CC CC CC CC          mov cx, [CCCCCCCCH] ; %I1+10
08595488  66 89 0D CC CC CC CC          mov [CCCCCCCCH], cx ; $$DATA$$+230

0859548F  8A 0D CC CC CC CC             mov cl, [CCCCCCCCH] ; %I0+0
08595495  88 0D CC CC CC CC             mov [CCCCCCCCH], cl ; $$DATA$$+58

0859549B  8A 0D CC CC CC CC             mov cl, [CCCCCCCCH] ; %I0+3
085954A1  88 0D CC CC CC CC             mov [CCCCCCCCH], cl ; $$DATA$$+232

085954A7  8A 0D CC CC CC CC             mov cl, [CCCCCCCCH] ; %I0+4
085954AD  88 0D CC CC CC CC             mov [CCCCCCCCH], cl ; $$DATA$$+233

085954B3  8A 0D CC CC CC CC             mov cl, [CCCCCCCCH] ; %I0+6
085954B9  88 0D CC CC CC CC             mov [CCCCCCCCH], cl ; $$DATA$$+234

085954BF  66 8B 0D CC CC CC CC          mov cx, [CCCCCCCCH] ; %I1+0
085954C6  66 89 0D CC CC CC CC          mov [CCCCCCCCH], cx ; $$DATA$$+240

085954CD  8B E5                         mov esp, ebp
085954CF  5D                            pop ebp

085954D0  C3                            ret


*** OUTPUT:
085954D1  55                            push ebp
085954D2  8B EC                         mov ebp, esp

085954D4  8B E5                         mov esp, ebp
085954D6  5D                            pop ebp

085954D7  C3                            ret



**************************************************
	Task Timed init code
**************************************************

085954D8  55                            push ebp
085954D9  8B EC                         mov ebp, esp

Var init: V::SR_ATS_CTRL.TIME_SEC = 4000
085954DB  66 C7 05 CC CC CC CC A0 0F    mov word ptr [CCCCCCCCH], 0FA0H ; $$DATA$$+222

085954E4  8B E5                         mov esp, ebp
085954E6  5D                            pop ebp

085954E7  C3                            ret



**************************************************
	Global init code
**************************************************

08595500  55                            push ebp
08595501  8B EC                         mov ebp, esp

Var init: V:EMBEDDEDELEMENTS:$$POUCBARRAY$$BACKGROUND = [?ATS_mdb.$$POUCB$$, 0]
08595503  B9 CC CC CC CC                mov ecx, CCCCCCCCH ; $$DATA$$+328
08595508  89 0D CC CC CC CC             mov [CCCCCCCCH], ecx ; $$DATA$$+276

Var init: V:EMBEDDEDELEMENTS:$$POUCBARRAY$$BOOT = [?sr_init_counters.$$POUCB$$, 0]
0859550E  B9 CC CC CC CC                mov ecx, CCCCCCCCH ; $$DATA$$+334
08595513  89 0D CC CC CC CC             mov [CCCCCCCCH], ecx ; $$DATA$$+284

Var init: V:EMBEDDEDELEMENTS:$$POUCBARRAY$$INIT = [?init_val.$$POUCB$$, 0]
08595519  B9 CC CC CC CC                mov ecx, CCCCCCCCH ; $$DATA$$+340
0859551E  89 0D CC CC CC CC             mov [CCCCCCCCH], ecx ; $$DATA$$+292

Var init: V:EMBEDDEDELEMENTS:$$POUCBARRAY$$SERV = [?InitParDB.$$POUCB$$, 0]
08595524  B9 CC CC CC CC                mov ecx, CCCCCCCCH ; $$DATA$$+346
08595529  89 0D CC CC CC CC             mov [CCCCCCCCH], ecx ; $$DATA$$+300

Var init: V:EMBEDDEDELEMENTS:$$POUCBARRAY$$TIMED = [?sr_pressure.$$POUCB$$, ?sr_counters.$$POUCB$$, ?sr_save_counters.$$POUCB$$, ?sr_ATS_Ctrl.$$POUCB$$, 0]
0859552F  B9 CC CC CC CC                mov ecx, CCCCCCCCH ; $$DATA$$+352
08595534  89 0D CC CC CC CC             mov [CCCCCCCCH], ecx ; $$DATA$$+308
0859553A  B9 CC CC CC CC                mov ecx, CCCCCCCCH ; $$DATA$$+358
0859553F  89 0D CC CC CC CC             mov [CCCCCCCCH], ecx ; $$DATA$$+312
08595545  B9 CC CC CC CC                mov ecx, CCCCCCCCH ; $$DATA$$+364
0859554A  89 0D CC CC CC CC             mov [CCCCCCCCH], ecx ; $$DATA$$+316
08595550  B9 CC CC CC CC                mov ecx, CCCCCCCCH ; $$DATA$$+370
08595555  89 0D CC CC CC CC             mov [CCCCCCCCH], ecx ; $$DATA$$+320

0859555B  8B E5                         mov esp, ebp
0859555D  5D                            pop ebp

0859555E  C3                            ret



**************************************************
	Global RETAIN init code
**************************************************

0859555F  55                            push ebp
08595560  8B EC                         mov ebp, esp

08595562  8B E5                         mov esp, ebp
08595564  5D                            pop ebp

08595565  C3                            ret



**************************************************
	Task $$VirtualTables init code
**************************************************

08595566  55                            push ebp
08595567  8B EC                         mov ebp, esp

08595569  8B E5                         mov esp, ebp
0859556B  5D                            pop ebp

0859556C  C3                            ret



********************************************
MEMORY MAP
********************************************

Code area type:          		       main code
Start code area:          		0000000008590000h
End code area:            		0000000008595F1Ch
Code size:                		00005F1Ch

Start local data area:    		0000000008510000h
End local data area:      		0000000008510178h
Local data size:          		00000178h

Start retentive data area:		0000000000000000h
End retentive data area:  		0000000000000000h
Retentive data size:      		00000000h

Start bit data area:      		0000000000000000h
End bit data area:        		0000000000000000h
Bit data size:            		00000000h



********************************************
CODE ID:                                1802ABC8
DEBUG MEMO ID:                          000034F7
FULL MEMO ID:                           000074B2
RELOCATION ADDR:                        0000000008590000
********************************************
