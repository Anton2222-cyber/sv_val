***********************************************************************
*
*	CODE GENERATION LISTING FOR: sw37
*	COMPILER VERSION: 6.0.0.52
*
***********************************************************************

**************************************************
	List function block: R_TRIG
**************************************************

FUNCTION_BLOCK R_TRIG

	{ DE:"<HTML>The output Q will remain FALSE as long as the input variable CLK is FALSE.<br>
As soon as CLK returns TRUE, Q will first return TRUE.<br><br>
This means each time the function is called up, Q will return FALSE until CLK has falling edge followed by an rising edge.<br><br>
<img src= r_trig.png>" }

        VAR_INPUT
clk : BOOL;	{ DE:"Input for edge detection" }
	END_VAR

        VAR_OUTPUT
q : BOOL;	{ DE:"Raising edge output" }
	END_VAR

        VAR
m : BOOL := FALSE;
	END_VAR

END_FUNCTION_BLOCK

08A64490  55                            push ebp
08A64491  8B EB                         mov ebp, ebx
08A64493  57                            push edi

#0		{SRC:R_TRIG}
#1		
#2			LD		clk
(*) UNDEF
08A64494  33 C0                         xor eax, eax
08A64496  8A 45 01                      mov al, 1[ebp]

#3			ANDN	m
(*) BOOL
08A64499  33 C9                         xor ecx, ecx
08A6449B  8A 4D 00                      mov cl, [ebp]
08A6449E  84 C9                         test cl, cl
08A644A0  0F 94 C1                      sete cl
08A644A3  23 C1                         and eax, ecx

#4			ST		q
(*) BOOL
08A644A5  84 C0                         test al, al
08A644A7  0F 95 45 02                   setne 2[ebp]

#5		
#6			LD		clk
(*) UNDEF
08A644AB  33 C0                         xor eax, eax
08A644AD  8A 45 01                      mov al, 1[ebp]

#7			ST		m
(*) BOOL
08A644B0  84 C0                         test al, al
08A644B2  0F 95 45 00                   setne [ebp]

08A644B6  5F                            pop edi
08A644B7  5D                            pop ebp

08A644B8  C3                            ret


Frame allocation (hex):

	0000 bit  0: VAR m
	0001 bit  0: VAR clk
	0002 bit  0: VAR q

END_FUNCTION_BLOCK
**************************************************
	List function block: TON
**************************************************

FUNCTION_BLOCK TON

	{ DE:"<HTML>The TON block produces a delayed output Q of the input IN. The delay time is expressed in milliseconds on the PT input.</br></br>
<img src= tonscheme.png>
<ul>
<li>if IN is FALSE Q is false</li>
<li>Q becomes TRUE as IN remains TRUE for PT milliseconds</li>
<li>Q remains TRUE until IN remains TRUE</li>
</ul>" }

        VAR_INPUT
IN : BOOL;	{ DE:"Timer input source" }
PT : UDINT;	{ DE:"Preset time value (ms)" }
	END_VAR

        VAR_OUTPUT
Q : BOOL;	{ DE:"Timer output" }
ET : UDINT;	{ DE:"Timer current value (ms)" }
	END_VAR

        VAR_EXTERNAL
	{G:"System_Timers"}
sysTimer AT %MD0.0 : UDINT;	{ DE:"System timer [ms]" }
	END_VAR

        VAR
timStart : UDINT;	{ DE:"Time value at start of counting" }
	END_VAR

END_FUNCTION_BLOCK

08A644B9  55                            push ebp
08A644BA  8B EB                         mov ebp, ebx
08A644BC  57                            push edi

#0		{SRC:TON}
#1		
#2			(*	Check if in counting	*)
#3		
#4			LD		IN
(*) UNDEF
08A644BD  33 C0                         xor eax, eax
08A644BF  8A 45 04                      mov al, 4[ebp]

#5			JMPCN	lReset
(-) BOOL
08A644C2  84 C0                         test al, al
08A644C4  90 74 61 90 90 90             je 08A64528H

#6		
#7			(*	Check if Q is TRUE *)
#8			LD		Q
(*) UNDEF
08A644CA  33 C0                         xor eax, eax
08A644CC  8A 45 09                      mov al, 9[ebp]

#9			RETC
#10			
(-) BOOL
08A644CF  84 C0                         test al, al
08A644D1  90 75 6A 90 90 90             jne 08A6453EH

#11			(*	Check if already in counting *)
#12			LD		timStart
(*) UNDEF
08A644D7  8B 45 00                      mov eax, [ebp]

#13			EQ		0
(*) UDINT
08A644DA  3D 00 00 00 00                cmp eax, 0
08A644DF  0F 94 C0                      sete al
08A644E2  25 FF 00 00 00                and eax, 0FFh

#14			JMPCN	lUpdate
(-) BOOL
08A644E7  84 C0                         test al, al
08A644E9  90 74 0C 90 90 90             je 08A644F8H

#15		
#16			(*	Start of counting *)
#17			LD		sysTimer
(*) UNDEF
08A644EF  8B 05 CC CC CC CC             mov eax, [CCCCCCCCH] ; %M0+0

#18			ST		timStart
(*) UDINT
08A644F5  89 45 00                      mov [ebp], eax

#19			
#20		lUpdate:
#21		
#22			(*	Update timer and check if time elapsed *)
#23			LD		sysTimer
(*) UNDEF
08A644F8  8B 05 CC CC CC CC             mov eax, [CCCCCCCCH] ; %M0+0

#24			SUB		timStart
(*) UDINT
08A644FE  2B 45 00                      sub eax, [ebp]

#25			ST		ET
(*) UDINT
08A64501  89 45 0A                      mov 10[ebp], eax

#26			GE		PT
(*) UDINT
08A64504  3B 45 05                      cmp eax, [ebp+5]
08A64507  0F 93 C0                      setae al
08A6450A  25 FF 00 00 00                and eax, 0FFh

#27			ST		Q
(*) BOOL
08A6450F  84 C0                         test al, al
08A64511  0F 95 45 09                   setne 9[ebp]

#28			RETCN
#29		
(-) BOOL
08A64515  84 C0                         test al, al
08A64517  90 74 24 90 90 90             je 08A6453EH

#30			(*	Limit actual time value *)
#31			LD		PT
(*) UNDEF
08A6451D  8B 45 05                      mov eax, 5[ebp]

#32			ST		ET
(*) UDINT
08A64520  89 45 0A                      mov 10[ebp], eax

#33			RET
#34		
(-) UDINT
08A64523  EB 19 90 90 90                jmp 08A6453EH

#35		lReset:
#36		
#37			(*	Reset status *)
#38			LD		0
(*) UNDEF
08A64528  B8 00 00 00 00                mov eax, 00H

#39			ST		ET
(*) USINT
08A6452D  89 45 0A                      mov 10[ebp], eax

#40			ST		timStart
(*) UDINT
08A64530  89 45 00                      mov [ebp], eax

#41			LD		FALSE
(*) UNDEF
08A64533  B8 00 00 00 00                mov eax, 00H

#42			ST		Q
(*) BOOL
08A64538  84 C0                         test al, al
08A6453A  0F 95 45 09                   setne 9[ebp]

08A6453E  5F                            pop edi
08A6453F  5D                            pop ebp

08A64540  C3                            ret


Frame allocation (hex):

	0000       : VAR timStart
	0004 bit  0: VAR IN
	0005       : VAR PT
	0009 bit  0: VAR Q
	000A       : VAR ET

END_FUNCTION_BLOCK
**************************************************
	List function block: CheckAlarmVal
**************************************************

FUNCTION_BLOCK CheckAlarmVal

        VAR_IN_OUT
di_val_open_state_fall_FB : INT^;
di_val_close_state_fall_FB : INT^;
di_val_open_state_R_FB : INT^;
di_val_close_state_R_FB : BOOL^;
Alarm_Val_FB : WORD^;
o_val_open_R_FB : BOOL^;
o_val_close_R_FB : BOOL^;
o_val_open_fall_FB : BOOL^;
o_val_close_fall_FB : BOOL^;
start_check : BOOL^;
	END_VAR

        VAR_OUTPUT
is_check_done : BOOL;
isOK : BOOL;
	END_VAR

        VAR
check_timer : TON;	{ DE:"локальний FB таймера" }
should_run_timer : BOOL;
	END_VAR

END_FUNCTION_BLOCK

08A64541  55                            push ebp
08A64542  8B EB                         mov ebp, ebx
08A64544  57                            push edi

#0		{SRC:CheckAlarmVal}
#1		(*$WAITSWITCH$*)
#2		
#3		
#4			(* IF check_timer.IN *)
#5			LD		check_timer.IN	{LNXT:3|-1|-1}
(*) UNDEF
08A64545  33 C0                         xor eax, eax
08A64547  8A 45 04                      mov al, 4[ebp]

#6			JMPCN	$label0	{LNXT:3|4|8}
(-) BOOL
08A6454A  84 C0                         test al, al
08A6454C  90 74 19 90 90 90             je 08A64568H

#7		
#8			(* THEN *)
#9		
#10				(* isOK := TRUE; *)
#11				MOVE		TRUE,isOK	{LNXT:4|5|-1}
(*) BOOL
08A64552  B8 01 00 00 00                mov eax, 01H
08A64557  84 C0                         test al, al
08A64559  0F 95 45 18                   setne 24[ebp]

#12		
#13				(* is_check_done := false; *)
#14				MOVE		false,is_check_done	{LNXT:5|8|-1}
(*) BOOL
08A6455D  B8 00 00 00 00                mov eax, 00H
08A64562  84 C0                         test al, al
08A64564  0F 95 45 17                   setne 23[ebp]

#15		
#16		$label0:
#17			(* END_IF *)
#18		
#19		
#20			(* IF start_check *)
#21			LD		start_check	{LNXT:8|-1|-1}
(*) UNDEF
08A64568  8B 55 3D                      mov edx, 61[ebp]
08A6456B  33 C0                         xor eax, eax
08A6456D  8A 02                         mov al, [edx]

#22			JMPCN	$label1	{LNXT:8|9|13}
(-) BOOL
08A6456F  84 C0                         test al, al
08A64571  90 74 1F 90 90 90             je 08A64593H

#23		
#24			(* THEN *)
#25		
#26				(* check_timer *)
#27				MOVE		true,check_timer.IN	{LNXT:9|-1|-1}
(*) BOOL
08A64577  B8 01 00 00 00                mov eax, 01H
08A6457C  84 C0                         test al, al
08A6457E  0F 95 45 04                   setne 4[ebp]

#28				MOVE		10000,check_timer.PT	{LNXT:9|-1|-1}
(*) BOOL
08A64582  B8 10 27 00 00                mov eax, 2710H
08A64587  89 45 05                      mov 5[ebp], eax

#29				CAL		check_timer	{LNXT:9|13|-1}
(*) UDINT
08A6458A  50                            push eax
08A6458B  8B DD                         mov ebx, ebp
08A6458D  E8 27 FF FF FF                call 08A644B9H ; $$CODE$$+17593
08A64592  58                            pop eax

#30		
#31		$label1:
#32			(* END_IF *)
#33		
#34		
#35			(* IF check_timer.Q *)
#36			LD		check_timer.Q	{LNXT:13|-1|-1}
(*) UNDEF
08A64593  33 C0                         xor eax, eax
08A64595  8A 45 09                      mov al, 9[ebp]

#37			JMPCN	$label2	{LNXT:13|15|44}
(-) BOOL
08A64598  84 C0                         test al, al
08A6459A  0F 84 2C 01 00 00             je 08A646CCH

#38		
#39			(* THEN *)
#40		
#41				(* check_timer *)
#42				MOVE		false,check_timer.IN	{LNXT:15|-1|-1}
(*) BOOL
08A645A0  B8 00 00 00 00                mov eax, 00H
08A645A5  84 C0                         test al, al
08A645A7  0F 95 45 04                   setne 4[ebp]

#43				CAL		check_timer	{LNXT:15|17|-1}
(*) BOOL
08A645AB  50                            push eax
08A645AC  8B DD                         mov ebx, ebp
08A645AE  E8 06 FF FF FF                call 08A644B9H ; $$CODE$$+17593
08A645B3  58                            pop eax

#44		
#45		
#46				(* IF o_val_open_R_FB^ AND NOT di_val_open_state_R_FB^ *)
#47				LD		di_val_open_state_R_FB^	{LNXT:17|-1|-1}
(*) UNDEF
08A645B4  8B 55 21                      mov edx, 33[ebp]
08A645B7  0F BF 02                      movsx eax, word ptr [edx]

#48				NOT	{LNXT:17|-1|-1}
(*) INT
08A645BA  66 F7 D0                      not ax

#49				AND		o_val_open_R_FB^	{LNXT:17|-1|-1}
(*) INT
08A645BD  8B 55 2D                      mov edx, 45[ebp]
08A645C0  33 C9                         xor ecx, ecx
08A645C2  8A 0A                         mov cl, [edx]
08A645C4  23 C1                         and eax, ecx

#50				JMPCN	$label3	{LNXT:17|18|21}
(-) INT
08A645C6  66 85 C0                      test ax, ax
08A645C9  90 74 20 90 90 90             je 08A645ECH

#51		
#52				(* THEN *)
#53		
#54					(* Alarm_Val_FB^.0 := TRUE; *)
#55					MOVE		TRUE,Alarm_Val_FB^.0	{LNXT:18|21|-1}
(*) INT
08A645CF  B8 01 00 00 00                mov eax, 01H
08A645D4  8B 55 29                      mov edx, 41[ebp]
08A645D7  84 C0                         test al, al
08A645D9  90 75 0C 90 90 90             jne 0000000FH@
08A645DF  0F BA 32 00                   btr [edx], 0
08A645E3  EB 07 90 90 90                jmp 00000009H@
08A645E8  0F BA 2A 00                   bts [edx], 0

#56		
#57		$label3:
#58				(* END_IF *)
#59		
#60		
#61				(* IF o_val_close_R_FB^ AND NOT di_val_close_state_R_FB^ *)
#62				LD		di_val_close_state_R_FB^	{LNXT:21|-1|-1}
(*) UNDEF
08A645EC  8B 55 25                      mov edx, 37[ebp]
08A645EF  33 C0                         xor eax, eax
08A645F1  8A 02                         mov al, [edx]

#63				NOT	{LNXT:21|-1|-1}
(*) BOOL
08A645F3  84 C0                         test al, al
08A645F5  0F 94 C0                      sete al

#64				AND		o_val_close_R_FB^	{LNXT:21|-1|-1}
(*) BOOL
08A645F8  8B 55 31                      mov edx, 49[ebp]
08A645FB  8B 55 31                      mov edx, 49[ebp]
08A645FE  33 C9                         xor ecx, ecx
08A64600  8A 0A                         mov cl, [edx]
08A64602  23 C1                         and eax, ecx

#65				JMPCN	$label4	{LNXT:21|22|25}
(-) BOOL
08A64604  84 C0                         test al, al
08A64606  90 74 20 90 90 90             je 08A64629H

#66		
#67				(* THEN *)
#68		
#69					(* Alarm_Val_FB^.1 := TRUE; *)
#70					MOVE		TRUE,Alarm_Val_FB^.1	{LNXT:22|25|-1}
(*) BOOL
08A6460C  B8 01 00 00 00                mov eax, 01H
08A64611  8B 55 29                      mov edx, 41[ebp]
08A64614  84 C0                         test al, al
08A64616  90 75 0C 90 90 90             jne 0000000FH@
08A6461C  0F BA 32 01                   btr [edx], 1
08A64620  EB 07 90 90 90                jmp 00000009H@
08A64625  0F BA 2A 01                   bts [edx], 1

#71		
#72		$label4:
#73				(* END_IF *)
#74		
#75		
#76				(* IF o_val_open_fall_FB^ AND NOT di_val_open_state_fall_FB^ *)
#77				LD		di_val_open_state_fall_FB^	{LNXT:25|-1|-1}
(*) UNDEF
08A64629  8B 55 19                      mov edx, 25[ebp]
08A6462C  0F BF 02                      movsx eax, word ptr [edx]

#78				NOT	{LNXT:25|-1|-1}
(*) INT
08A6462F  66 F7 D0                      not ax

#79				AND		o_val_open_fall_FB^	{LNXT:25|-1|-1}
(*) INT
08A64632  8B 55 35                      mov edx, 53[ebp]
08A64635  33 C9                         xor ecx, ecx
08A64637  8A 0A                         mov cl, [edx]
08A64639  23 C1                         and eax, ecx

#80				JMPCN	$label5	{LNXT:25|26|29}
(-) INT
08A6463B  66 85 C0                      test ax, ax
08A6463E  90 74 20 90 90 90             je 08A64661H

#81		
#82				(* THEN *)
#83		
#84					(* Alarm_Val_FB^.2 := TRUE; *)
#85					MOVE		TRUE,Alarm_Val_FB^.2	{LNXT:26|29|-1}
(*) INT
08A64644  B8 01 00 00 00                mov eax, 01H
08A64649  8B 55 29                      mov edx, 41[ebp]
08A6464C  84 C0                         test al, al
08A6464E  90 75 0C 90 90 90             jne 0000000FH@
08A64654  0F BA 32 02                   btr [edx], 2
08A64658  EB 07 90 90 90                jmp 00000009H@
08A6465D  0F BA 2A 02                   bts [edx], 2

#86		
#87		$label5:
#88				(* END_IF *)
#89		
#90		
#91				(* IF o_val_close_fall_FB^ AND NOT di_val_close_state_fall_FB^ *)
#92				LD		di_val_close_state_fall_FB^	{LNXT:29|-1|-1}
(*) UNDEF
08A64661  8B 55 1D                      mov edx, 29[ebp]
08A64664  0F BF 02                      movsx eax, word ptr [edx]

#93				NOT	{LNXT:29|-1|-1}
(*) INT
08A64667  66 F7 D0                      not ax

#94				AND		o_val_close_fall_FB^	{LNXT:29|-1|-1}
(*) INT
08A6466A  8B 55 39                      mov edx, 57[ebp]
08A6466D  33 C9                         xor ecx, ecx
08A6466F  8A 0A                         mov cl, [edx]
08A64671  23 C1                         and eax, ecx

#95				JMPCN	$label6	{LNXT:29|30|34}
(-) INT
08A64673  66 85 C0                      test ax, ax
08A64676  90 74 20 90 90 90             je 08A64699H

#96		
#97				(* THEN *)
#98		
#99					(* Alarm_Val_FB^.3 := TRUE; *)
#100					MOVE		TRUE,Alarm_Val_FB^.3	{LNXT:30|34|-1}
(*) INT
08A6467C  B8 01 00 00 00                mov eax, 01H
08A64681  8B 55 29                      mov edx, 41[ebp]
08A64684  84 C0                         test al, al
08A64686  90 75 0C 90 90 90             jne 0000000FH@
08A6468C  0F BA 32 03                   btr [edx], 3
08A64690  EB 07 90 90 90                jmp 00000009H@
08A64695  0F BA 2A 03                   bts [edx], 3

#101		
#102		$label6:
#103				(* END_IF *)
#104		
#105		
#106				(* IF Alarm_Val_FB^ > 0 *)
#107				LD		Alarm_Val_FB^	{LNXT:34|-1|-1}
(*) UNDEF
08A64699  8B 55 29                      mov edx, 41[ebp]
08A6469C  33 C0                         xor eax, eax
08A6469E  66 8B 02                      mov ax, [edx]

#108				GT		0	{LNXT:34|-1|-1}
(*) WORD
08A646A1  3D 00 00 00 00                cmp eax, 0
08A646A6  0F 9F C0                      setg al
08A646A9  25 FF 00 00 00                and eax, 0FFh

#109				JMPCN	$label7	{LNXT:34|35|38}
(-) BOOL
08A646AE  84 C0                         test al, al
08A646B0  90 74 0E 90 90 90             je 08A646C1H

#110		
#111				(* THEN *)
#112		
#113					(* isOK := FALSE; *)
#114					MOVE		FALSE,isOK	{LNXT:35|38|-1}
(*) BOOL
08A646B6  B8 00 00 00 00                mov eax, 00H
08A646BB  84 C0                         test al, al
08A646BD  0F 95 45 18                   setne 24[ebp]

#115		
#116		$label7:
#117				(* END_IF *)
#118		
#119				(* is_check_done := TRUE; *)
#120				MOVE		TRUE,is_check_done	{LNXT:38|44|-1}
(*) BOOL
08A646C1  B8 01 00 00 00                mov eax, 01H
08A646C6  84 C0                         test al, al
08A646C8  0F 95 45 17                   setne 23[ebp]

#121		
#122		$label2:
#123			(* END_IF *)
#124		
#125			(* check_timer *)
#126			CAL		check_timer	{LNXT:44|-1|-1}
(*) BOOL
08A646CC  50                            push eax
08A646CD  8B DD                         mov ebx, ebp
08A646CF  E8 E5 FD FF FF                call 08A644B9H ; $$CODE$$+17593
08A646D4  58                            pop eax

08A646D5  5F                            pop edi
08A646D6  5D                            pop ebp

08A646D7  C3                            ret


Frame allocation (hex):

	0000       : FB check_timer
	0016 bit  0: VAR should_run_timer
	0017 bit  0: VAR is_check_done
	0018 bit  0: VAR isOK
	0019       : VAR di_val_open_state_fall_FB
	001D       : VAR di_val_close_state_fall_FB
	0021       : VAR di_val_open_state_R_FB
	0025       : VAR di_val_close_state_R_FB
	0029       : VAR Alarm_Val_FB
	002D       : VAR o_val_open_R_FB
	0031       : VAR o_val_close_R_FB
	0035       : VAR o_val_open_fall_FB
	0039       : VAR o_val_close_fall_FB
	003D       : VAR start_check

END_FUNCTION_BLOCK
**************************************************
	List function block: CheckWashAndStart
**************************************************

FUNCTION_BLOCK CheckWashAndStart

        VAR_IN_OUT
sv_washing_FB : BOOL^;
o_val_open_R_FB : BOOL^;
o_val_close_R_FB : BOOL^;
o_val_open_fall_FB : BOOL^;
o_val_close_fall_FB : BOOL^;
q_start_ats_FB : BOOL^;
ep_time_wash_FB : INT^;
i_val_state_FB : INT^;
di_val_open_state_fall_FB : INT^;
di_val_close_state_fall_FB : INT^;
di_val_open_state_R_FB : INT^;
di_val_close_state_R_FB : BOOL^;
Alarm_Val_FB : WORD^;
	END_VAR

        VAR_OUTPUT
is_running_wash : BOOL;
	END_VAR

        VAR
washing_timer : TON;	{ DE:"локальний FB таймера" }
onWash : BOOL;
checkAlarmVal : CheckAlarmVal;
valve_rising : BOOL;
prev_val_open_fall : BOOL;
prev_val_close_fall : BOOL;
prev_val_open_R : BOOL;
prev_val_close_R : BOOL;
	END_VAR

END_FUNCTION_BLOCK

08A646D8  55                            push ebp
08A646D9  8B EB                         mov ebp, ebx
08A646DB  57                            push edi

#0		{SRC:CheckWashAndStart}
#1		(*$WAITSWITCH$*)
#2		
#3		
#4			(* IF sv_washing_FB^ and i_val_state_FB^=1 *)
#5			LD		i_val_state_FB^	{LNXT:1|-1|-1}
(*) UNDEF
08A646DC  8B 95 82 00 00 00             mov edx, 130[ebp]
08A646E2  0F BF 02                      movsx eax, word ptr [edx]

#6			EQ		1	{LNXT:1|-1|-1}
(*) INT
08A646E5  3D 01 00 00 00                cmp eax, 1
08A646EA  0F 94 C0                      sete al
08A646ED  25 FF 00 00 00                and eax, 0FFh

#7			AND		sv_washing_FB^	{LNXT:1|-1|-1}
(*) BOOL
08A646F2  8B 55 66                      mov edx, 102[ebp]
08A646F5  8B 55 66                      mov edx, 102[ebp]
08A646F8  33 C9                         xor ecx, ecx
08A646FA  8A 0A                         mov cl, [edx]
08A646FC  23 C1                         and eax, ecx

#8			JMPCN	$label0	{LNXT:1|2|4}
(-) BOOL
08A646FE  84 C0                         test al, al
08A64700  90 74 13 90 90 90             je 08A64716H

#9		
#10			(* THEN *)
#11		
#12				(* onWash :=true; *)
#13				MOVE		true,onWash	{LNXT:2|7|-1}
(*) BOOL
08A64706  B8 01 00 00 00                mov eax, 01H
08A6470B  84 C0                         test al, al
08A6470D  0F 95 45 16                   setne 22[ebp]

#14				JMP		$label1	{LNXT:1|2|4}
(-) BOOL
08A64711  EB 0E 90 90 90                jmp 08A64721H

#15		$label0:
#16		
#17			(* ELSE *)
#18		
#19				(* onWash :=false; *)
#20				MOVE		false,onWash	{LNXT:4|7|-1}
(*) BOOL
08A64716  B8 00 00 00 00                mov eax, 00H
08A6471B  84 C0                         test al, al
08A6471D  0F 95 45 16                   setne 22[ebp]

#21		
#22		$label1:
#23			(* END_IF *)
#24		
#25		
#26			(* IF onWash *)
#27			LD		onWash	{LNXT:7|-1|-1}
(*) UNDEF
08A64721  33 C0                         xor eax, eax
08A64723  8A 45 16                      mov al, 22[ebp]

#28			JMPCN	$label2	{LNXT:7|10|52}
(-) BOOL
08A64726  84 C0                         test al, al
08A64728  0F 84 87 01 00 00             je 08A648B5H

#29		
#30			(* THEN *)
#31		
#32				(* is_running_wash :=true; *)
#33				MOVE		true,is_running_wash	{LNXT:10|12|-1}
(*) BOOL
08A6472E  B8 01 00 00 00                mov eax, 01H
08A64733  84 C0                         test al, al
08A64735  0F 95 45 65                   setne 101[ebp]

#34		
#35				(* prev_val_open_fall:=o_val_open_fall_FB^; *)
#36				MOVE		o_val_open_fall_FB^,prev_val_open_fall	{LNXT:12|13|-1}
(*) BOOL
08A64739  8B 55 72                      mov edx, 114[ebp]
08A6473C  33 C0                         xor eax, eax
08A6473E  8A 02                         mov al, [edx]
08A64740  84 C0                         test al, al
08A64742  0F 95 45 61                   setne 97[ebp]

#37		
#38				(* prev_val_close_fall:=o_val_close_fall_FB^; *)
#39				MOVE		o_val_close_fall_FB^,prev_val_close_fall	{LNXT:13|14|-1}
(*) BOOL
08A64746  8B 55 76                      mov edx, 118[ebp]
08A64749  33 C0                         xor eax, eax
08A6474B  8A 02                         mov al, [edx]
08A6474D  84 C0                         test al, al
08A6474F  0F 95 45 62                   setne 98[ebp]

#40		
#41				(* prev_val_open_R:=o_val_open_R_FB^; *)
#42				MOVE		o_val_open_R_FB^,prev_val_open_R	{LNXT:14|15|-1}
(*) BOOL
08A64753  8B 55 6A                      mov edx, 106[ebp]
08A64756  33 C0                         xor eax, eax
08A64758  8A 02                         mov al, [edx]
08A6475A  84 C0                         test al, al
08A6475C  0F 95 45 63                   setne 99[ebp]

#43		
#44				(* prev_val_close_R:=o_val_close_R_FB^; *)
#45				MOVE		o_val_close_R_FB^,prev_val_close_R	{LNXT:15|17|-1}
(*) BOOL
08A64760  8B 55 6E                      mov edx, 110[ebp]
08A64763  33 C0                         xor eax, eax
08A64765  8A 02                         mov al, [edx]
08A64767  84 C0                         test al, al
08A64769  0F 95 45 64                   setne 100[ebp]

#46		
#47				(* o_val_close_R_FB^:=true; *)
#48				MOVE		true,o_val_close_R_FB^	{LNXT:17|18|-1}
(*) BOOL
08A6476D  B8 01 00 00 00                mov eax, 01H
08A64772  8B 55 6E                      mov edx, 110[ebp]
08A64775  84 C0                         test al, al
08A64777  0F 95 02                      setne [edx]

#49		
#50				(* o_val_open_R_FB^:=false; *)
#51				MOVE		false,o_val_open_R_FB^	{LNXT:18|19|-1}
(*) BOOL
08A6477A  B8 00 00 00 00                mov eax, 00H
08A6477F  8B 55 6A                      mov edx, 106[ebp]
08A64782  84 C0                         test al, al
08A64784  0F 95 02                      setne [edx]

#52		
#53				(* o_val_open_fall_FB^:=true; *)
#54				MOVE		true,o_val_open_fall_FB^	{LNXT:19|20|-1}
(*) BOOL
08A64787  B8 01 00 00 00                mov eax, 01H
08A6478C  8B 55 72                      mov edx, 114[ebp]
08A6478F  84 C0                         test al, al
08A64791  0F 95 02                      setne [edx]

#55		
#56				(* o_val_close_fall_FB^:=false; *)
#57				MOVE		false,o_val_close_fall_FB^	{LNXT:20|22|-1}
(*) BOOL
08A64794  B8 00 00 00 00                mov eax, 00H
08A64799  8B 55 76                      mov edx, 118[ebp]
08A6479C  84 C0                         test al, al
08A6479E  0F 95 02                      setne [edx]

#58		
#59				(* valve_rising :=
#60		    (o_val_open_fall_FB^ AND NOT prev_val_open_fall) OR
#61			(o_val_close_fall_FB^ AND NOT prev_val_close_fall) OR
#62			(o_val_open_R_FB^ AND NOT prev_val_open_R) OR
#63			(o_val_close_R_FB^ AND NOT prev_val_close_R); *)
#64				LD		prev_val_close_R	{LNXT:22|30|-1}
(*) UNDEF
08A647A1  33 C0                         xor eax, eax
08A647A3  8A 45 64                      mov al, 100[ebp]

#65				NOT	{LNXT:22|30|-1}
(*) BOOL
08A647A6  84 C0                         test al, al
08A647A8  0F 94 C0                      sete al

#66				AND		o_val_close_R_FB^	{LNXT:22|30|-1}
(*) BOOL
08A647AB  8B 55 6E                      mov edx, 110[ebp]
08A647AE  8B 55 6E                      mov edx, 110[ebp]
08A647B1  33 C9                         xor ecx, ecx
08A647B3  8A 0A                         mov cl, [edx]
08A647B5  23 C1                         and eax, ecx

#67				OR(		prev_val_open_R	{LNXT:22|30|-1}
(*) BOOL
08A647B7  50                            push eax
08A647B8  33 C0                         xor eax, eax
08A647BA  8A 45 63                      mov al, 99[ebp]

#68				NOT	{LNXT:22|30|-1}
(*) BOOL
08A647BD  84 C0                         test al, al
08A647BF  0F 94 C0                      sete al

#69				AND		o_val_open_R_FB^	{LNXT:22|30|-1}
(*) BOOL
08A647C2  8B 55 6A                      mov edx, 106[ebp]
08A647C5  8B 55 6A                      mov edx, 106[ebp]
08A647C8  33 C9                         xor ecx, ecx
08A647CA  8A 0A                         mov cl, [edx]
08A647CC  23 C1                         and eax, ecx

#70				OR(		prev_val_close_fall	{LNXT:22|30|-1}
(*) BOOL
08A647CE  50                            push eax
08A647CF  33 C0                         xor eax, eax
08A647D1  8A 45 62                      mov al, 98[ebp]

#71				NOT	{LNXT:22|30|-1}
(*) BOOL
08A647D4  84 C0                         test al, al
08A647D6  0F 94 C0                      sete al

#72				AND		o_val_close_fall_FB^	{LNXT:22|30|-1}
(*) BOOL
08A647D9  8B 55 76                      mov edx, 118[ebp]
08A647DC  8B 55 76                      mov edx, 118[ebp]
08A647DF  33 C9                         xor ecx, ecx
08A647E1  8A 0A                         mov cl, [edx]
08A647E3  23 C1                         and eax, ecx

#73				OR(		prev_val_open_fall	{LNXT:22|30|-1}
(*) BOOL
08A647E5  50                            push eax
08A647E6  33 C0                         xor eax, eax
08A647E8  8A 45 61                      mov al, 97[ebp]

#74				NOT	{LNXT:22|30|-1}
(*) BOOL
08A647EB  84 C0                         test al, al
08A647ED  0F 94 C0                      sete al

#75				AND		o_val_open_fall_FB^	{LNXT:22|30|-1}
(*) BOOL
08A647F0  8B 55 72                      mov edx, 114[ebp]
08A647F3  8B 55 72                      mov edx, 114[ebp]
08A647F6  33 C9                         xor ecx, ecx
08A647F8  8A 0A                         mov cl, [edx]
08A647FA  23 C1                         and eax, ecx

#76				)	{LNXT:22|30|-1}
(*) BOOL
08A647FC  8B C8                         mov ecx, eax
08A647FE  58                            pop eax
08A647FF  0B C1                         or eax, ecx

#77				)	{LNXT:22|30|-1}
(*) BOOL
08A64801  8B C8                         mov ecx, eax
08A64803  58                            pop eax
08A64804  0B C1                         or eax, ecx

#78				)	{LNXT:22|30|-1}
(*) BOOL
08A64806  8B C8                         mov ecx, eax
08A64808  58                            pop eax
08A64809  0B C1                         or eax, ecx

#79				ST		valve_rising	{LNXT:22|30|-1}
(*) BOOL
08A6480B  84 C0                         test al, al
08A6480D  0F 95 45 60                   setne 96[ebp]

#80		
#81				(* checkAlarmVal *)
#82				MOVE		di_val_open_state_fall_FB,checkAlarmVal.di_val_open_state_fall_FB	{LNXT:30|-1|-1}
(*) BOOL
08A64811  8B 95 86 00 00 00             mov edx, 134[ebp]
08A64817  8D 02                         lea eax, [edx]
08A64819  89 45 30                      mov 48[ebp], eax

#83				MOVE		di_val_close_state_fall_FB,checkAlarmVal.di_val_close_state_fall_FB	{LNXT:30|-1|-1}
(*) INT^
08A6481C  8B 95 8A 00 00 00             mov edx, 138[ebp]
08A64822  8D 02                         lea eax, [edx]
08A64824  89 45 34                      mov 52[ebp], eax

#84				MOVE		di_val_open_state_R_FB,checkAlarmVal.di_val_open_state_R_FB	{LNXT:31|-1|-1}
(*) INT^
08A64827  8B 95 8E 00 00 00             mov edx, 142[ebp]
08A6482D  8D 02                         lea eax, [edx]
08A6482F  89 45 38                      mov 56[ebp], eax

#85				MOVE		di_val_close_state_R_FB,checkAlarmVal.di_val_close_state_R_FB	{LNXT:32|-1|-1}
(*) INT^
08A64832  8B 95 92 00 00 00             mov edx, 146[ebp]
08A64838  8D 02                         lea eax, [edx]
08A6483A  89 45 3C                      mov 60[ebp], eax

#86				MOVE		Alarm_Val_FB,checkAlarmVal.Alarm_Val_FB	{LNXT:33|-1|-1}
(*) BOOL^
08A6483D  8B 95 96 00 00 00             mov edx, 150[ebp]
08A64843  8D 02                         lea eax, [edx]
08A64845  89 45 40                      mov 64[ebp], eax

#87				MOVE		o_val_open_R_FB,checkAlarmVal.o_val_open_R_FB	{LNXT:34|-1|-1}
(*) WORD^
08A64848  8B 55 6A                      mov edx, 106[ebp]
08A6484B  8D 02                         lea eax, [edx]
08A6484D  89 45 44                      mov 68[ebp], eax

#88				MOVE		o_val_close_R_FB,checkAlarmVal.o_val_close_R_FB	{LNXT:35|-1|-1}
(*) BOOL^
08A64850  8B 55 6E                      mov edx, 110[ebp]
08A64853  8D 02                         lea eax, [edx]
08A64855  89 45 48                      mov 72[ebp], eax

#89				MOVE		o_val_open_fall_FB,checkAlarmVal.o_val_open_fall_FB	{LNXT:36|-1|-1}
(*) BOOL^
08A64858  8B 55 72                      mov edx, 114[ebp]
08A6485B  8D 02                         lea eax, [edx]
08A6485D  89 45 4C                      mov 76[ebp], eax

#90				MOVE		o_val_close_fall_FB,checkAlarmVal.o_val_close_fall_FB	{LNXT:37|-1|-1}
(*) BOOL^
08A64860  8B 55 76                      mov edx, 118[ebp]
08A64863  8D 02                         lea eax, [edx]
08A64865  89 45 50                      mov 80[ebp], eax

#91				MOVE		valve_rising,checkAlarmVal.start_check	{LNXT:38|-1|-1}
(*) BOOL^
08A64868  8D 45 60                      lea eax, 96[ebp]
08A6486B  89 45 54                      mov 84[ebp], eax

#92				CAL		checkAlarmVal	{LNXT:30|43|-1}
(*) BOOL^
08A6486E  50                            push eax
08A6486F  8B DD                         mov ebx, ebp
08A64871  81 C3 17 00 00 00             add ebx, 23
08A64877  E8 C5 FC FF FF                call 08A64541H ; $$CODE$$+17729
08A6487C  58                            pop eax

#93		
#94		
#95				(* IF checkAlarmVal.is_check_done and checkAlarmVal.isOK *)
#96				LD		checkAlarmVal.is_check_done	{LNXT:43|-1|-1}
(*) UNDEF
08A6487D  33 C0                         xor eax, eax
08A6487F  8A 45 2E                      mov al, 46[ebp]

#97				AND		checkAlarmVal.isOK	{LNXT:43|-1|-1}
(*) BOOL
08A64882  33 C9                         xor ecx, ecx
08A64884  8A 4D 2F                      mov cl, 47[ebp]
08A64887  23 C1                         and eax, ecx

#98				JMPCN	$label4	{LNXT:43|44|46}
(-) BOOL
08A64889  84 C0                         test al, al
08A6488B  90 74 15 90 90 90             je 08A648A3H

#99		
#100				(* THEN *)
#101		
#102					(* q_start_ats_FB^:=true; *)
#103					MOVE		true,q_start_ats_FB^	{LNXT:44|56|-1}
(*) BOOL
08A64891  B8 01 00 00 00                mov eax, 01H
08A64896  8B 55 7A                      mov edx, 122[ebp]
08A64899  84 C0                         test al, al
08A6489B  0F 95 02                      setne [edx]

#104					JMP		$label5	{LNXT:43|44|46}
(-) BOOL
08A6489E  EB 10 90 90 90                jmp 08A648B0H

#105		$label4:
#106		
#107				(* ELSE *)
#108		
#109					(* q_start_ats_FB^:=false; *)
#110					MOVE		false,q_start_ats_FB^	{LNXT:46|56|-1}
(*) BOOL
08A648A3  B8 00 00 00 00                mov eax, 00H
08A648A8  8B 55 7A                      mov edx, 122[ebp]
08A648AB  84 C0                         test al, al
08A648AD  0F 95 02                      setne [edx]

#111		
#112		$label5:
#113				(* END_IF *)
#114				JMP		$label3	{LNXT:7|10|52}
(-) BOOL
08A648B0  EB 10 90 90 90                jmp 08A648C2H

#115		$label2:
#116		
#117			(* ELSE *)
#118		
#119				(* q_start_ats_FB^:=true; *)
#120				MOVE		true,q_start_ats_FB^	{LNXT:52|56|-1}
(*) BOOL
08A648B5  B8 01 00 00 00                mov eax, 01H
08A648BA  8B 55 7A                      mov edx, 122[ebp]
08A648BD  84 C0                         test al, al
08A648BF  0F 95 02                      setne [edx]

#121		
#122		$label3:
#123			(* END_IF *)
#124		
#125		
#126			(* IF washing_timer.Q *)
#127			LD		washing_timer.Q	{LNXT:56|-1|-1}
(*) UNDEF
08A648C2  33 C0                         xor eax, eax
08A648C4  8A 45 09                      mov al, 9[ebp]

#128			JMPCN	$label6	{LNXT:56|57|70}
(-) BOOL
08A648C7  84 C0                         test al, al
08A648C9  90 74 5A 90 90 90             je 08A64926H

#129		
#130			(* THEN *)
#131		
#132				(* sv_washing_FB^:=false; *)
#133				MOVE		false,sv_washing_FB^	{LNXT:57|58|-1}
(*) BOOL
08A648CF  B8 00 00 00 00                mov eax, 00H
08A648D4  8B 55 66                      mov edx, 102[ebp]
08A648D7  84 C0                         test al, al
08A648D9  0F 95 02                      setne [edx]

#134		
#135				(* onWash :=false; *)
#136				MOVE		false,onWash	{LNXT:58|61|-1}
(*) BOOL
08A648DC  B8 00 00 00 00                mov eax, 00H
08A648E1  84 C0                         test al, al
08A648E3  0F 95 45 16                   setne 22[ebp]

#137		
#138				(* o_val_close_R_FB^:=false; *)
#139				MOVE		false,o_val_close_R_FB^	{LNXT:61|62|-1}
(*) BOOL
08A648E7  B8 00 00 00 00                mov eax, 00H
08A648EC  8B 55 6E                      mov edx, 110[ebp]
08A648EF  84 C0                         test al, al
08A648F1  0F 95 02                      setne [edx]

#140		
#141				(* o_val_open_fall_FB^:=false; *)
#142				MOVE		false,o_val_open_fall_FB^	{LNXT:62|64|-1}
(*) BOOL
08A648F4  B8 00 00 00 00                mov eax, 00H
08A648F9  8B 55 72                      mov edx, 114[ebp]
08A648FC  84 C0                         test al, al
08A648FE  0F 95 02                      setne [edx]

#143		
#144				(* o_val_open_R_FB^:=true; *)
#145				MOVE		true,o_val_open_R_FB^	{LNXT:64|65|-1}
(*) BOOL
08A64901  B8 01 00 00 00                mov eax, 01H
08A64906  8B 55 6A                      mov edx, 106[ebp]
08A64909  84 C0                         test al, al
08A6490B  0F 95 02                      setne [edx]

#146		
#147				(* o_val_close_fall_FB^:=true; *)
#148				MOVE		true,o_val_close_fall_FB^	{LNXT:65|67|-1}
(*) BOOL
08A6490E  B8 01 00 00 00                mov eax, 01H
08A64913  8B 55 76                      mov edx, 118[ebp]
08A64916  84 C0                         test al, al
08A64918  0F 95 02                      setne [edx]

#149		
#150				(* is_running_wash :=false; *)
#151				MOVE		false,is_running_wash	{LNXT:67|70|-1}
(*) BOOL
08A6491B  B8 00 00 00 00                mov eax, 00H
08A64920  84 C0                         test al, al
08A64922  0F 95 45 65                   setne 101[ebp]

#152		
#153		$label6:
#154			(* END_IF *)
#155		
#156			(* washing_timer *)
#157			LD		onWash	{LNXT:70|-1|-1}
(*) UNDEF
08A64926  33 C0                         xor eax, eax
08A64928  8A 45 16                      mov al, 22[ebp]

#158			AND		q_start_ats_FB^	{LNXT:70|-1|-1}
(*) BOOL
08A6492B  8B 55 7A                      mov edx, 122[ebp]
08A6492E  8B 55 7A                      mov edx, 122[ebp]
08A64931  33 C9                         xor ecx, ecx
08A64933  8A 0A                         mov cl, [edx]
08A64935  23 C1                         and eax, ecx

#159			ST		washing_timer.IN	{LNXT:70|-1|-1}
(*) BOOL
08A64937  84 C0                         test al, al
08A64939  0F 95 45 04                   setne 4[ebp]

#160			MOVE		ep_time_wash_FB^,washing_timer.PT	{LNXT:70|-1|-1}
(*) BOOL
08A6493D  8B 55 7E                      mov edx, 126[ebp]
08A64940  0F BF 02                      movsx eax, word ptr [edx]
08A64943  89 45 05                      mov 5[ebp], eax

#161			CAL		washing_timer	{LNXT:70|-1|-1}
(*) INT
08A64946  50                            push eax
08A64947  8B DD                         mov ebx, ebp
08A64949  E8 6B FB FF FF                call 08A644B9H ; $$CODE$$+17593
08A6494E  58                            pop eax

08A6494F  5F                            pop edi
08A64950  5D                            pop ebp

08A64951  C3                            ret


Frame allocation (hex):

	0000       : FB washing_timer
	0016 bit  0: VAR onWash
	0017       : FB checkAlarmVal
	0060 bit  0: VAR valve_rising
	0061 bit  0: VAR prev_val_open_fall
	0062 bit  0: VAR prev_val_close_fall
	0063 bit  0: VAR prev_val_open_R
	0064 bit  0: VAR prev_val_close_R
	0065 bit  0: VAR is_running_wash
	0066       : VAR sv_washing_FB
	006A       : VAR o_val_open_R_FB
	006E       : VAR o_val_close_R_FB
	0072       : VAR o_val_open_fall_FB
	0076       : VAR o_val_close_fall_FB
	007A       : VAR q_start_ats_FB
	007E       : VAR ep_time_wash_FB
	0082       : VAR i_val_state_FB
	0086       : VAR di_val_open_state_fall_FB
	008A       : VAR di_val_close_state_fall_FB
	008E       : VAR di_val_open_state_R_FB
	0092       : VAR di_val_close_state_R_FB
	0096       : VAR Alarm_Val_FB

END_FUNCTION_BLOCK
**************************************************
	List program: ATS_mdb
**************************************************

PROGRAM ATS_mdb

        VAR
res_eta_lcr : UINT;
resp_eta_lcr : ARRAY[0..3] OF INT;
res : INT;
xTON : TON;
	END_VAR

END_PROGRAM

08A64960  55                            push ebp
08A64961  8B EC                         mov ebp, esp
08A64963  60                            pushad

#0		{SRC:ATS_mdb}
#1		(*$WAITSWITCH$*)
#2		
#3			(* res := sysMbMRTU_FC03(	addr := 1, 
#4											base := 257, // 256
#5											no := 4, 
#6											object := ADR(resp_eta_lcr), 
#7											timeout := 200); *)
#8			ADR		resp_eta_lcr	{LNXT:2|8|-1}
(*) UDINT
08A64964  B8 CC CC CC CC                mov eax, CCCCCCCCH ; $$DATA$$+12

#9			ST		$$TMP0	{LNXT:2|8|-1}
(*) @INT
08A64969  89 05 CC CC CC CC             mov [CCCCCCCCH], eax ; $$DATA$$+20

#10			LDP0		1	{LNXT:2|8|-1}
(*) @INT
#11			sysMbMRTU_FC03		257, 4, $$TMP0, 200	{LNXT:2|8|-1}
(*) @INT
08A6496F  68 C8 00 00 00                push 200
08A64974  FF 35 CC CC CC CC             push [CCCCCCCCH] ; $$DATA$$+20
08A6497A  68 04 00 00 00                push 4
08A6497F  68 01 01 00 00                push 257
08A64984  68 01 00 00 00                push 1
08A64989  B9 CC CC CC CC                mov ecx, CCCCCCCCH ; sysMbMRTU_FC03
08A6498E  FF D1                         call ecx
08A64990  81 C4 14 00 00 00             add esp, 20

#12			ST		res	{LNXT:2|8|-1}
(*) UINT
08A64996  66 89 05 CC CC CC CC          mov [CCCCCCCCH], ax ; $$DATA$$+24

#13		
#14			(* ATS22_DUT.Ready 	:= to_bool(resp_eta_lcr[0] And 16#01); *)
#15			LD		resp_eta_lcr[0]	{LNXT:8|9|-1}
(*) UNDEF
08A6499D  0F BF 05 CC CC CC CC          movsx eax, word ptr [CCCCCCCCH] ; $$DATA$$+12

#16			AND		16#01	{LNXT:8|9|-1}
(*) INT
08A649A4  25 01 00 00 00                and eax, 00000001H

#17			to_bool	{LNXT:8|9|-1}
(*) INT
08A649A9  66 85 C0                      test ax, ax
08A649AC  0F 95 C0                      setne al

#18			ST		ATS22_DUT.Ready	{LNXT:8|9|-1}
(*) BOOL
08A649AF  84 C0                         test al, al
08A649B1  0F 95 05 CC CC CC CC          setne [CCCCCCCCH] ; $$DATA$$+26

#19		
#20			(* ATS22_DUT.On 		:= to_bool(resp_eta_lcr[0] And 16#02); *)
#21			LD		resp_eta_lcr[0]	{LNXT:9|10|-1}
(*) UNDEF
08A649B8  0F BF 05 CC CC CC CC          movsx eax, word ptr [CCCCCCCCH] ; $$DATA$$+12

#22			AND		16#02	{LNXT:9|10|-1}
(*) INT
08A649BF  25 02 00 00 00                and eax, 00000002H

#23			to_bool	{LNXT:9|10|-1}
(*) INT
08A649C4  66 85 C0                      test ax, ax
08A649C7  0F 95 C0                      setne al

#24			ST		ATS22_DUT.On	{LNXT:9|10|-1}
(*) BOOL
08A649CA  84 C0                         test al, al
08A649CC  0F 95 05 CC CC CC CC          setne [CCCCCCCCH] ; $$DATA$$+27

#25		
#26			(* ATS22_DUT.Trip 		:= to_bool(resp_eta_lcr[0] And 16#04); *)
#27			LD		resp_eta_lcr[0]	{LNXT:10|11|-1}
(*) UNDEF
08A649D3  0F BF 05 CC CC CC CC          movsx eax, word ptr [CCCCCCCCH] ; $$DATA$$+12

#28			AND		16#04	{LNXT:10|11|-1}
(*) INT
08A649DA  25 04 00 00 00                and eax, 00000004H

#29			to_bool	{LNXT:10|11|-1}
(*) INT
08A649DF  66 85 C0                      test ax, ax
08A649E2  0F 95 C0                      setne al

#30			ST		ATS22_DUT.Trip	{LNXT:10|11|-1}
(*) BOOL
08A649E5  84 C0                         test al, al
08A649E7  0F 95 05 CC CC CC CC          setne [CCCCCCCCH] ; $$DATA$$+28

#31		
#32			(* ATS22_DUT.Warning 	:= to_bool(resp_eta_lcr[0] And 16#08); *)
#33			LD		resp_eta_lcr[0]	{LNXT:11|12|-1}
(*) UNDEF
08A649EE  0F BF 05 CC CC CC CC          movsx eax, word ptr [CCCCCCCCH] ; $$DATA$$+12

#34			AND		16#08	{LNXT:11|12|-1}
(*) INT
08A649F5  25 08 00 00 00                and eax, 00000008H

#35			to_bool	{LNXT:11|12|-1}
(*) INT
08A649FA  66 85 C0                      test ax, ax
08A649FD  0F 95 C0                      setne al

#36			ST		ATS22_DUT.Warning	{LNXT:11|12|-1}
(*) BOOL
08A64A00  84 C0                         test al, al
08A64A02  0F 95 05 CC CC CC CC          setne [CCCCCCCCH] ; $$DATA$$+29

#37		
#38			(* ATS22_DUT.LI3 		:= to_bool(resp_eta_lcr[0] And 16#20); *)
#39			LD		resp_eta_lcr[0]	{LNXT:12|13|-1}
(*) UNDEF
08A64A09  0F BF 05 CC CC CC CC          movsx eax, word ptr [CCCCCCCCH] ; $$DATA$$+12

#40			AND		16#20	{LNXT:12|13|-1}
(*) INT
08A64A10  25 20 00 00 00                and eax, 00000020H

#41			to_bool	{LNXT:12|13|-1}
(*) INT
08A64A15  66 85 C0                      test ax, ax
08A64A18  0F 95 C0                      setne al

#42			ST		ATS22_DUT.LI3	{LNXT:12|13|-1}
(*) BOOL
08A64A1B  84 C0                         test al, al
08A64A1D  0F 95 05 CC CC CC CC          setne [CCCCCCCCH] ; $$DATA$$+30

#43		
#44			(* ATS22_DUT.LI2 		:= to_bool(resp_eta_lcr[0] And 16#40); *)
#45			LD		resp_eta_lcr[0]	{LNXT:13|14|-1}
(*) UNDEF
08A64A24  0F BF 05 CC CC CC CC          movsx eax, word ptr [CCCCCCCCH] ; $$DATA$$+12

#46			AND		16#40	{LNXT:13|14|-1}
(*) INT
08A64A2B  25 40 00 00 00                and eax, 00000040H

#47			to_bool	{LNXT:13|14|-1}
(*) INT
08A64A30  66 85 C0                      test ax, ax
08A64A33  0F 95 C0                      setne al

#48			ST		ATS22_DUT.LI2	{LNXT:13|14|-1}
(*) BOOL
08A64A36  84 C0                         test al, al
08A64A38  0F 95 05 CC CC CC CC          setne [CCCCCCCCH] ; $$DATA$$+31

#49		
#50			(* ATS22_DUT.LI1 		:= to_bool(resp_eta_lcr[0] And 16#80); *)
#51			LD		resp_eta_lcr[0]	{LNXT:14|17|-1}
(*) UNDEF
08A64A3F  0F BF 05 CC CC CC CC          movsx eax, word ptr [CCCCCCCCH] ; $$DATA$$+12

#52			AND		16#80	{LNXT:14|17|-1}
(*) INT
08A64A46  25 80 00 00 00                and eax, 00000080H

#53			to_bool	{LNXT:14|17|-1}
(*) INT
08A64A4B  66 85 C0                      test ax, ax
08A64A4E  0F 95 C0                      setne al

#54			ST		ATS22_DUT.LI1	{LNXT:14|17|-1}
(*) BOOL
08A64A51  84 C0                         test al, al
08A64A53  0F 95 05 CC CC CC CC          setne [CCCCCCCCH] ; $$DATA$$+32

#55		
#56			(* ATS_State_bits.0 := ATS22_DUT.Ready; *)
#57			MOVE		ATS22_DUT.Ready,ATS_State_bits.0	{LNXT:17|18|-1}
(*) BOOL
08A64A5A  33 C0                         xor eax, eax
08A64A5C  8A 05 CC CC CC CC             mov al, [CCCCCCCCH] ; $$DATA$$+26
08A64A62  84 C0                         test al, al
08A64A64  90 75 11 90 90 90             jne 00000014H@
08A64A6A  66 0F BA 35 CC CC CC CC 00    btr word ptr [CCCCCCCCH], 0 ; %M110+16
08A64A73  EB 0C 90 90 90                jmp 0000000EH@
08A64A78  66 0F BA 2D CC CC CC CC 00    bts word ptr [CCCCCCCCH], 0 ; %M110+16

#58		
#59			(* ATS_State_bits.1 := ATS22_DUT.On And i_run_ats; *)
#60			LD		ATS22_DUT.On	{LNXT:18|19|-1}
(*) UNDEF
08A64A81  33 C0                         xor eax, eax
08A64A83  8A 05 CC CC CC CC             mov al, [CCCCCCCCH] ; $$DATA$$+27

#61			AND		i_run_ats	{LNXT:18|19|-1}
(*) BOOL
08A64A89  33 C9                         xor ecx, ecx
08A64A8B  8A 0D CC CC CC CC             mov cl, [CCCCCCCCH] ; $$DATA$$+52
08A64A91  23 C1                         and eax, ecx

#62			ST		ATS_State_bits.1	{LNXT:18|19|-1}
(*) BOOL
08A64A93  84 C0                         test al, al
08A64A95  90 75 11 90 90 90             jne 00000014H@
08A64A9B  66 0F BA 35 CC CC CC CC 01    btr word ptr [CCCCCCCCH], 1 ; %M110+16
08A64AA4  EB 0C 90 90 90                jmp 0000000EH@
08A64AA9  66 0F BA 2D CC CC CC CC 01    bts word ptr [CCCCCCCCH], 1 ; %M110+16

#63		
#64			(* ATS_State_bits.2 := ATS22_DUT.Trip Or Not i_no_alm_ats ; *)
#65			LD		i_no_alm_ats	{LNXT:19|20|-1}
(*) UNDEF
08A64AB2  33 C0                         xor eax, eax
08A64AB4  8A 05 CC CC CC CC             mov al, [CCCCCCCCH] ; $$DATA$$+53

#66			NOT	{LNXT:19|20|-1}
(*) BOOL
08A64ABA  84 C0                         test al, al
08A64ABC  0F 94 C0                      sete al

#67			OR		ATS22_DUT.Trip	{LNXT:19|20|-1}
(*) BOOL
08A64ABF  33 C9                         xor ecx, ecx
08A64AC1  8A 0D CC CC CC CC             mov cl, [CCCCCCCCH] ; $$DATA$$+28
08A64AC7  0B C1                         or eax, ecx

#68			ST		ATS_State_bits.2	{LNXT:19|20|-1}
(*) BOOL
08A64AC9  84 C0                         test al, al
08A64ACB  90 75 11 90 90 90             jne 00000014H@
08A64AD1  66 0F BA 35 CC CC CC CC 02    btr word ptr [CCCCCCCCH], 2 ; %M110+16
08A64ADA  EB 0C 90 90 90                jmp 0000000EH@
08A64ADF  66 0F BA 2D CC CC CC CC 02    bts word ptr [CCCCCCCCH], 2 ; %M110+16

#69		
#70			(* ATS_State_bits.3 := ATS22_DUT.Warning; *)
#71			MOVE		ATS22_DUT.Warning,ATS_State_bits.3	{LNXT:20|21|-1}
(*) BOOL
08A64AE8  33 C0                         xor eax, eax
08A64AEA  8A 05 CC CC CC CC             mov al, [CCCCCCCCH] ; $$DATA$$+29
08A64AF0  84 C0                         test al, al
08A64AF2  90 75 11 90 90 90             jne 00000014H@
08A64AF8  66 0F BA 35 CC CC CC CC 03    btr word ptr [CCCCCCCCH], 3 ; %M110+16
08A64B01  EB 0C 90 90 90                jmp 0000000EH@
08A64B06  66 0F BA 2D CC CC CC CC 03    bts word ptr [CCCCCCCCH], 3 ; %M110+16

#72		
#73			(* ATS_State_bits.4 := ATS22_DUT.Local; *)
#74			MOVE		ATS22_DUT.Local,ATS_State_bits.4	{LNXT:21|22|-1}
(*) BOOL
08A64B0F  33 C0                         xor eax, eax
08A64B11  8A 05 CC CC CC CC             mov al, [CCCCCCCCH] ; $$DATA$$+34
08A64B17  84 C0                         test al, al
08A64B19  90 75 11 90 90 90             jne 00000014H@
08A64B1F  66 0F BA 35 CC CC CC CC 04    btr word ptr [CCCCCCCCH], 4 ; %M110+16
08A64B28  EB 0C 90 90 90                jmp 0000000EH@
08A64B2D  66 0F BA 2D CC CC CC CC 04    bts word ptr [CCCCCCCCH], 4 ; %M110+16

#75		
#76			(* ATS_State_bits.5 := ATS22_DUT.Ramping; *)
#77			MOVE		ATS22_DUT.Ramping,ATS_State_bits.5	{LNXT:22|23|-1}
(*) BOOL
08A64B36  33 C0                         xor eax, eax
08A64B38  8A 05 CC CC CC CC             mov al, [CCCCCCCCH] ; $$DATA$$+35
08A64B3E  84 C0                         test al, al
08A64B40  90 75 11 90 90 90             jne 00000014H@
08A64B46  66 0F BA 35 CC CC CC CC 05    btr word ptr [CCCCCCCCH], 5 ; %M110+16
08A64B4F  EB 0C 90 90 90                jmp 0000000EH@
08A64B54  66 0F BA 2D CC CC CC CC 05    bts word ptr [CCCCCCCCH], 5 ; %M110+16

#78		
#79			(* ATS_State_bits.6 := ATS22_DUT.LI1; *)
#80			MOVE		ATS22_DUT.LI1,ATS_State_bits.6	{LNXT:23|24|-1}
(*) BOOL
08A64B5D  33 C0                         xor eax, eax
08A64B5F  8A 05 CC CC CC CC             mov al, [CCCCCCCCH] ; $$DATA$$+32
08A64B65  84 C0                         test al, al
08A64B67  90 75 11 90 90 90             jne 00000014H@
08A64B6D  66 0F BA 35 CC CC CC CC 06    btr word ptr [CCCCCCCCH], 6 ; %M110+16
08A64B76  EB 0C 90 90 90                jmp 0000000EH@
08A64B7B  66 0F BA 2D CC CC CC CC 06    bts word ptr [CCCCCCCCH], 6 ; %M110+16

#81		
#82			(* ATS_State_bits.7 := ATS22_DUT.LI2; *)
#83			MOVE		ATS22_DUT.LI2,ATS_State_bits.7	{LNXT:24|25|-1}
(*) BOOL
08A64B84  33 C0                         xor eax, eax
08A64B86  8A 05 CC CC CC CC             mov al, [CCCCCCCCH] ; $$DATA$$+31
08A64B8C  84 C0                         test al, al
08A64B8E  90 75 11 90 90 90             jne 00000014H@
08A64B94  66 0F BA 35 CC CC CC CC 07    btr word ptr [CCCCCCCCH], 7 ; %M110+16
08A64B9D  EB 0C 90 90 90                jmp 0000000EH@
08A64BA2  66 0F BA 2D CC CC CC CC 07    bts word ptr [CCCCCCCCH], 7 ; %M110+16

#84		
#85			(* ATS_State_bits.8 := ATS22_DUT.LI3; *)
#86			MOVE		ATS22_DUT.LI3,ATS_State_bits.8	{LNXT:25|28|-1}
(*) BOOL
08A64BAB  33 C0                         xor eax, eax
08A64BAD  8A 05 CC CC CC CC             mov al, [CCCCCCCCH] ; $$DATA$$+30
08A64BB3  84 C0                         test al, al
08A64BB5  90 75 11 90 90 90             jne 00000014H@
08A64BBB  66 0F BA 35 CC CC CC CC 08    btr word ptr [CCCCCCCCH], 8 ; %M110+16
08A64BC4  EB 0C 90 90 90                jmp 0000000EH@
08A64BC9  66 0F BA 2D CC CC CC CC 08    bts word ptr [CCCCCCCCH], 8 ; %M110+16

#87		
#88			(* ATS_State_bits.9 := i_pb_loc; *)
#89			MOVE		i_pb_loc,ATS_State_bits.9	{LNXT:28|29|-1}
(*) BOOL
08A64BD2  0F BF 05 CC CC CC CC          movsx eax, word ptr [CCCCCCCCH] ; $$DATA$$+54
08A64BD9  66 85 C0                      test ax, ax
08A64BDC  90 75 11 90 90 90             jne 00000014H@
08A64BE2  66 0F BA 35 CC CC CC CC 09    btr word ptr [CCCCCCCCH], 9 ; %M110+16
08A64BEB  EB 0C 90 90 90                jmp 0000000EH@
08A64BF0  66 0F BA 2D CC CC CC CC 09    bts word ptr [CCCCCCCCH], 9 ; %M110+16

#90		
#91			(* ATS_State_bits.10 := i_pb_rem; *)
#92			MOVE		i_pb_rem,ATS_State_bits.10	{LNXT:29|31|-1}
(*) INT
08A64BF9  0F BF 05 CC CC CC CC          movsx eax, word ptr [CCCCCCCCH] ; $$DATA$$+56
08A64C00  66 85 C0                      test ax, ax
08A64C03  90 75 11 90 90 90             jne 00000014H@
08A64C09  66 0F BA 35 CC CC CC CC 0A    btr word ptr [CCCCCCCCH], 10 ; %M110+16
08A64C12  EB 0C 90 90 90                jmp 0000000EH@
08A64C17  66 0F BA 2D CC CC CC CC 0A    bts word ptr [CCCCCCCCH], 10 ; %M110+16

#93		
#94		
#95			(* IF i_pb_loc AND not i_pb_rem *)
#96			LD		i_pb_rem	{LNXT:31|-1|-1}
(*) UNDEF
08A64C20  0F BF 05 CC CC CC CC          movsx eax, word ptr [CCCCCCCCH] ; $$DATA$$+56

#97			NOT	{LNXT:31|-1|-1}
(*) INT
08A64C27  66 F7 D0                      not ax

#98			AND(		i_pb_loc	{LNXT:31|-1|-1}
(*) INT
08A64C2A  50                            push eax
08A64C2B  0F BF 05 CC CC CC CC          movsx eax, word ptr [CCCCCCCCH] ; $$DATA$$+54

#99			NOT	{LNXT:31|-1|-1}
(*) INT
08A64C32  66 F7 D0                      not ax

#100			)	{LNXT:31|-1|-1}
(*) INT
08A64C35  8B C8                         mov ecx, eax
08A64C37  58                            pop eax
08A64C38  23 C1                         and eax, ecx

#101			JMPCN	$label0	{LNXT:31|32|34}
(-) INT
08A64C3A  66 85 C0                      test ax, ax
08A64C3D  90 74 27 90 90 90             je 08A64C67H

#102		
#103			(* THEN *)
#104		
#105				(* ATS_State_bits.11 := TRUE; *)
#106				MOVE		TRUE,ATS_State_bits.11	{LNXT:32|34|-1}
(*) INT
08A64C43  B8 01 00 00 00                mov eax, 01H
08A64C48  84 C0                         test al, al
08A64C4A  90 75 11 90 90 90             jne 00000014H@
08A64C50  66 0F BA 35 CC CC CC CC 0B    btr word ptr [CCCCCCCCH], 11 ; %M110+16
08A64C59  EB 0C 90 90 90                jmp 0000000EH@
08A64C5E  66 0F BA 2D CC CC CC CC 0B    bts word ptr [CCCCCCCCH], 11 ; %M110+16

#107		
#108		$label0:
#109			(* END_IF *)
#110		
#111		
#112			(* IF i_pb_loc AND i_pb_rem *)
#113			LD		i_pb_loc	{LNXT:34|-1|-1}
(*) UNDEF
08A64C67  0F BF 05 CC CC CC CC          movsx eax, word ptr [CCCCCCCCH] ; $$DATA$$+54

#114			NOT	{LNXT:34|-1|-1}
(*) INT
08A64C6E  66 F7 D0                      not ax

#115			AND		i_pb_rem	{LNXT:34|-1|-1}
(*) INT
08A64C71  0F BF 0D CC CC CC CC          movsx ecx, word ptr [CCCCCCCCH] ; $$DATA$$+56
08A64C78  23 C1                         and eax, ecx

#116			JMPCN	$label1	{LNXT:34|35|37}
(-) INT
08A64C7A  66 85 C0                      test ax, ax
08A64C7D  90 74 27 90 90 90             je 08A64CA7H

#117		
#118			(* THEN *)
#119		
#120				(* ATS_State_bits.11 := FALSE; *)
#121				MOVE		FALSE,ATS_State_bits.11	{LNXT:35|37|-1}
(*) INT
08A64C83  B8 00 00 00 00                mov eax, 00H
08A64C88  84 C0                         test al, al
08A64C8A  90 75 11 90 90 90             jne 00000014H@
08A64C90  66 0F BA 35 CC CC CC CC 0B    btr word ptr [CCCCCCCCH], 11 ; %M110+16
08A64C99  EB 0C 90 90 90                jmp 0000000EH@
08A64C9E  66 0F BA 2D CC CC CC CC 0B    bts word ptr [CCCCCCCCH], 11 ; %M110+16

#122		
#123		$label1:
#124			(* END_IF *)
#125		
#126		
#127			(* IF i_pb_loc AND not i_pb_rem *)
#128			LD		i_pb_rem	{LNXT:37|-1|-1}
(*) UNDEF
08A64CA7  0F BF 05 CC CC CC CC          movsx eax, word ptr [CCCCCCCCH] ; $$DATA$$+56

#129			NOT	{LNXT:37|-1|-1}
(*) INT
08A64CAE  66 F7 D0                      not ax

#130			AND		i_pb_loc	{LNXT:37|-1|-1}
(*) INT
08A64CB1  0F BF 0D CC CC CC CC          movsx ecx, word ptr [CCCCCCCCH] ; $$DATA$$+54
08A64CB8  23 C1                         and eax, ecx

#131			JMPCN	$label2	{LNXT:37|38|43}
(-) INT
08A64CBA  66 85 C0                      test ax, ax
08A64CBD  90 74 27 90 90 90             je 08A64CE7H

#132		
#133			(* THEN *)
#134		
#135				(* ATS_State_bits.11 := FALSE; *)
#136				MOVE		FALSE,ATS_State_bits.11	{LNXT:38|43|-1}
(*) INT
08A64CC3  B8 00 00 00 00                mov eax, 00H
08A64CC8  84 C0                         test al, al
08A64CCA  90 75 11 90 90 90             jne 00000014H@
08A64CD0  66 0F BA 35 CC CC CC CC 0B    btr word ptr [CCCCCCCCH], 11 ; %M110+16
08A64CD9  EB 0C 90 90 90                jmp 0000000EH@
08A64CDE  66 0F BA 2D CC CC CC CC 0B    bts word ptr [CCCCCCCCH], 11 ; %M110+16

#137		
#138		$label2:
#139			(* END_IF *)
#140		
#141			(* ATS22_DUT.EtaCurrent := to_byte(SHR(resp_eta_lcr[0] AND 16#3F00, 16#08) * 200 / 63); *)
#142			LD		resp_eta_lcr[0]	{LNXT:43|44|-1}
(*) UNDEF
08A64CE7  0F BF 05 CC CC CC CC          movsx eax, word ptr [CCCCCCCCH] ; $$DATA$$+12

#143			AND		16#3F00	{LNXT:43|44|-1}
(*) INT
08A64CEE  25 00 3F 00 00                and eax, 00003F00H

#144			SHR		16#08	{LNXT:43|44|-1}
(*) INT
08A64CF3  C1 E8 08                      shr eax, 8

#145			MUL		200	{LNXT:43|44|-1}
(*) DINT
08A64CF6  B9 C8 00 00 00                mov ecx, 200
08A64CFB  F7 E9                         imul ecx

#146			DIV		63	{LNXT:43|44|-1}
(*) DINT
08A64CFD  99                            cdq
08A64CFE  B9 3F 00 00 00                mov ecx, 63
08A64D03  F7 F9                         idiv ecx

#147			to_byte	{LNXT:43|44|-1}
(*) DINT
#148			ST		ATS22_DUT.EtaCurrent	{LNXT:43|44|-1}
(*) BYTE
08A64D05  88 05 CC CC CC CC             mov [CCCCCCCCH], al ; $$DATA$$+33

#149		
#150			(* ATS_Current_prsnt	 := ATS22_DUT.EtaCurrent; *)
#151			MOVE		ATS22_DUT.EtaCurrent,ATS_Current_prsnt	{LNXT:44|46|-1}
(*) BYTE
08A64D0B  33 C0                         xor eax, eax
08A64D0D  8A 05 CC CC CC CC             mov al, [CCCCCCCCH] ; $$DATA$$+33
08A64D13  66 89 05 CC CC CC CC          mov [CCCCCCCCH], ax ; %M110+18

#152		
#153			(* ATS22_DUT.Local 	:= to_bool(resp_eta_lcr[0] And 16#4000); *)
#154			LD		resp_eta_lcr[0]	{LNXT:46|47|-1}
(*) UNDEF
08A64D1A  0F BF 05 CC CC CC CC          movsx eax, word ptr [CCCCCCCCH] ; $$DATA$$+12

#155			AND		16#4000	{LNXT:46|47|-1}
(*) INT
08A64D21  25 00 40 00 00                and eax, 00004000H

#156			to_bool	{LNXT:46|47|-1}
(*) INT
08A64D26  66 85 C0                      test ax, ax
08A64D29  0F 95 C0                      setne al

#157			ST		ATS22_DUT.Local	{LNXT:46|47|-1}
(*) BOOL
08A64D2C  84 C0                         test al, al
08A64D2E  0F 95 05 CC CC CC CC          setne [CCCCCCCCH] ; $$DATA$$+34

#158		
#159			(* ATS22_DUT.Ramping 	:= to_bool(resp_eta_lcr[0] And 16#8000); *)
#160			LD		resp_eta_lcr[0]	{LNXT:47|49|-1}
(*) UNDEF
08A64D35  0F BF 05 CC CC CC CC          movsx eax, word ptr [CCCCCCCCH] ; $$DATA$$+12

#161			AND		16#8000	{LNXT:47|49|-1}
(*) INT
08A64D3C  25 00 80 00 00                and eax, 00008000H

#162			to_bool	{LNXT:47|49|-1}
(*) INT
08A64D41  66 85 C0                      test ax, ax
08A64D44  0F 95 C0                      setne al

#163			ST		ATS22_DUT.Ramping	{LNXT:47|49|-1}
(*) BOOL
08A64D47  84 C0                         test al, al
08A64D49  0F 95 05 CC CC CC CC          setne [CCCCCCCCH] ; $$DATA$$+35

#164		
#165			(* ATS22_DUT.Lcr1 := resp_eta_lcr[1]; *)
#166			MOVE		resp_eta_lcr[1],ATS22_DUT.Lcr1	{LNXT:49|50|-1}
(*) BOOL
08A64D50  0F BF 05 CC CC CC CC          movsx eax, word ptr [CCCCCCCCH] ; $$DATA$$+14
08A64D57  66 89 05 CC CC CC CC          mov [CCCCCCCCH], ax ; $$DATA$$+36

#167		
#168			(* ATS22_DUT.Lcr2 := resp_eta_lcr[2]; *)
#169			MOVE		resp_eta_lcr[2],ATS22_DUT.Lcr2	{LNXT:50|51|-1}
(*) INT
08A64D5E  0F BF 05 CC CC CC CC          movsx eax, word ptr [CCCCCCCCH] ; $$DATA$$+16
08A64D65  66 89 05 CC CC CC CC          mov [CCCCCCCCH], ax ; $$DATA$$+38

#170		
#171			(* ATS22_DUT.Lcr3 := resp_eta_lcr[3]; *)
#172			MOVE		resp_eta_lcr[3],ATS22_DUT.Lcr3	{LNXT:51|53|-1}
(*) INT
08A64D6C  0F BF 05 CC CC CC CC          movsx eax, word ptr [CCCCCCCCH] ; $$DATA$$+18
08A64D73  66 89 05 CC CC CC CC          mov [CCCCCCCCH], ax ; $$DATA$$+40

#173		
#174			(* ATS_Current_L1 := ATS22_DUT.Lcr1; *)
#175			MOVE		ATS22_DUT.Lcr1,ATS_Current_L1	{LNXT:53|54|-1}
(*) INT
08A64D7A  0F BF 05 CC CC CC CC          movsx eax, word ptr [CCCCCCCCH] ; $$DATA$$+36
08A64D81  66 89 05 CC CC CC CC          mov [CCCCCCCCH], ax ; %M110+20

#176		
#177			(* ATS_Current_L2 := ATS22_DUT.Lcr2; *)
#178			MOVE		ATS22_DUT.Lcr2,ATS_Current_L2	{LNXT:54|55|-1}
(*) INT
08A64D88  0F BF 05 CC CC CC CC          movsx eax, word ptr [CCCCCCCCH] ; $$DATA$$+38
08A64D8F  66 89 05 CC CC CC CC          mov [CCCCCCCCH], ax ; %M110+22

#179		
#180			(* ATS_Current_L3 := ATS22_DUT.Lcr3; *)
#181			MOVE		ATS22_DUT.Lcr3,ATS_Current_L3	{LNXT:55|57|-1}
(*) INT
08A64D96  0F BF 05 CC CC CC CC          movsx eax, word ptr [CCCCCCCCH] ; $$DATA$$+40
08A64D9D  66 89 05 CC CC CC CC          mov [CCCCCCCCH], ax ; %M110+24

#182		
#183			(* res := sysMbMRTU_FC03(	addr := 1, 
#184											base := 261, // 260
#185											no := 1, 
#186											object := ADR(resp_eta_lcr), 
#187											timeout := 200); *)
#188			ADR		resp_eta_lcr	{LNXT:57|63|-1}
(*) INT
08A64DA4  B8 CC CC CC CC                mov eax, CCCCCCCCH ; $$DATA$$+12

#189			ST		$$TMP0	{LNXT:57|63|-1}
(*) @INT
08A64DA9  89 05 CC CC CC CC             mov [CCCCCCCCH], eax ; $$DATA$$+20

#190			LDP0		1	{LNXT:57|63|-1}
(*) @INT
#191			sysMbMRTU_FC03		261, 1, $$TMP0, 200	{LNXT:57|63|-1}
(*) @INT
08A64DAF  68 C8 00 00 00                push 200
08A64DB4  FF 35 CC CC CC CC             push [CCCCCCCCH] ; $$DATA$$+20
08A64DBA  68 01 00 00 00                push 1
08A64DBF  68 05 01 00 00                push 261
08A64DC4  68 01 00 00 00                push 1
08A64DC9  B9 CC CC CC CC                mov ecx, CCCCCCCCH ; sysMbMRTU_FC03
08A64DCE  FF D1                         call ecx
08A64DD0  81 C4 14 00 00 00             add esp, 20

#192			ST		res	{LNXT:57|63|-1}
(*) UINT
08A64DD6  66 89 05 CC CC CC CC          mov [CCCCCCCCH], ax ; $$DATA$$+24

#193		
#194			(* ATS22_DUT.LcrVoltage	:= resp_eta_lcr[0]; *)
#195			MOVE		resp_eta_lcr[0],ATS22_DUT.LcrVoltage	{LNXT:63|64|-1}
(*) UINT
08A64DDD  0F BF 05 CC CC CC CC          movsx eax, word ptr [CCCCCCCCH] ; $$DATA$$+12
08A64DE4  66 89 05 CC CC CC CC          mov [CCCCCCCCH], ax ; $$DATA$$+42

#196		
#197			(* ATS_Voltage := ATS22_DUT.LcrVoltage; *)
#198			MOVE		ATS22_DUT.LcrVoltage,ATS_Voltage	{LNXT:64|68|-1}
(*) INT
08A64DEB  0F BF 05 CC CC CC CC          movsx eax, word ptr [CCCCCCCCH] ; $$DATA$$+42
08A64DF2  66 89 05 CC CC CC CC          mov [CCCCCCCCH], ax ; %M110+36

#199		
#200			(* res := sysMbMRTU_FC03(	addr := 1, 
#201											base := 280, // 279
#202											no := 1, 
#203											object := ADR(resp_eta_lcr), 
#204											timeout := 200); *)
#205			ADR		resp_eta_lcr	{LNXT:68|74|-1}
(*) INT
08A64DF9  B8 CC CC CC CC                mov eax, CCCCCCCCH ; $$DATA$$+12

#206			ST		$$TMP0	{LNXT:68|74|-1}
(*) @INT
08A64DFE  89 05 CC CC CC CC             mov [CCCCCCCCH], eax ; $$DATA$$+20

#207			LDP0		1	{LNXT:68|74|-1}
(*) @INT
#208			sysMbMRTU_FC03		280, 1, $$TMP0, 200	{LNXT:68|74|-1}
(*) @INT
08A64E04  68 C8 00 00 00                push 200
08A64E09  FF 35 CC CC CC CC             push [CCCCCCCCH] ; $$DATA$$+20
08A64E0F  68 01 00 00 00                push 1
08A64E14  68 18 01 00 00                push 280
08A64E19  68 01 00 00 00                push 1
08A64E1E  B9 CC CC CC CC                mov ecx, CCCCCCCCH ; sysMbMRTU_FC03
08A64E23  FF D1                         call ecx
08A64E25  81 C4 14 00 00 00             add esp, 20

#209			ST		res	{LNXT:68|74|-1}
(*) UINT
08A64E2B  66 89 05 CC CC CC CC          mov [CCCCCCCCH], ax ; $$DATA$$+24

#210		
#211			(* ATS22_DUT.LastFLT 	:= resp_eta_lcr[0]; *)
#212			MOVE		resp_eta_lcr[0],ATS22_DUT.LastFLT	{LNXT:74|75|-1}
(*) UINT
08A64E32  0F BF 05 CC CC CC CC          movsx eax, word ptr [CCCCCCCCH] ; $$DATA$$+12
08A64E39  66 89 05 CC CC CC CC          mov [CCCCCCCCH], ax ; $$DATA$$+44

#213		
#214			(* ATS_Last_FaultCode := ATS22_DUT.LastFLT; *)
#215			MOVE		ATS22_DUT.LastFLT,ATS_Last_FaultCode	{LNXT:75|78|-1}
(*) INT
08A64E40  0F BF 05 CC CC CC CC          movsx eax, word ptr [CCCCCCCCH] ; $$DATA$$+44
08A64E47  66 89 05 CC CC CC CC          mov [CCCCCCCCH], ax ; %M110+26

#216		
#217			(* res := sysMbMRTU_FC03(	addr := 1, 
#218											base := 274, // 273
#219											no := 3, 
#220											object := ADR(resp_eta_lcr), 
#221											timeout := 200); *)
#222			ADR		resp_eta_lcr	{LNXT:78|84|-1}
(*) INT
08A64E4E  B8 CC CC CC CC                mov eax, CCCCCCCCH ; $$DATA$$+12

#223			ST		$$TMP0	{LNXT:78|84|-1}
(*) @INT
08A64E53  89 05 CC CC CC CC             mov [CCCCCCCCH], eax ; $$DATA$$+20

#224			LDP0		1	{LNXT:78|84|-1}
(*) @INT
#225			sysMbMRTU_FC03		274, 3, $$TMP0, 200	{LNXT:78|84|-1}
(*) @INT
08A64E59  68 C8 00 00 00                push 200
08A64E5E  FF 35 CC CC CC CC             push [CCCCCCCCH] ; $$DATA$$+20
08A64E64  68 03 00 00 00                push 3
08A64E69  68 12 01 00 00                push 274
08A64E6E  68 01 00 00 00                push 1
08A64E73  B9 CC CC CC CC                mov ecx, CCCCCCCCH ; sysMbMRTU_FC03
08A64E78  FF D1                         call ecx
08A64E7A  81 C4 14 00 00 00             add esp, 20

#226			ST		res	{LNXT:78|84|-1}
(*) UINT
08A64E80  66 89 05 CC CC CC CC          mov [CCCCCCCCH], ax ; $$DATA$$+24

#227		
#228		
#229			(* IF res <> 0 *)
#230			LD		res	{LNXT:84|-1|-1}
(*) UNDEF
08A64E87  0F BF 05 CC CC CC CC          movsx eax, word ptr [CCCCCCCCH] ; $$DATA$$+24

#231			NE		0	{LNXT:84|-1|-1}
(*) INT
08A64E8E  3D 00 00 00 00                cmp eax, 0
08A64E93  0F 95 C0                      setne al
08A64E96  25 FF 00 00 00                and eax, 0FFh

#232			JMPCN	$label3	{LNXT:84|84|86}
(-) BOOL
08A64E9B  84 C0                         test al, al
08A64E9D  90 74 27 90 90 90             je 08A64EC7H

#233		
#234			(* THEN *)
#235		
#236				(* Alarms.6 := true; *)
#237				MOVE		true,Alarms.6	{LNXT:84|86|-1}
(*) BOOL
08A64EA3  B8 01 00 00 00                mov eax, 01H
08A64EA8  84 C0                         test al, al
08A64EAA  90 75 11 90 90 90             jne 00000014H@
08A64EB0  66 0F BA 35 CC CC CC CC 06    btr word ptr [CCCCCCCCH], 6 ; %M110+32
08A64EB9  EB 0C 90 90 90                jmp 0000000EH@
08A64EBE  66 0F BA 2D CC CC CC CC 06    bts word ptr [CCCCCCCCH], 6 ; %M110+32

#238		
#239		$label3:
#240			(* END_IF *)
#241		
#242			(* ATS22_DUT.MotRunTime 		:= resp_eta_lcr[0]; *)
#243			MOVE		resp_eta_lcr[0],ATS22_DUT.MotRunTime	{LNXT:86|87|-1}
(*) WORD
08A64EC7  0F BF 05 CC CC CC CC          movsx eax, word ptr [CCCCCCCCH] ; $$DATA$$+12
08A64ECE  66 89 05 CC CC CC CC          mov [CCCCCCCCH], ax ; $$DATA$$+46

#244		
#245			(* ATS22_DUT.MotStartCnt 		:= resp_eta_lcr[1]; *)
#246			MOVE		resp_eta_lcr[1],ATS22_DUT.MotStartCnt	{LNXT:87|88|-1}
(*) INT
08A64ED5  0F BF 05 CC CC CC CC          movsx eax, word ptr [CCCCCCCCH] ; $$DATA$$+14
08A64EDC  66 89 05 CC CC CC CC          mov [CCCCCCCCH], ax ; $$DATA$$+48

#247		
#248			(* ATS22_DUT.MotLastStartTime 	:= resp_eta_lcr[2]; *)
#249			MOVE		resp_eta_lcr[2],ATS22_DUT.MotLastStartTime	{LNXT:88|90|-1}
(*) INT
08A64EE3  0F BF 05 CC CC CC CC          movsx eax, word ptr [CCCCCCCCH] ; $$DATA$$+16
08A64EEA  66 89 05 CC CC CC CC          mov [CCCCCCCCH], ax ; $$DATA$$+50

#250		
#251			(* ATS_RunTime_Hors	:= to_word(ATS22_DUT.MotRunTime); *)
#252			LDP0		ATS22_DUT.MotRunTime	{LNXT:90|91|-1}
(*) INT
#253			to_word	{LNXT:90|91|-1}
(*) INT
08A64EF1  0F BF 05 CC CC CC CC          movsx eax, word ptr [CCCCCCCCH] ; $$DATA$$+46

#254			ST		ATS_RunTime_Hors	{LNXT:90|91|-1}
(*) WORD
08A64EF8  66 89 05 CC CC CC CC          mov [CCCCCCCCH], ax ; %M110+28

#255		
#256			(* ATS_OnTimes_Cnt		:= to_word(ATS22_DUT.MotStartCnt); *)
#257			LDP0		ATS22_DUT.MotStartCnt	{LNXT:91|2|-1}
(*) WORD
#258			to_word	{LNXT:91|2|-1}
(*) WORD
08A64EFF  0F BF 05 CC CC CC CC          movsx eax, word ptr [CCCCCCCCH] ; $$DATA$$+48

#259			ST		ATS_OnTimes_Cnt	{LNXT:91|2|-1}
(*) WORD
08A64F06  66 89 05 CC CC CC CC          mov [CCCCCCCCH], ax ; %M110+30

08A64F0D  61                            popad
08A64F0E  5D                            pop ebp

08A64F0F  C3                            ret

END_PROGRAM


**************************************************
	Target variable image generation
**************************************************


*** INPUT:
08A64F10  55                            push ebp
08A64F11  8B EC                         mov ebp, esp

08A64F13  8A 0D CC CC CC CC             mov cl, [CCCCCCCCH] ; %I0+7
08A64F19  88 0D CC CC CC CC             mov [CCCCCCCCH], cl ; $$DATA$$+52

08A64F1F  8A 0D CC CC CC CC             mov cl, [CCCCCCCCH] ; %I0+6
08A64F25  88 0D CC CC CC CC             mov [CCCCCCCCH], cl ; $$DATA$$+53

08A64F2B  66 8B 0D CC CC CC CC          mov cx, [CCCCCCCCH] ; %I1+12
08A64F32  66 89 0D CC CC CC CC          mov [CCCCCCCCH], cx ; $$DATA$$+54

08A64F39  66 8B 0D CC CC CC CC          mov cx, [CCCCCCCCH] ; %I1+14
08A64F40  66 89 0D CC CC CC CC          mov [CCCCCCCCH], cx ; $$DATA$$+56

08A64F47  8B E5                         mov esp, ebp
08A64F49  5D                            pop ebp

08A64F4A  C3                            ret


*** OUTPUT:
08A64F4B  55                            push ebp
08A64F4C  8B EC                         mov ebp, esp

08A64F4E  8B E5                         mov esp, ebp
08A64F50  5D                            pop ebp

08A64F51  C3                            ret



**************************************************
	Task Background init code
**************************************************

08A64F52  55                            push ebp
08A64F53  8B EC                         mov ebp, esp

08A64F55  8B E5                         mov esp, ebp
08A64F57  5D                            pop ebp

08A64F58  C3                            ret

**************************************************
	List program: sr_init_counters
**************************************************

PROGRAM sr_init_counters

END_PROGRAM

08A64F70  55                            push ebp
08A64F71  8B EC                         mov ebp, esp
08A64F73  60                            pushad

#0		{SRC:sr_init_counters}
#1		(*$WAITSWITCH$*)
#2		
#3			(* kw_counter 	:= epprom_kw_cnt; *)
#4			MOVE		epprom_kw_cnt,kw_counter	{LNXT:1|2|-1}
(*) UDINT
08A64F74  8B 05 CC CC CC CC             mov eax, [CCCCCCCCH] ; %M101+8
08A64F7A  89 05 CC CC CC CC             mov [CCCCCCCCH], eax ; %M110+4

#5		
#6			(* q_counter	:= epprom_q_cnt; *)
#7			MOVE		epprom_q_cnt,q_counter	{LNXT:2|1|-1}
(*) DWORD
08A64F80  8B 05 CC CC CC CC             mov eax, [CCCCCCCCH] ; %M101+0
08A64F86  89 05 CC CC CC CC             mov [CCCCCCCCH], eax ; %M110+8

08A64F8C  61                            popad
08A64F8D  5D                            pop ebp

08A64F8E  C3                            ret

END_PROGRAM


**************************************************
	Target variable image generation
**************************************************


*** INPUT:
08A64F8F  C3                            ret


*** OUTPUT:
08A64F90  C3                            ret



**************************************************
	Task Boot init code
**************************************************

08A64F91  55                            push ebp
08A64F92  8B EC                         mov ebp, esp

08A64F94  8B E5                         mov esp, ebp
08A64F96  5D                            pop ebp

08A64F97  C3                            ret

**************************************************
	List program: init_val
**************************************************

PROGRAM init_val

END_PROGRAM

08A64FB0  55                            push ebp
08A64FB1  8B EC                         mov ebp, esp
08A64FB3  60                            pushad

#0		{SRC:init_val}
#1		(*$WAITSWITCH$*)
#2		
#3		
#4			(* IF di_val_close_state_R *)
#5			LD		di_val_close_state_R	{LNXT:1|-1|-1}
(*) UNDEF
08A64FB4  33 C0                         xor eax, eax
08A64FB6  8A 05 CC CC CC CC             mov al, [CCCCCCCCH] ; %I0+0

#6			NOT	{LNXT:1|-1|-1}
(*) BOOL
08A64FBC  84 C0                         test al, al
08A64FBE  0F 94 C0                      sete al

#7			JMPCN	$label0	{LNXT:1|2|6}
(-) BOOL
08A64FC1  84 C0                         test al, al
08A64FC3  90 74 1F 90 90 90             je 08A64FE5H

#8		
#9			(* THEN *)
#10		
#11				(* o_val_close_R:=true; *)
#12				MOVE		true,o_val_close_R	{LNXT:2|3|-1}
(*) BOOL
08A64FC9  B8 01 00 00 00                mov eax, 01H
08A64FCE  84 C0                         test al, al
08A64FD0  0F 95 05 CC CC CC CC          setne [CCCCCCCCH] ; %Q1+3

#13		
#14				(* o_val_open_R:=false; *)
#15				MOVE		false,o_val_open_R	{LNXT:3|6|-1}
(*) BOOL
08A64FD7  B8 00 00 00 00                mov eax, 00H
08A64FDC  84 C0                         test al, al
08A64FDE  0F 95 05 CC CC CC CC          setne [CCCCCCCCH] ; %Q1+2

#16		
#17		$label0:
#18			(* END_IF *)
#19		
#20		
#21			(* IF di_val_close_state_fall = 0 *)
#22			LD		di_val_close_state_fall	{LNXT:6|-1|-1}
(*) UNDEF
08A64FE5  0F BF 05 CC CC CC CC          movsx eax, word ptr [CCCCCCCCH] ; %I1+8

#23			EQ		0	{LNXT:6|-1|-1}
(*) INT
08A64FEC  3D 00 00 00 00                cmp eax, 0
08A64FF1  0F 94 C0                      sete al
08A64FF4  25 FF 00 00 00                and eax, 0FFh

#24			JMPCN	$label1	{LNXT:6|7|1}
(-) BOOL
08A64FF9  84 C0                         test al, al
08A64FFB  90 74 1F 90 90 90             je 08A6501DH

#25		
#26			(* THEN *)
#27		
#28				(* o_val_close_fall:=true; *)
#29				MOVE		true,o_val_close_fall	{LNXT:7|8|-1}
(*) BOOL
08A65001  B8 01 00 00 00                mov eax, 01H
08A65006  84 C0                         test al, al
08A65008  0F 95 05 CC CC CC CC          setne [CCCCCCCCH] ; %Q1+1

#30		
#31				(* o_val_open_fall:=false; *)
#32				MOVE		false,o_val_open_fall	{LNXT:8|1|-1}
(*) BOOL
08A6500F  B8 00 00 00 00                mov eax, 00H
08A65014  84 C0                         test al, al
08A65016  0F 95 05 CC CC CC CC          setne [CCCCCCCCH] ; %Q1+0

08A6501D  61                            popad
08A6501E  5D                            pop ebp

08A6501F  C3                            ret

END_PROGRAM


**************************************************
	Target variable image generation
**************************************************


*** INPUT:
08A65020  C3                            ret


*** OUTPUT:
08A65021  C3                            ret



**************************************************
	Task Init init code
**************************************************

08A65022  55                            push ebp
08A65023  8B EC                         mov ebp, esp

08A65025  8B E5                         mov esp, ebp
08A65027  5D                            pop ebp

08A65028  C3                            ret

**************************************************
	List program: InitParDB
**************************************************

PROGRAM InitParDB

        VAR
warningsKiller : USINT;
dummyCrc32 : UDINT;
	END_VAR

END_PROGRAM

08A65040  55                            push ebp
08A65041  8B EC                         mov ebp, esp
08A65043  60                            pushad

#0		{SRC:InitParDB}
#1		(*$WAITSWITCH$*)
#2		
#3			(* dummyCrc32 := 541599759; *)
#4			MOVE		541599759,dummyCrc32	{LNXT:3|5|-1}
(*) UDINT
08A65044  B8 0F 28 48 20                mov eax, 2048280FH
08A65049  89 05 CC CC CC CC             mov [CCCCCCCCH], eax ; $$DATA$$+60

#5		
#6			(* warningsKiller := sysDBase_SetExtTable( ADR( $$ParDB ), $$ParDBLength ); *)
#7			ADR		$$ParDB	{LNXT:5|3|-1}
(*) UDINT
08A6504F  B8 CC CC CC CC                mov eax, CCCCCCCCH ; $$CODE$$+336

#8			sysDBase_SetExtTable		$$ParDBLength	{LNXT:5|3|-1}
(*) @USINT
08A65054  68 16 00 00 00                push 22
08A65059  8B C8                         mov ecx, eax
08A6505B  51                            push ecx
08A6505C  B9 CC CC CC CC                mov ecx, CCCCCCCCH ; sysDBase_SetExtTable
08A65061  FF D1                         call ecx
08A65063  81 C4 08 00 00 00             add esp, 8

#9			ST		warningsKiller	{LNXT:5|3|-1}
(*) USINT
08A65069  88 05 CC CC CC CC             mov [CCCCCCCCH], al ; $$DATA$$+59

08A6506F  61                            popad
08A65070  5D                            pop ebp

08A65071  C3                            ret

END_PROGRAM


**************************************************
	Target variable image generation
**************************************************


*** INPUT:
08A65072  C3                            ret


*** OUTPUT:
08A65073  C3                            ret



**************************************************
	Task Serv init code
**************************************************

08A65074  55                            push ebp
08A65075  8B EC                         mov ebp, esp

08A65077  8B E5                         mov esp, ebp
08A65079  5D                            pop ebp

08A6507A  C3                            ret

**************************************************
	List program: sr_pressure
**************************************************

PROGRAM sr_pressure

        VAR
tmp_test : INT;
	END_VAR

END_PROGRAM

08A65090  55                            push ebp
08A65091  8B EC                         mov ebp, esp
08A65093  60                            pushad

#0		{SRC:sr_pressure}
#1		(*$WAITSWITCH$*)
#2		
#3			(* Pressure := to_int(to_real(i_adc_pressure )/10); *)
#4			LDP0		i_adc_pressure	{LNXT:2|2|-1}
(*) UDINT
#5			to_real	{LNXT:2|2|-1}
(*) UDINT
08A65094  0F BF 05 CC CC CC CC          movsx eax, word ptr [CCCCCCCCH] ; $$DATA$$+246
08A6509B  50                            push eax
08A6509C  DB 04 24                      fild dword ptr [esp]
08A6509F  58                            pop eax

#6			DIV		10	{LNXT:2|2|-1}
(*) REAL
08A650A0  68 0A 00 00 00                push 10
08A650A5  DA 34 24                      fidiv [esp]
08A650A8  81 C4 04 00 00 00             add esp, 4

#7			to_int	{LNXT:2|2|-1}
(*) REAL
08A650AE  81 EC 08 00 00 00             sub esp, 8
08A650B4  DF 3C 24                      fistp qword ptr [esp]
08A650B7  58                            pop eax
08A650B8  81 C4 04 00 00 00             add esp, 4

#8			ST		Pressure	{LNXT:2|2|-1}
(*) INT
08A650BE  66 89 05 CC CC CC CC          mov [CCCCCCCCH], ax ; %M110+0

END_PROGRAM
**************************************************
	List program: sr_counters
**************************************************

PROGRAM sr_counters

        VAR
kw_trig : R_TRIG;
q_trig : R_TRIG;
kw_pulses_per_acs : UINT;
q_pulses_per_acs : UINT;
test_freq : UDINT;
	END_VAR

END_PROGRAM

#0		{SRC:sr_counters}
#1		(*$WAITSWITCH$*)
#2		
#3			(* kw_pulses_per_acs 	:= 8000; *)
#4			MOVE		8000,kw_pulses_per_acs	{LNXT:2|3|-1}
(*) UDINT
08A650C5  B8 40 1F 00 00                mov eax, 1F40H
08A650CA  66 89 05 CC CC CC CC          mov [CCCCCCCCH], ax ; $$DATA$$+242

#5		
#6			(* q_pulses_per_acs	:= 1; *)
#7			MOVE		1,q_pulses_per_acs	{LNXT:3|15|-1}
(*) UINT
08A650D1  B8 01 00 00 00                mov eax, 01H
08A650D6  66 89 05 CC CC CC CC          mov [CCCCCCCCH], ax ; $$DATA$$+244

#8		
#9		
#10			(* IF fdi_q_cnt >= q_pulses_per_acs *)
#11			LD		fdi_q_cnt	{LNXT:15|-1|-1}
(*) UNDEF
08A650DD  8B 05 CC CC CC CC             mov eax, [CCCCCCCCH] ; %M500+0

#12			GE		q_pulses_per_acs	{LNXT:15|-1|-1}
(*) UDINT
08A650E3  33 C9                         xor ecx, ecx
08A650E5  66 8B 0D CC CC CC CC          mov cx, [CCCCCCCCH] ; $$DATA$$+244
08A650EC  3B C1                         cmp eax, ecx
08A650EE  0F 93 C0                      setae al
08A650F1  25 FF 00 00 00                and eax, 0FFh

#13			JMPCN	$label0	{LNXT:15|16|20}
(-) BOOL
08A650F6  84 C0                         test al, al
08A650F8  90 74 22 90 90 90             je 08A6511DH

#14		
#15			(* THEN *)
#16		
#17				(* q_counter := q_counter + 1; *)
#18				LD		q_counter	{LNXT:16|17|-1}
(*) UNDEF
08A650FE  8B 05 CC CC CC CC             mov eax, [CCCCCCCCH] ; %M110+8

#19				ADD		1	{LNXT:16|17|-1}
(*) DWORD
08A65104  05 01 00 00 00                add eax, 1

#20				ST		q_counter	{LNXT:16|17|-1}
(*) DWORD
08A65109  89 05 CC CC CC CC             mov [CCCCCCCCH], eax ; %M110+8

#21		
#22				(* fdi_q_reset := true; *)
#23				MOVE		true,fdi_q_reset	{LNXT:17|20|-1}
(*) DWORD
08A6510F  B8 01 00 00 00                mov eax, 01H
08A65114  84 C0                         test al, al
08A65116  0F 95 05 CC CC CC CC          setne [CCCCCCCCH] ; %M550+0

#24		
#25		$label0:
#26			(* END_IF *)
#27		
#28			(* q_value := to_int((3600 * to_real(fdi_q_freq)) / (to_real(q_pulses_per_acs) / 1)); *)
#29			LDP0		fdi_q_freq	{LNXT:20|2|-1}
(*) BOOL
#30			to_real	{LNXT:20|2|-1}
(*) BOOL
08A6511D  8B 05 CC CC CC CC             mov eax, [CCCCCCCCH] ; %M500+4
08A65123  68 00 00 00 00                push 0
08A65128  50                            push eax
08A65129  DF 2C 24                      fild qword ptr [esp]
08A6512C  81 C4 08 00 00 00             add esp, 8

#31			MUL		3600	{LNXT:20|2|-1}
(*) REAL
08A65132  68 10 0E 00 00                push 3600
08A65137  DA 0C 24                      fimul [esp]
08A6513A  81 C4 04 00 00 00             add esp, 4

#32			DIV(		0	{LNXT:20|2|-1}
(*) REAL
08A65140  81 EC 04 00 00 00             sub esp, 4
08A65146  D9 1C 24                      fstp dword ptr [esp]
08A65149  B8 00 00 00 00                mov eax, 00H

#33			LDP0		q_pulses_per_acs	{LNXT:20|2|-1}
(*) USINT
#34			to_real	{LNXT:20|2|-1}
(*) USINT
08A6514E  33 C0                         xor eax, eax
08A65150  66 8B 05 CC CC CC CC          mov ax, [CCCCCCCCH] ; $$DATA$$+244
08A65157  68 00 00 00 00                push 0
08A6515C  50                            push eax
08A6515D  DF 2C 24                      fild qword ptr [esp]
08A65160  81 C4 08 00 00 00             add esp, 8

#35			DIV		1	{LNXT:20|2|-1}
(*) REAL
08A65166  68 01 00 00 00                push 1
08A6516B  DA 34 24                      fidiv [esp]
08A6516E  81 C4 04 00 00 00             add esp, 4

#36			)	{LNXT:20|2|-1}
(*) REAL
08A65174  81 EC 04 00 00 00             sub esp, 4
08A6517A  D9 1C 24                      fstp dword ptr [esp]
08A6517D  D9 44 24 04                   fld dword ptr 4[esp]
08A65181  D8 34 24                      fdiv dword ptr [esp]
08A65184  81 C4 08 00 00 00             add esp, 8

#37			to_int	{LNXT:20|2|-1}
(*) REAL
08A6518A  81 EC 08 00 00 00             sub esp, 8
08A65190  DF 3C 24                      fistp qword ptr [esp]
08A65193  58                            pop eax
08A65194  81 C4 04 00 00 00             add esp, 4

#38			ST		q_value	{LNXT:20|2|-1}
(*) INT
08A6519A  66 89 05 CC CC CC CC          mov [CCCCCCCCH], ax ; %M110+14

END_PROGRAM
**************************************************
	List program: sr_save_counters
**************************************************

PROGRAM sr_save_counters

        VAR
power_err : R_TRIG;
ton_start_up : TON;
res_q : BOOL;
res_kw : BOOL;
	END_VAR

END_PROGRAM

#0		{SRC:sr_save_counters}
#1		(*$WAITSWITCH$*)
#2		
#3			(* ton_start_up *)
#4			MOVE		true,ton_start_up.IN	{LNXT:1|-1|-1}
(*) UDINT
08A651A1  B8 01 00 00 00                mov eax, 01H
08A651A6  84 C0                         test al, al
08A651A8  0F 95 05 CC CC CC CC          setne [CCCCCCCCH] ; $$DATA$$+252

#5			MOVE		5000,ton_start_up.PT	{LNXT:1|-1|-1}
(*) BOOL
08A651AF  B8 88 13 00 00                mov eax, 1388H
08A651B4  89 05 CC CC CC CC             mov [CCCCCCCCH], eax ; $$DATA$$+253

#6			CAL		ton_start_up	{LNXT:1|2|-1}
(*) UDINT
08A651BA  50                            push eax
08A651BB  BB CC CC CC CC                mov ebx, CCCCCCCCH ; $$DATA$$+248
08A651C0  E8 F4 F2 FF FF                call 08A644B9H ; $$CODE$$+17593
08A651C5  58                            pop eax

#7		
#8			(* power_err *)
#9			LD		ton_start_up.Q	{LNXT:2|-1|-1}
(*) UNDEF
08A651C6  33 C0                         xor eax, eax
08A651C8  8A 05 CC CC CC CC             mov al, [CCCCCCCCH] ; $$DATA$$+257

#10			AND		i_rnpp	{LNXT:2|-1|-1}
(*) BOOL
08A651CE  33 C9                         xor ecx, ecx
08A651D0  8A 0D CC CC CC CC             mov cl, [CCCCCCCCH] ; $$DATA$$+240
08A651D6  23 C1                         and eax, ecx

#11			ST		power_err.clk	{LNXT:2|-1|-1}
(*) BOOL
08A651D8  84 C0                         test al, al
08A651DA  0F 95 05 CC CC CC CC          setne [CCCCCCCCH] ; $$DATA$$+271

#12			CAL		power_err	{LNXT:2|3|-1}
(*) BOOL
08A651E1  50                            push eax
08A651E2  BB CC CC CC CC                mov ebx, CCCCCCCCH ; $$DATA$$+270
08A651E7  E8 A4 F2 FF FF                call 08A64490H ; $$CODE$$+17552
08A651EC  58                            pop eax

#13		
#14		
#15			(* IF power_err.q *)
#16			LD		power_err.q	{LNXT:3|-1|-1}
(*) UNDEF
08A651ED  33 C0                         xor eax, eax
08A651EF  8A 05 CC CC CC CC             mov al, [CCCCCCCCH] ; $$DATA$$+272

#17			JMPCN	$label0	{LNXT:3|4|1}
(-) BOOL
08A651F5  84 C0                         test al, al
08A651F7  0F 84 82 00 00 00             je 08A6527FH

#18		
#19			(* THEN *)
#20		
#21		
#22				(* IF epprom_q_cnt <> q_counter *)
#23				LD		epprom_q_cnt	{LNXT:4|-1|-1}
(*) UNDEF
08A651FD  8B 05 CC CC CC CC             mov eax, [CCCCCCCCH] ; %M101+0

#24				NE		q_counter	{LNXT:4|-1|-1}
(*) DWORD
08A65203  3B 05 CC CC CC CC             cmp eax, [CCCCCCCCH] ; %M110+8
08A65209  0F 95 C0                      setne al
08A6520C  25 FF 00 00 00                and eax, 0FFh

#25				JMPCN	$label1	{LNXT:4|4|5}
(-) BOOL
08A65211  84 C0                         test al, al
08A65213  90 74 28 90 90 90             je 08A6523EH

#26		
#27				(* THEN *)
#28		
#29					(* res_q := sysWriteParUINT(ADR(epprom_q_cnt), q_counter); *)
#30					ADR		epprom_q_cnt	{LNXT:4|5|-1}
(*) BOOL
08A65219  B8 CC CC CC CC                mov eax, CCCCCCCCH ; %M101+0

#31					sysWriteParUINT		q_counter	{LNXT:4|5|-1}
(*) @DWORD
08A6521E  8B 0D CC CC CC CC             mov ecx, [CCCCCCCCH] ; %M110+8
08A65224  51                            push ecx
08A65225  8B C8                         mov ecx, eax
08A65227  51                            push ecx
08A65228  B9 CC CC CC CC                mov ecx, CCCCCCCCH ; sysWriteParUINT
08A6522D  FF D1                         call ecx
08A6522F  81 C4 08 00 00 00             add esp, 8

#32					ST		res_q	{LNXT:4|5|-1}
(*) BOOL
08A65235  84 C0                         test al, al
08A65237  0F 95 05 CC CC CC CC          setne [CCCCCCCCH] ; $$DATA$$+281

#33		
#34		$label1:
#35				(* END_IF *)
#36		
#37		
#38				(* IF epprom_kw_cnt <> kw_counter *)
#39				LD		epprom_kw_cnt	{LNXT:5|-1|-1}
(*) UNDEF
08A6523E  8B 05 CC CC CC CC             mov eax, [CCCCCCCCH] ; %M101+8

#40				NE		kw_counter	{LNXT:5|-1|-1}
(*) DWORD
08A65244  3B 05 CC CC CC CC             cmp eax, [CCCCCCCCH] ; %M110+4
08A6524A  0F 95 C0                      setne al
08A6524D  25 FF 00 00 00                and eax, 0FFh

#41				JMPCN	$label2	{LNXT:5|5|1}
(-) BOOL
08A65252  84 C0                         test al, al
08A65254  90 74 28 90 90 90             je 08A6527FH

#42		
#43				(* THEN *)
#44		
#45					(* res_kw := sysWriteParUINT(ADR(epprom_kw_cnt), kw_counter); *)
#46					ADR		epprom_kw_cnt	{LNXT:5|1|-1}
(*) BOOL
08A6525A  B8 CC CC CC CC                mov eax, CCCCCCCCH ; %M101+8

#47					sysWriteParUINT		kw_counter	{LNXT:5|1|-1}
(*) @DWORD
08A6525F  8B 0D CC CC CC CC             mov ecx, [CCCCCCCCH] ; %M110+4
08A65265  51                            push ecx
08A65266  8B C8                         mov ecx, eax
08A65268  51                            push ecx
08A65269  B9 CC CC CC CC                mov ecx, CCCCCCCCH ; sysWriteParUINT
08A6526E  FF D1                         call ecx
08A65270  81 C4 08 00 00 00             add esp, 8

#48					ST		res_kw	{LNXT:5|1|-1}
(*) BOOL
08A65276  84 C0                         test al, al
08A65278  0F 95 05 CC CC CC CC          setne [CCCCCCCCH] ; $$DATA$$+282

END_PROGRAM
**************************************************
	List program: sr_ATS_Ctrl
**************************************************

PROGRAM sr_ATS_Ctrl

        VAR
TON_StartUp_1 : TON;
TON_StartUp_2 : TON;
stopping_timer : TON;
downtimeIN : BOOL;
washing_timer : TON;
checkWashAndStart : CheckWashAndStart;
isRunningWash : BOOL;
onWash : BOOL := false;
time_sec : INT := 4000;
	END_VAR

END_PROGRAM

#0		{SRC:sr_ATS_Ctrl}
#1		(*$WAITSWITCH$*)
#2		
#3		
#4			(* IF i_pb_rem = 1 And
#5		Not Alarms.0 And 
#6		Not Alarms.3 And 
#7		Not Alarms.4 And 
#8		Not Alarms.5 And 
#9		Not Alarms.7 *)
#10			LD		Alarms.7	{LNXT:2|-1|-1}
(*) UNDEF
08A6527F  33 C0                         xor eax, eax
08A65281  66 8B 05 CC CC CC CC          mov ax, [CCCCCCCCH] ; %M110+32
08A65288  C1 E8 07                      shr eax, 7
08A6528B  25 01 00 00 00                and eax, 1

#11			NOT	{LNXT:2|-1|-1}
(*) BOOL
08A65290  84 C0                         test al, al
08A65292  0F 94 C0                      sete al

#12			AND(		Alarms.5	{LNXT:2|-1|-1}
(*) BOOL
08A65295  50                            push eax
08A65296  33 C0                         xor eax, eax
08A65298  66 8B 05 CC CC CC CC          mov ax, [CCCCCCCCH] ; %M110+32
08A6529F  C1 E8 05                      shr eax, 5
08A652A2  25 01 00 00 00                and eax, 1

#13			NOT	{LNXT:2|-1|-1}
(*) BOOL
08A652A7  84 C0                         test al, al
08A652A9  0F 94 C0                      sete al

#14			AND(		Alarms.4	{LNXT:2|-1|-1}
(*) BOOL
08A652AC  50                            push eax
08A652AD  33 C0                         xor eax, eax
08A652AF  66 8B 05 CC CC CC CC          mov ax, [CCCCCCCCH] ; %M110+32
08A652B6  C1 E8 04                      shr eax, 4
08A652B9  25 01 00 00 00                and eax, 1

#15			NOT	{LNXT:2|-1|-1}
(*) BOOL
08A652BE  84 C0                         test al, al
08A652C0  0F 94 C0                      sete al

#16			AND(		Alarms.3	{LNXT:2|-1|-1}
(*) BOOL
08A652C3  50                            push eax
08A652C4  33 C0                         xor eax, eax
08A652C6  66 8B 05 CC CC CC CC          mov ax, [CCCCCCCCH] ; %M110+32
08A652CD  C1 E8 03                      shr eax, 3
08A652D0  25 01 00 00 00                and eax, 1

#17			NOT	{LNXT:2|-1|-1}
(*) BOOL
08A652D5  84 C0                         test al, al
08A652D7  0F 94 C0                      sete al

#18			AND(		Alarms.0	{LNXT:2|-1|-1}
(*) BOOL
08A652DA  50                            push eax
08A652DB  33 C0                         xor eax, eax
08A652DD  66 8B 05 CC CC CC CC          mov ax, [CCCCCCCCH] ; %M110+32
08A652E4  25 01 00 00 00                and eax, 1

#19			NOT	{LNXT:2|-1|-1}
(*) BOOL
08A652E9  84 C0                         test al, al
08A652EB  0F 94 C0                      sete al

#20			AND(		i_pb_rem	{LNXT:2|-1|-1}
(*) BOOL
08A652EE  50                            push eax
08A652EF  0F BF 05 CC CC CC CC          movsx eax, word ptr [CCCCCCCCH] ; $$DATA$$+64

#21			EQ		1	{LNXT:2|-1|-1}
(*) INT
08A652F6  3D 01 00 00 00                cmp eax, 1
08A652FB  0F 94 C0                      sete al
08A652FE  25 FF 00 00 00                and eax, 0FFh

#22			)	{LNXT:2|-1|-1}
(*) BOOL
08A65303  8B C8                         mov ecx, eax
08A65305  58                            pop eax
08A65306  23 C1                         and eax, ecx

#23			)	{LNXT:2|-1|-1}
(*) BOOL
08A65308  8B C8                         mov ecx, eax
08A6530A  58                            pop eax
08A6530B  23 C1                         and eax, ecx

#24			)	{LNXT:2|-1|-1}
(*) BOOL
08A6530D  8B C8                         mov ecx, eax
08A6530F  58                            pop eax
08A65310  23 C1                         and eax, ecx

#25			)	{LNXT:2|-1|-1}
(*) BOOL
08A65312  8B C8                         mov ecx, eax
08A65314  58                            pop eax
08A65315  23 C1                         and eax, ecx

#26			)	{LNXT:2|-1|-1}
(*) BOOL
08A65317  8B C8                         mov ecx, eax
08A65319  58                            pop eax
08A6531A  23 C1                         and eax, ecx

#27			JMPCN	$label0	{LNXT:2|9|30}
(-) BOOL
08A6531C  84 C0                         test al, al
08A6531E  0F 84 C9 00 00 00             je 08A653EDH

#28		
#29			(* THEN *)
#30		
#31		
#32				(* IF CMD.0 *)
#33				LD		CMD.0	{LNXT:9|-1|-1}
(*) UNDEF
08A65324  33 C0                         xor eax, eax
08A65326  66 8B 05 CC CC CC CC          mov ax, [CCCCCCCCH] ; %M110+34
08A6532D  25 01 00 00 00                and eax, 1

#34				JMPCN	$label2	{LNXT:9|10|26}
(-) BOOL
08A65332  84 C0                         test al, al
08A65334  0F 84 A0 00 00 00             je 08A653DAH

#35		
#36				(* THEN *)
#37		
#38					(* checkWashAndStart *)
#39					MOVE		o_val_close_fall,checkWashAndStart.o_val_close_fall_FB	{LNXT:10|-1|-1}
(*) BOOL
08A6533A  B8 CC CC CC CC                mov eax, CCCCCCCCH ; %Q1+1
08A6533F  89 05 CC CC CC CC             mov [CCCCCCCCH], eax ; $$DATA$$+184

#40					MOVE		o_val_close_R,checkWashAndStart.o_val_close_R_FB	{LNXT:11|-1|-1}
(*) BOOL^
08A65345  B8 CC CC CC CC                mov eax, CCCCCCCCH ; %Q1+3
08A6534A  89 05 CC CC CC CC             mov [CCCCCCCCH], eax ; $$DATA$$+176

#41					MOVE		o_val_open_fall,checkWashAndStart.o_val_open_fall_FB	{LNXT:12|-1|-1}
(*) BOOL^
08A65350  B8 CC CC CC CC                mov eax, CCCCCCCCH ; %Q1+0
08A65355  89 05 CC CC CC CC             mov [CCCCCCCCH], eax ; $$DATA$$+180

#42					MOVE		o_val_open_R,checkWashAndStart.o_val_open_R_FB	{LNXT:13|-1|-1}
(*) BOOL^
08A6535B  B8 CC CC CC CC                mov eax, CCCCCCCCH ; %Q1+2
08A65360  89 05 CC CC CC CC             mov [CCCCCCCCH], eax ; $$DATA$$+172

#43					MOVE		sv_washing,checkWashAndStart.sv_washing_FB	{LNXT:14|-1|-1}
(*) BOOL^
08A65366  B8 CC CC CC CC                mov eax, CCCCCCCCH ; %M110+38
08A6536B  89 05 CC CC CC CC             mov [CCCCCCCCH], eax ; $$DATA$$+168

#44					MOVE		q_start_ats,checkWashAndStart.q_start_ats_FB	{LNXT:15|-1|-1}
(*) BOOL^
08A65371  B8 CC CC CC CC                mov eax, CCCCCCCCH ; %Q1+7
08A65376  89 05 CC CC CC CC             mov [CCCCCCCCH], eax ; $$DATA$$+188

#45					MOVE		time_sec,checkWashAndStart.ep_time_wash_FB	{LNXT:16|-1|-1}
(*) BOOL^
08A6537C  B8 CC CC CC CC                mov eax, CCCCCCCCH ; $$DATA$$+228
08A65381  89 05 CC CC CC CC             mov [CCCCCCCCH], eax ; $$DATA$$+192

#46					MOVE		i_val_state,checkWashAndStart.i_val_state_FB	{LNXT:17|-1|-1}
(*) INT^
08A65387  B8 CC CC CC CC                mov eax, CCCCCCCCH ; $$DATA$$+230
08A6538C  89 05 CC CC CC CC             mov [CCCCCCCCH], eax ; $$DATA$$+196

#47					MOVE		di_val_open_state_fall,checkWashAndStart.di_val_open_state_fall_FB	{LNXT:18|-1|-1}
(*) INT^
08A65392  B8 CC CC CC CC                mov eax, CCCCCCCCH ; $$DATA$$+232
08A65397  89 05 CC CC CC CC             mov [CCCCCCCCH], eax ; $$DATA$$+200

#48					MOVE		di_val_close_state_fall,checkWashAndStart.di_val_close_state_fall_FB	{LNXT:19|-1|-1}
(*) INT^
08A6539D  B8 CC CC CC CC                mov eax, CCCCCCCCH ; $$DATA$$+234
08A653A2  89 05 CC CC CC CC             mov [CCCCCCCCH], eax ; $$DATA$$+204

#49					MOVE		di_val_open_state_R,checkWashAndStart.di_val_open_state_R_FB	{LNXT:20|-1|-1}
(*) INT^
08A653A8  B8 CC CC CC CC                mov eax, CCCCCCCCH ; $$DATA$$+236
08A653AD  89 05 CC CC CC CC             mov [CCCCCCCCH], eax ; $$DATA$$+208

#50					MOVE		di_val_close_state_R,checkWashAndStart.di_val_close_state_R_FB	{LNXT:21|-1|-1}
(*) INT^
08A653B3  B8 CC CC CC CC                mov eax, CCCCCCCCH ; $$DATA$$+58
08A653B8  89 05 CC CC CC CC             mov [CCCCCCCCH], eax ; $$DATA$$+212

#51					MOVE		Alarms_Val,checkWashAndStart.Alarm_Val_FB	{LNXT:22|-1|-1}
(*) BOOL^
08A653BE  B8 CC CC CC CC                mov eax, CCCCCCCCH ; %M110+40
08A653C3  89 05 CC CC CC CC             mov [CCCCCCCCH], eax ; $$DATA$$+216

#52					CAL		checkWashAndStart	{LNXT:10|82|-1}
(*) WORD^
08A653C9  50                            push eax
08A653CA  BB CC CC CC CC                mov ebx, CCCCCCCCH ; $$DATA$$+66
08A653CF  E8 04 F3 FF FF                call 08A646D8H ; $$CODE$$+18136
08A653D4  58                            pop eax

#53					JMP		$label3	{LNXT:9|10|26}
(-) WORD^
08A653D5  EB 11 90 90 90                jmp 08A653E8H

#54		$label2:
#55		
#56				(* ELSE *)
#57		
#58					(* q_start_ats := False; *)
#59					MOVE		False,q_start_ats	{LNXT:26|82|-1}
(*) WORD^
08A653DA  B8 00 00 00 00                mov eax, 00H
08A653DF  84 C0                         test al, al
08A653E1  0F 95 05 CC CC CC CC          setne [CCCCCCCCH] ; %Q1+7

#60		
#61		$label3:
#62				(* END_IF *)
#63				JMP		$label1	{LNXT:2|9|30}
(-) BOOL
08A653E8  EB 35 90 90 90                jmp 08A6541FH

#64		$label0:
#65		
#66			(* ELSE *)
#67		
#68				(* CMD.0 := False; *)
#69				MOVE		False,CMD.0	{LNXT:30|31|-1}
(*) BOOL
08A653ED  B8 00 00 00 00                mov eax, 00H
08A653F2  84 C0                         test al, al
08A653F4  90 75 11 90 90 90             jne 00000014H@
08A653FA  66 0F BA 35 CC CC CC CC 00    btr word ptr [CCCCCCCCH], 0 ; %M110+34
08A65403  EB 0C 90 90 90                jmp 0000000EH@
08A65408  66 0F BA 2D CC CC CC CC 00    bts word ptr [CCCCCCCCH], 0 ; %M110+34

#70		
#71				(* q_start_ats := False; *)
#72				MOVE		False,q_start_ats	{LNXT:31|82|-1}
(*) WORD
08A65411  B8 00 00 00 00                mov eax, 00H
08A65416  84 C0                         test al, al
08A65418  0F 95 05 CC CC CC CC          setne [CCCCCCCCH] ; %Q1+7

#73		
#74		$label1:
#75			(* END_IF *)
#76		
#77		
#78			(* IF q_start_ats *)
#79			LD		q_start_ats	{LNXT:82|-1|-1}
(*) UNDEF
08A6541F  33 C0                         xor eax, eax
08A65421  8A 05 CC CC CC CC             mov al, [CCCCCCCCH] ; %Q1+7

#80			NOT	{LNXT:82|-1|-1}
(*) BOOL
08A65427  84 C0                         test al, al
08A65429  0F 94 C0                      sete al

#81			JMPCN	$label4	{LNXT:82|83|85}
(-) BOOL
08A6542C  84 C0                         test al, al
08A6542E  90 74 16 90 90 90             je 08A65447H

#82		
#83			(* THEN *)
#84		
#85				(* downtimeIN:=true; *)
#86				MOVE		true,downtimeIN	{LNXT:83|95|-1}
(*) BOOL
08A65434  B8 01 00 00 00                mov eax, 01H
08A65439  84 C0                         test al, al
08A6543B  0F 95 05 CC CC CC CC          setne [CCCCCCCCH] ; $$DATA$$+238

#87				JMP		$label5	{LNXT:82|83|85}
(-) BOOL
08A65442  EB 11 90 90 90                jmp 08A65455H

#88		$label4:
#89		
#90			(* ELSE *)
#91		
#92				(* downtimeIN:=false; *)
#93				MOVE		false,downtimeIN	{LNXT:85|95|-1}
(*) BOOL
08A65447  B8 00 00 00 00                mov eax, 00H
08A6544C  84 C0                         test al, al
08A6544E  0F 95 05 CC CC CC CC          setne [CCCCCCCCH] ; $$DATA$$+238

#94		
#95		$label5:
#96			(* END_IF *)
#97		
#98			(* Alarms.2 := i_sns_door; *)
#99			MOVE		i_sns_door,Alarms.2	{LNXT:95|98|-1}
(*) BOOL
08A65455  33 C0                         xor eax, eax
08A65457  8A 05 CC CC CC CC             mov al, [CCCCCCCCH] ; $$DATA$$+239
08A6545D  84 C0                         test al, al
08A6545F  90 75 11 90 90 90             jne 00000014H@
08A65465  66 0F BA 35 CC CC CC CC 02    btr word ptr [CCCCCCCCH], 2 ; %M110+32
08A6546E  EB 0C 90 90 90                jmp 0000000EH@
08A65473  66 0F BA 2D CC CC CC CC 02    bts word ptr [CCCCCCCCH], 2 ; %M110+32

#100		
#101			(* Alarms.3 := i_rnpp; *)
#102			MOVE		i_rnpp,Alarms.3	{LNXT:98|104|-1}
(*) BOOL
08A6547C  33 C0                         xor eax, eax
08A6547E  8A 05 CC CC CC CC             mov al, [CCCCCCCCH] ; $$DATA$$+240
08A65484  84 C0                         test al, al
08A65486  90 75 11 90 90 90             jne 00000014H@
08A6548C  66 0F BA 35 CC CC CC CC 03    btr word ptr [CCCCCCCCH], 3 ; %M110+32
08A65495  EB 0C 90 90 90                jmp 0000000EH@
08A6549A  66 0F BA 2D CC CC CC CC 03    bts word ptr [CCCCCCCCH], 3 ; %M110+32

#103		
#104			(* Alarms.5 := i_no_alm_ats; *)
#105			MOVE		i_no_alm_ats,Alarms.5	{LNXT:104|145|-1}
(*) BOOL
08A654A3  33 C0                         xor eax, eax
08A654A5  8A 05 CC CC CC CC             mov al, [CCCCCCCCH] ; $$DATA$$+241
08A654AB  84 C0                         test al, al
08A654AD  90 75 11 90 90 90             jne 00000014H@
08A654B3  66 0F BA 35 CC CC CC CC 05    btr word ptr [CCCCCCCCH], 5 ; %M110+32
08A654BC  EB 0C 90 90 90                jmp 0000000EH@
08A654C1  66 0F BA 2D CC CC CC CC 05    bts word ptr [CCCCCCCCH], 5 ; %M110+32

#106		
#107		
#108			(* IF CMD.1 *)
#109			LD		CMD.1	{LNXT:145|-1|-1}
(*) UNDEF
08A654CA  33 C0                         xor eax, eax
08A654CC  66 8B 05 CC CC CC CC          mov ax, [CCCCCCCCH] ; %M110+34
08A654D3  C1 E8 01                      shr eax, 1
08A654D6  25 01 00 00 00                and eax, 1

#110			JMPCN	$label6	{LNXT:145|146|2}
(-) BOOL
08A654DB  84 C0                         test al, al
08A654DD  90 74 33 90 90 90             je 08A65513H

#111		
#112			(* THEN *)
#113		
#114				(* Alarms := 0; *)
#115				MOVE		0,Alarms	{LNXT:146|147|-1}
(*) BOOL
08A654E3  B8 00 00 00 00                mov eax, 00H
08A654E8  66 89 05 CC CC CC CC          mov [CCCCCCCCH], ax ; %M110+32

#116		
#117				(* CMD.1 := False; *)
#118				MOVE		False,CMD.1	{LNXT:147|2|-1}
(*) WORD
08A654EF  B8 00 00 00 00                mov eax, 00H
08A654F4  84 C0                         test al, al
08A654F6  90 75 11 90 90 90             jne 00000014H@
08A654FC  66 0F BA 35 CC CC CC CC 01    btr word ptr [CCCCCCCCH], 1 ; %M110+34
08A65505  EB 0C 90 90 90                jmp 0000000EH@
08A6550A  66 0F BA 2D CC CC CC CC 01    bts word ptr [CCCCCCCCH], 1 ; %M110+34

08A65513  61                            popad
08A65514  5D                            pop ebp

08A65515  C3                            ret

END_PROGRAM


**************************************************
	Target variable image generation
**************************************************


*** INPUT:
08A65516  55                            push ebp
08A65517  8B EC                         mov ebp, esp

08A65519  66 8B 0D CC CC CC CC          mov cx, [CCCCCCCCH] ; %I1+14
08A65520  66 89 0D CC CC CC CC          mov [CCCCCCCCH], cx ; $$DATA$$+64

08A65527  66 8B 0D CC CC CC CC          mov cx, [CCCCCCCCH] ; %I1+4
08A6552E  66 89 0D CC CC CC CC          mov [CCCCCCCCH], cx ; $$DATA$$+230

08A65535  66 8B 0D CC CC CC CC          mov cx, [CCCCCCCCH] ; %I1+6
08A6553C  66 89 0D CC CC CC CC          mov [CCCCCCCCH], cx ; $$DATA$$+232

08A65543  66 8B 0D CC CC CC CC          mov cx, [CCCCCCCCH] ; %I1+8
08A6554A  66 89 0D CC CC CC CC          mov [CCCCCCCCH], cx ; $$DATA$$+234

08A65551  66 8B 0D CC CC CC CC          mov cx, [CCCCCCCCH] ; %I1+10
08A65558  66 89 0D CC CC CC CC          mov [CCCCCCCCH], cx ; $$DATA$$+236

08A6555F  8A 0D CC CC CC CC             mov cl, [CCCCCCCCH] ; %I0+0
08A65565  88 0D CC CC CC CC             mov [CCCCCCCCH], cl ; $$DATA$$+58

08A6556B  8A 0D CC CC CC CC             mov cl, [CCCCCCCCH] ; %I0+3
08A65571  88 0D CC CC CC CC             mov [CCCCCCCCH], cl ; $$DATA$$+239

08A65577  8A 0D CC CC CC CC             mov cl, [CCCCCCCCH] ; %I0+4
08A6557D  88 0D CC CC CC CC             mov [CCCCCCCCH], cl ; $$DATA$$+240

08A65583  8A 0D CC CC CC CC             mov cl, [CCCCCCCCH] ; %I0+6
08A65589  88 0D CC CC CC CC             mov [CCCCCCCCH], cl ; $$DATA$$+241

08A6558F  66 8B 0D CC CC CC CC          mov cx, [CCCCCCCCH] ; %I1+0
08A65596  66 89 0D CC CC CC CC          mov [CCCCCCCCH], cx ; $$DATA$$+246

08A6559D  8B E5                         mov esp, ebp
08A6559F  5D                            pop ebp

08A655A0  C3                            ret


*** OUTPUT:
08A655A1  55                            push ebp
08A655A2  8B EC                         mov ebp, esp

08A655A4  8B E5                         mov esp, ebp
08A655A6  5D                            pop ebp

08A655A7  C3                            ret



**************************************************
	Task Timed init code
**************************************************

08A655A8  55                            push ebp
08A655A9  8B EC                         mov ebp, esp

Var init: V::SR_ATS_CTRL.TIME_SEC = 4000
08A655AB  66 C7 05 CC CC CC CC A0 0F    mov word ptr [CCCCCCCCH], 0FA0H ; $$DATA$$+228

08A655B4  8B E5                         mov esp, ebp
08A655B6  5D                            pop ebp

08A655B7  C3                            ret



**************************************************
	Global init code
**************************************************

08A655D0  55                            push ebp
08A655D1  8B EC                         mov ebp, esp

Var init: V:EMBEDDEDELEMENTS:$$POUCBARRAY$$BACKGROUND = [?ATS_mdb.$$POUCB$$, 0]
08A655D3  B9 CC CC CC CC                mov ecx, CCCCCCCCH ; $$DATA$$+336
08A655D8  89 0D CC CC CC CC             mov [CCCCCCCCH], ecx ; $$DATA$$+284

Var init: V:EMBEDDEDELEMENTS:$$POUCBARRAY$$BOOT = [?sr_init_counters.$$POUCB$$, 0]
08A655DE  B9 CC CC CC CC                mov ecx, CCCCCCCCH ; $$DATA$$+342
08A655E3  89 0D CC CC CC CC             mov [CCCCCCCCH], ecx ; $$DATA$$+292

Var init: V:EMBEDDEDELEMENTS:$$POUCBARRAY$$INIT = [?init_val.$$POUCB$$, 0]
08A655E9  B9 CC CC CC CC                mov ecx, CCCCCCCCH ; $$DATA$$+348
08A655EE  89 0D CC CC CC CC             mov [CCCCCCCCH], ecx ; $$DATA$$+300

Var init: V:EMBEDDEDELEMENTS:$$POUCBARRAY$$SERV = [?InitParDB.$$POUCB$$, 0]
08A655F4  B9 CC CC CC CC                mov ecx, CCCCCCCCH ; $$DATA$$+354
08A655F9  89 0D CC CC CC CC             mov [CCCCCCCCH], ecx ; $$DATA$$+308

Var init: V:EMBEDDEDELEMENTS:$$POUCBARRAY$$TIMED = [?sr_pressure.$$POUCB$$, ?sr_counters.$$POUCB$$, ?sr_save_counters.$$POUCB$$, ?sr_ATS_Ctrl.$$POUCB$$, 0]
08A655FF  B9 CC CC CC CC                mov ecx, CCCCCCCCH ; $$DATA$$+360
08A65604  89 0D CC CC CC CC             mov [CCCCCCCCH], ecx ; $$DATA$$+316
08A6560A  B9 CC CC CC CC                mov ecx, CCCCCCCCH ; $$DATA$$+366
08A6560F  89 0D CC CC CC CC             mov [CCCCCCCCH], ecx ; $$DATA$$+320
08A65615  B9 CC CC CC CC                mov ecx, CCCCCCCCH ; $$DATA$$+372
08A6561A  89 0D CC CC CC CC             mov [CCCCCCCCH], ecx ; $$DATA$$+324
08A65620  B9 CC CC CC CC                mov ecx, CCCCCCCCH ; $$DATA$$+378
08A65625  89 0D CC CC CC CC             mov [CCCCCCCCH], ecx ; $$DATA$$+328

08A6562B  8B E5                         mov esp, ebp
08A6562D  5D                            pop ebp

08A6562E  C3                            ret



**************************************************
	Global RETAIN init code
**************************************************

08A6562F  55                            push ebp
08A65630  8B EC                         mov ebp, esp

08A65632  8B E5                         mov esp, ebp
08A65634  5D                            pop ebp

08A65635  C3                            ret



**************************************************
	Task $$VirtualTables init code
**************************************************

08A65636  55                            push ebp
08A65637  8B EC                         mov ebp, esp

08A65639  8B E5                         mov esp, ebp
08A6563B  5D                            pop ebp

08A6563C  C3                            ret



********************************************
MEMORY MAP
********************************************

Code area type:          		       main code
Start code area:          		0000000008A60000h
End code area:            		0000000008A65FECh
Code size:                		00005FECh

Start local data area:    		00000000088E0000h
End local data area:      		00000000088E0180h
Local data size:          		00000180h

Start retentive data area:		0000000000000000h
End retentive data area:  		0000000000000000h
Retentive data size:      		00000000h

Start bit data area:      		0000000000000000h
End bit data area:        		0000000000000000h
Bit data size:            		00000000h



********************************************
CODE ID:                                F455B829
DEBUG MEMO ID:                          000034F7
FULL MEMO ID:                           0000788F
RELOCATION ADDR:                        0000000008A60000
********************************************
