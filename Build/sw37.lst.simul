***********************************************************************
*
*	CODE GENERATION LISTING FOR: sw37
*	COMPILER VERSION: 6.0.0.52
*
***********************************************************************

**************************************************
	List function block: R_TRIG
**************************************************

FUNCTION_BLOCK R_TRIG

	{ DE:"<HTML>The output Q will remain FALSE as long as the input variable CLK is FALSE.<br>
As soon as CLK returns TRUE, Q will first return TRUE.<br><br>
This means each time the function is called up, Q will return FALSE until CLK has falling edge followed by an rising edge.<br><br>
<img src= r_trig.png>" }

        VAR_INPUT
clk : BOOL;	{ DE:"Input for edge detection" }
	END_VAR

        VAR_OUTPUT
q : BOOL;	{ DE:"Raising edge output" }
	END_VAR

        VAR
m : BOOL := FALSE;
	END_VAR

END_FUNCTION_BLOCK

083E4490  55                            push ebp
083E4491  8B EB                         mov ebp, ebx
083E4493  57                            push edi

#0		{SRC:R_TRIG}
#1		
#2			LD		clk
(*) UNDEF
083E4494  33 C0                         xor eax, eax
083E4496  8A 45 01                      mov al, 1[ebp]

#3			ANDN	m
(*) BOOL
083E4499  33 C9                         xor ecx, ecx
083E449B  8A 4D 00                      mov cl, [ebp]
083E449E  84 C9                         test cl, cl
083E44A0  0F 94 C1                      sete cl
083E44A3  23 C1                         and eax, ecx

#4			ST		q
(*) BOOL
083E44A5  84 C0                         test al, al
083E44A7  0F 95 45 02                   setne 2[ebp]

#5		
#6			LD		clk
(*) UNDEF
083E44AB  33 C0                         xor eax, eax
083E44AD  8A 45 01                      mov al, 1[ebp]

#7			ST		m
(*) BOOL
083E44B0  84 C0                         test al, al
083E44B2  0F 95 45 00                   setne [ebp]

083E44B6  5F                            pop edi
083E44B7  5D                            pop ebp

083E44B8  C3                            ret


Frame allocation (hex):

	0000 bit  0: VAR m
	0001 bit  0: VAR clk
	0002 bit  0: VAR q

END_FUNCTION_BLOCK
**************************************************
	List function block: TON
**************************************************

FUNCTION_BLOCK TON

	{ DE:"<HTML>The TON block produces a delayed output Q of the input IN. The delay time is expressed in milliseconds on the PT input.</br></br>
<img src= tonscheme.png>
<ul>
<li>if IN is FALSE Q is false</li>
<li>Q becomes TRUE as IN remains TRUE for PT milliseconds</li>
<li>Q remains TRUE until IN remains TRUE</li>
</ul>" }

        VAR_INPUT
IN : BOOL;	{ DE:"Timer input source" }
PT : UDINT;	{ DE:"Preset time value (ms)" }
	END_VAR

        VAR_OUTPUT
Q : BOOL;	{ DE:"Timer output" }
ET : UDINT;	{ DE:"Timer current value (ms)" }
	END_VAR

        VAR_EXTERNAL
	{G:"System_Timers"}
sysTimer AT %MD0.0 : UDINT;	{ DE:"System timer [ms]" }
	END_VAR

        VAR
timStart : UDINT;	{ DE:"Time value at start of counting" }
	END_VAR

END_FUNCTION_BLOCK

083E44B9  55                            push ebp
083E44BA  8B EB                         mov ebp, ebx
083E44BC  57                            push edi

#0		{SRC:TON}
#1		
#2			(*	Check if in counting	*)
#3		
#4			LD		IN
(*) UNDEF
083E44BD  33 C0                         xor eax, eax
083E44BF  8A 45 04                      mov al, 4[ebp]

#5			JMPCN	lReset
(-) BOOL
083E44C2  84 C0                         test al, al
083E44C4  90 74 61 90 90 90             je 083E4528H

#6		
#7			(*	Check if Q is TRUE *)
#8			LD		Q
(*) UNDEF
083E44CA  33 C0                         xor eax, eax
083E44CC  8A 45 09                      mov al, 9[ebp]

#9			RETC
#10			
(-) BOOL
083E44CF  84 C0                         test al, al
083E44D1  90 75 6A 90 90 90             jne 083E453EH

#11			(*	Check if already in counting *)
#12			LD		timStart
(*) UNDEF
083E44D7  8B 45 00                      mov eax, [ebp]

#13			EQ		0
(*) UDINT
083E44DA  3D 00 00 00 00                cmp eax, 0
083E44DF  0F 94 C0                      sete al
083E44E2  25 FF 00 00 00                and eax, 0FFh

#14			JMPCN	lUpdate
(-) BOOL
083E44E7  84 C0                         test al, al
083E44E9  90 74 0C 90 90 90             je 083E44F8H

#15		
#16			(*	Start of counting *)
#17			LD		sysTimer
(*) UNDEF
083E44EF  8B 05 CC CC CC CC             mov eax, [CCCCCCCCH] ; %M0+0

#18			ST		timStart
(*) UDINT
083E44F5  89 45 00                      mov [ebp], eax

#19			
#20		lUpdate:
#21		
#22			(*	Update timer and check if time elapsed *)
#23			LD		sysTimer
(*) UNDEF
083E44F8  8B 05 CC CC CC CC             mov eax, [CCCCCCCCH] ; %M0+0

#24			SUB		timStart
(*) UDINT
083E44FE  2B 45 00                      sub eax, [ebp]

#25			ST		ET
(*) UDINT
083E4501  89 45 0A                      mov 10[ebp], eax

#26			GE		PT
(*) UDINT
083E4504  3B 45 05                      cmp eax, [ebp+5]
083E4507  0F 93 C0                      setae al
083E450A  25 FF 00 00 00                and eax, 0FFh

#27			ST		Q
(*) BOOL
083E450F  84 C0                         test al, al
083E4511  0F 95 45 09                   setne 9[ebp]

#28			RETCN
#29		
(-) BOOL
083E4515  84 C0                         test al, al
083E4517  90 74 24 90 90 90             je 083E453EH

#30			(*	Limit actual time value *)
#31			LD		PT
(*) UNDEF
083E451D  8B 45 05                      mov eax, 5[ebp]

#32			ST		ET
(*) UDINT
083E4520  89 45 0A                      mov 10[ebp], eax

#33			RET
#34		
(-) UDINT
083E4523  EB 19 90 90 90                jmp 083E453EH

#35		lReset:
#36		
#37			(*	Reset status *)
#38			LD		0
(*) UNDEF
083E4528  B8 00 00 00 00                mov eax, 00H

#39			ST		ET
(*) USINT
083E452D  89 45 0A                      mov 10[ebp], eax

#40			ST		timStart
(*) UDINT
083E4530  89 45 00                      mov [ebp], eax

#41			LD		FALSE
(*) UNDEF
083E4533  B8 00 00 00 00                mov eax, 00H

#42			ST		Q
(*) BOOL
083E4538  84 C0                         test al, al
083E453A  0F 95 45 09                   setne 9[ebp]

083E453E  5F                            pop edi
083E453F  5D                            pop ebp

083E4540  C3                            ret


Frame allocation (hex):

	0000       : VAR timStart
	0004 bit  0: VAR IN
	0005       : VAR PT
	0009 bit  0: VAR Q
	000A       : VAR ET

END_FUNCTION_BLOCK
**************************************************
	List function block: CheckAlarmVal
**************************************************

FUNCTION_BLOCK CheckAlarmVal

        VAR_IN_OUT
di_val_open_state_fall_FB : INT^;
di_val_close_state_fall_FB : INT^;
di_val_open_state_R_FB : INT^;
di_val_close_state_R_FB : BOOL^;
Alarm_Val_FB : WORD^;
o_val_open_R_FB : BOOL^;
o_val_close_R_FB : BOOL^;
o_val_open_fall_FB : BOOL^;
o_val_close_fall_FB : BOOL^;
start_check : BOOL^;
	END_VAR

        VAR_OUTPUT
check_timer : TON;	{ DE:"локальний FB таймера" }
is_check_done : BOOL;
isOK : BOOL;
	END_VAR

        VAR
should_run_timer : BOOL;
	END_VAR

END_FUNCTION_BLOCK

083E4541  55                            push ebp
083E4542  8B EB                         mov ebp, ebx
083E4544  57                            push edi

#0		{SRC:CheckAlarmVal}
#1		(*$WAITSWITCH$*)
#2		
#3		
#4			(* IF check_timer.IN *)
#5			LD		check_timer.IN	{LNXT:3|-1|-1}
(*) UNDEF
083E4545  33 C0                         xor eax, eax
083E4547  8A 45 05                      mov al, 5[ebp]

#6			JMPCN	$label0	{LNXT:3|4|8}
(-) BOOL
083E454A  84 C0                         test al, al
083E454C  90 74 19 90 90 90             je 083E4568H

#7		
#8			(* THEN *)
#9		
#10				(* isOK := TRUE; *)
#11				MOVE		TRUE,isOK	{LNXT:4|5|-1}
(*) BOOL
083E4552  B8 01 00 00 00                mov eax, 01H
083E4557  84 C0                         test al, al
083E4559  0F 95 45 18                   setne 24[ebp]

#12		
#13				(* is_check_done := false; *)
#14				MOVE		false,is_check_done	{LNXT:5|8|-1}
(*) BOOL
083E455D  B8 00 00 00 00                mov eax, 00H
083E4562  84 C0                         test al, al
083E4564  0F 95 45 17                   setne 23[ebp]

#15		
#16		$label0:
#17			(* END_IF *)
#18		
#19		
#20			(* IF start_check *)
#21			LD		start_check	{LNXT:8|-1|-1}
(*) UNDEF
083E4568  8B 55 3D                      mov edx, 61[ebp]
083E456B  33 C0                         xor eax, eax
083E456D  8A 02                         mov al, [edx]

#22			JMPCN	$label1	{LNXT:8|9|13}
(-) BOOL
083E456F  84 C0                         test al, al
083E4571  90 74 25 90 90 90             je 083E4599H

#23		
#24			(* THEN *)
#25		
#26				(* check_timer *)
#27				MOVE		true,check_timer.IN	{LNXT:9|-1|-1}
(*) BOOL
083E4577  B8 01 00 00 00                mov eax, 01H
083E457C  84 C0                         test al, al
083E457E  0F 95 45 05                   setne 5[ebp]

#28				MOVE		10000,check_timer.PT	{LNXT:9|-1|-1}
(*) BOOL
083E4582  B8 10 27 00 00                mov eax, 2710H
083E4587  89 45 06                      mov 6[ebp], eax

#29				CAL		check_timer	{LNXT:9|13|-1}
(*) UDINT
083E458A  50                            push eax
083E458B  8B DD                         mov ebx, ebp
083E458D  81 C3 01 00 00 00             add ebx, 1
083E4593  E8 21 FF FF FF                call 083E44B9H ; $$CODE$$+17593
083E4598  58                            pop eax

#30		
#31		$label1:
#32			(* END_IF *)
#33		
#34		
#35			(* IF check_timer.Q *)
#36			LD		check_timer.Q	{LNXT:13|-1|-1}
(*) UNDEF
083E4599  33 C0                         xor eax, eax
083E459B  8A 45 0A                      mov al, 10[ebp]

#37			JMPCN	$label2	{LNXT:13|15|41}
(-) BOOL
083E459E  84 C0                         test al, al
083E45A0  0F 84 32 01 00 00             je 083E46D8H

#38		
#39			(* THEN *)
#40		
#41				(* check_timer *)
#42				MOVE		false,check_timer.IN	{LNXT:15|-1|-1}
(*) BOOL
083E45A6  B8 00 00 00 00                mov eax, 00H
083E45AB  84 C0                         test al, al
083E45AD  0F 95 45 05                   setne 5[ebp]

#43				CAL		check_timer	{LNXT:15|17|-1}
(*) BOOL
083E45B1  50                            push eax
083E45B2  8B DD                         mov ebx, ebp
083E45B4  81 C3 01 00 00 00             add ebx, 1
083E45BA  E8 FA FE FF FF                call 083E44B9H ; $$CODE$$+17593
083E45BF  58                            pop eax

#44		
#45		
#46				(* IF o_val_open_R_FB^ AND NOT di_val_open_state_R_FB^ *)
#47				LD		di_val_open_state_R_FB^	{LNXT:17|-1|-1}
(*) UNDEF
083E45C0  8B 55 21                      mov edx, 33[ebp]
083E45C3  0F BF 02                      movsx eax, word ptr [edx]

#48				NOT	{LNXT:17|-1|-1}
(*) INT
083E45C6  66 F7 D0                      not ax

#49				AND		o_val_open_R_FB^	{LNXT:17|-1|-1}
(*) INT
083E45C9  8B 55 2D                      mov edx, 45[ebp]
083E45CC  33 C9                         xor ecx, ecx
083E45CE  8A 0A                         mov cl, [edx]
083E45D0  23 C1                         and eax, ecx

#50				JMPCN	$label3	{LNXT:17|18|21}
(-) INT
083E45D2  66 85 C0                      test ax, ax
083E45D5  90 74 20 90 90 90             je 083E45F8H

#51		
#52				(* THEN *)
#53		
#54					(* Alarm_Val_FB^.0 := TRUE; *)
#55					MOVE		TRUE,Alarm_Val_FB^.0	{LNXT:18|21|-1}
(*) INT
083E45DB  B8 01 00 00 00                mov eax, 01H
083E45E0  8B 55 29                      mov edx, 41[ebp]
083E45E3  84 C0                         test al, al
083E45E5  90 75 0C 90 90 90             jne 0000000FH@
083E45EB  0F BA 32 00                   btr [edx], 0
083E45EF  EB 07 90 90 90                jmp 00000009H@
083E45F4  0F BA 2A 00                   bts [edx], 0

#56		
#57		$label3:
#58				(* END_IF *)
#59		
#60		
#61				(* IF o_val_close_R_FB^ AND NOT di_val_close_state_R_FB^ *)
#62				LD		di_val_close_state_R_FB^	{LNXT:21|-1|-1}
(*) UNDEF
083E45F8  8B 55 25                      mov edx, 37[ebp]
083E45FB  33 C0                         xor eax, eax
083E45FD  8A 02                         mov al, [edx]

#63				NOT	{LNXT:21|-1|-1}
(*) BOOL
083E45FF  84 C0                         test al, al
083E4601  0F 94 C0                      sete al

#64				AND		o_val_close_R_FB^	{LNXT:21|-1|-1}
(*) BOOL
083E4604  8B 55 31                      mov edx, 49[ebp]
083E4607  8B 55 31                      mov edx, 49[ebp]
083E460A  33 C9                         xor ecx, ecx
083E460C  8A 0A                         mov cl, [edx]
083E460E  23 C1                         and eax, ecx

#65				JMPCN	$label4	{LNXT:21|22|25}
(-) BOOL
083E4610  84 C0                         test al, al
083E4612  90 74 20 90 90 90             je 083E4635H

#66		
#67				(* THEN *)
#68		
#69					(* Alarm_Val_FB^.1 := TRUE; *)
#70					MOVE		TRUE,Alarm_Val_FB^.1	{LNXT:22|25|-1}
(*) BOOL
083E4618  B8 01 00 00 00                mov eax, 01H
083E461D  8B 55 29                      mov edx, 41[ebp]
083E4620  84 C0                         test al, al
083E4622  90 75 0C 90 90 90             jne 0000000FH@
083E4628  0F BA 32 01                   btr [edx], 1
083E462C  EB 07 90 90 90                jmp 00000009H@
083E4631  0F BA 2A 01                   bts [edx], 1

#71		
#72		$label4:
#73				(* END_IF *)
#74		
#75		
#76				(* IF o_val_open_fall_FB^ AND NOT di_val_open_state_fall_FB^ *)
#77				LD		di_val_open_state_fall_FB^	{LNXT:25|-1|-1}
(*) UNDEF
083E4635  8B 55 19                      mov edx, 25[ebp]
083E4638  0F BF 02                      movsx eax, word ptr [edx]

#78				NOT	{LNXT:25|-1|-1}
(*) INT
083E463B  66 F7 D0                      not ax

#79				AND		o_val_open_fall_FB^	{LNXT:25|-1|-1}
(*) INT
083E463E  8B 55 35                      mov edx, 53[ebp]
083E4641  33 C9                         xor ecx, ecx
083E4643  8A 0A                         mov cl, [edx]
083E4645  23 C1                         and eax, ecx

#80				JMPCN	$label5	{LNXT:25|26|29}
(-) INT
083E4647  66 85 C0                      test ax, ax
083E464A  90 74 20 90 90 90             je 083E466DH

#81		
#82				(* THEN *)
#83		
#84					(* Alarm_Val_FB^.2 := TRUE; *)
#85					MOVE		TRUE,Alarm_Val_FB^.2	{LNXT:26|29|-1}
(*) INT
083E4650  B8 01 00 00 00                mov eax, 01H
083E4655  8B 55 29                      mov edx, 41[ebp]
083E4658  84 C0                         test al, al
083E465A  90 75 0C 90 90 90             jne 0000000FH@
083E4660  0F BA 32 02                   btr [edx], 2
083E4664  EB 07 90 90 90                jmp 00000009H@
083E4669  0F BA 2A 02                   bts [edx], 2

#86		
#87		$label5:
#88				(* END_IF *)
#89		
#90		
#91				(* IF o_val_close_fall_FB^ AND NOT di_val_close_state_fall_FB^ *)
#92				LD		di_val_close_state_fall_FB^	{LNXT:29|-1|-1}
(*) UNDEF
083E466D  8B 55 1D                      mov edx, 29[ebp]
083E4670  0F BF 02                      movsx eax, word ptr [edx]

#93				NOT	{LNXT:29|-1|-1}
(*) INT
083E4673  66 F7 D0                      not ax

#94				AND		o_val_close_fall_FB^	{LNXT:29|-1|-1}
(*) INT
083E4676  8B 55 39                      mov edx, 57[ebp]
083E4679  33 C9                         xor ecx, ecx
083E467B  8A 0A                         mov cl, [edx]
083E467D  23 C1                         and eax, ecx

#95				JMPCN	$label6	{LNXT:29|30|34}
(-) INT
083E467F  66 85 C0                      test ax, ax
083E4682  90 74 20 90 90 90             je 083E46A5H

#96		
#97				(* THEN *)
#98		
#99					(* Alarm_Val_FB^.3 := TRUE; *)
#100					MOVE		TRUE,Alarm_Val_FB^.3	{LNXT:30|34|-1}
(*) INT
083E4688  B8 01 00 00 00                mov eax, 01H
083E468D  8B 55 29                      mov edx, 41[ebp]
083E4690  84 C0                         test al, al
083E4692  90 75 0C 90 90 90             jne 0000000FH@
083E4698  0F BA 32 03                   btr [edx], 3
083E469C  EB 07 90 90 90                jmp 00000009H@
083E46A1  0F BA 2A 03                   bts [edx], 3

#101		
#102		$label6:
#103				(* END_IF *)
#104		
#105		
#106				(* IF Alarm_Val_FB^ > 0 *)
#107				LD		Alarm_Val_FB^	{LNXT:34|-1|-1}
(*) UNDEF
083E46A5  8B 55 29                      mov edx, 41[ebp]
083E46A8  33 C0                         xor eax, eax
083E46AA  66 8B 02                      mov ax, [edx]

#108				GT		0	{LNXT:34|-1|-1}
(*) WORD
083E46AD  3D 00 00 00 00                cmp eax, 0
083E46B2  0F 9F C0                      setg al
083E46B5  25 FF 00 00 00                and eax, 0FFh

#109				JMPCN	$label7	{LNXT:34|35|38}
(-) BOOL
083E46BA  84 C0                         test al, al
083E46BC  90 74 0E 90 90 90             je 083E46CDH

#110		
#111				(* THEN *)
#112		
#113					(* isOK := FALSE; *)
#114					MOVE		FALSE,isOK	{LNXT:35|38|-1}
(*) BOOL
083E46C2  B8 00 00 00 00                mov eax, 00H
083E46C7  84 C0                         test al, al
083E46C9  0F 95 45 18                   setne 24[ebp]

#115		
#116		$label7:
#117				(* END_IF *)
#118		
#119				(* is_check_done := TRUE; *)
#120				MOVE		TRUE,is_check_done	{LNXT:38|41|-1}
(*) BOOL
083E46CD  B8 01 00 00 00                mov eax, 01H
083E46D2  84 C0                         test al, al
083E46D4  0F 95 45 17                   setne 23[ebp]

#121		
#122		$label2:
#123			(* END_IF *)
#124		
#125			(* check_timer *)
#126			CAL		check_timer	{LNXT:41|-1|-1}
(*) BOOL
083E46D8  50                            push eax
083E46D9  8B DD                         mov ebx, ebp
083E46DB  81 C3 01 00 00 00             add ebx, 1
083E46E1  E8 D3 FD FF FF                call 083E44B9H ; $$CODE$$+17593
083E46E6  58                            pop eax

083E46E7  5F                            pop edi
083E46E8  5D                            pop ebp

083E46E9  C3                            ret


Frame allocation (hex):

	0000 bit  0: VAR should_run_timer
	0001       : FB check_timer
	0017 bit  0: VAR is_check_done
	0018 bit  0: VAR isOK
	0019       : VAR di_val_open_state_fall_FB
	001D       : VAR di_val_close_state_fall_FB
	0021       : VAR di_val_open_state_R_FB
	0025       : VAR di_val_close_state_R_FB
	0029       : VAR Alarm_Val_FB
	002D       : VAR o_val_open_R_FB
	0031       : VAR o_val_close_R_FB
	0035       : VAR o_val_open_fall_FB
	0039       : VAR o_val_close_fall_FB
	003D       : VAR start_check

END_FUNCTION_BLOCK
**************************************************
	List function block: CheckWashAndStart
**************************************************

FUNCTION_BLOCK CheckWashAndStart

        VAR_IN_OUT
sv_washing_FB : BOOL^;
o_val_open_R_FB : BOOL^;
o_val_close_R_FB : BOOL^;
o_val_open_fall_FB : BOOL^;
o_val_close_fall_FB : BOOL^;
q_start_ats_FB : BOOL^;
ep_time_wash_FB : INT^;
i_val_state_FB : INT^;
di_val_open_state_fall_FB : INT^;
di_val_close_state_fall_FB : INT^;
di_val_open_state_R_FB : INT^;
di_val_close_state_R_FB : BOOL^;
Alarm_Val_FB : WORD^;
	END_VAR

        VAR_OUTPUT
is_running_wash : BOOL;
	END_VAR

        VAR
washing_timer : TON;	{ DE:"локальний FB таймера" }
onWash : BOOL;
checkAlarmVal : CheckAlarmVal;
valve_rising : BOOL;
prev_val_open_fall : BOOL;
prev_val_close_fall : BOOL;
prev_val_open_R : BOOL;
prev_val_close_R : BOOL;
finish_val_rising : BOOL;
	END_VAR

END_FUNCTION_BLOCK

083E46EA  55                            push ebp
083E46EB  8B EB                         mov ebp, ebx
083E46ED  57                            push edi

#0		{SRC:CheckWashAndStart}
#1		(*$WAITSWITCH$*)
#2		
#3		
#4			(* IF sv_washing_FB^ and i_val_state_FB^=1 *)
#5			LD		i_val_state_FB^	{LNXT:1|-1|-1}
(*) UNDEF
083E46EE  8B 95 83 00 00 00             mov edx, 131[ebp]
083E46F4  0F BF 02                      movsx eax, word ptr [edx]

#6			EQ		1	{LNXT:1|-1|-1}
(*) INT
083E46F7  3D 01 00 00 00                cmp eax, 1
083E46FC  0F 94 C0                      sete al
083E46FF  25 FF 00 00 00                and eax, 0FFh

#7			AND		sv_washing_FB^	{LNXT:1|-1|-1}
(*) BOOL
083E4704  8B 55 67                      mov edx, 103[ebp]
083E4707  8B 55 67                      mov edx, 103[ebp]
083E470A  33 C9                         xor ecx, ecx
083E470C  8A 0A                         mov cl, [edx]
083E470E  23 C1                         and eax, ecx

#8			JMPCN	$label0	{LNXT:1|2|4}
(-) BOOL
083E4710  84 C0                         test al, al
083E4712  90 74 13 90 90 90             je 083E4728H

#9		
#10			(* THEN *)
#11		
#12				(* onWash :=true; *)
#13				MOVE		true,onWash	{LNXT:2|7|-1}
(*) BOOL
083E4718  B8 01 00 00 00                mov eax, 01H
083E471D  84 C0                         test al, al
083E471F  0F 95 45 16                   setne 22[ebp]

#14				JMP		$label1	{LNXT:1|2|4}
(-) BOOL
083E4723  EB 0E 90 90 90                jmp 083E4733H

#15		$label0:
#16		
#17			(* ELSE *)
#18		
#19				(* onWash :=false; *)
#20				MOVE		false,onWash	{LNXT:4|7|-1}
(*) BOOL
083E4728  B8 00 00 00 00                mov eax, 00H
083E472D  84 C0                         test al, al
083E472F  0F 95 45 16                   setne 22[ebp]

#21		
#22		$label1:
#23			(* END_IF *)
#24		
#25		
#26			(* IF onWash *)
#27			LD		onWash	{LNXT:7|-1|-1}
(*) UNDEF
083E4733  33 C0                         xor eax, eax
083E4735  8A 45 16                      mov al, 22[ebp]

#28			JMPCN	$label2	{LNXT:7|10|53}
(-) BOOL
083E4738  84 C0                         test al, al
083E473A  0F 84 87 01 00 00             je 083E48C7H

#29		
#30			(* THEN *)
#31		
#32				(* is_running_wash :=true; *)
#33				MOVE		true,is_running_wash	{LNXT:10|12|-1}
(*) BOOL
083E4740  B8 01 00 00 00                mov eax, 01H
083E4745  84 C0                         test al, al
083E4747  0F 95 45 66                   setne 102[ebp]

#34		
#35				(* prev_val_open_fall:=o_val_open_fall_FB^; *)
#36				MOVE		o_val_open_fall_FB^,prev_val_open_fall	{LNXT:12|13|-1}
(*) BOOL
083E474B  8B 55 73                      mov edx, 115[ebp]
083E474E  33 C0                         xor eax, eax
083E4750  8A 02                         mov al, [edx]
083E4752  84 C0                         test al, al
083E4754  0F 95 45 61                   setne 97[ebp]

#37		
#38				(* prev_val_close_fall:=o_val_close_fall_FB^; *)
#39				MOVE		o_val_close_fall_FB^,prev_val_close_fall	{LNXT:13|14|-1}
(*) BOOL
083E4758  8B 55 77                      mov edx, 119[ebp]
083E475B  33 C0                         xor eax, eax
083E475D  8A 02                         mov al, [edx]
083E475F  84 C0                         test al, al
083E4761  0F 95 45 62                   setne 98[ebp]

#40		
#41				(* prev_val_open_R:=o_val_open_R_FB^; *)
#42				MOVE		o_val_open_R_FB^,prev_val_open_R	{LNXT:14|15|-1}
(*) BOOL
083E4765  8B 55 6B                      mov edx, 107[ebp]
083E4768  33 C0                         xor eax, eax
083E476A  8A 02                         mov al, [edx]
083E476C  84 C0                         test al, al
083E476E  0F 95 45 63                   setne 99[ebp]

#43		
#44				(* prev_val_close_R:=o_val_close_R_FB^; *)
#45				MOVE		o_val_close_R_FB^,prev_val_close_R	{LNXT:15|17|-1}
(*) BOOL
083E4772  8B 55 6F                      mov edx, 111[ebp]
083E4775  33 C0                         xor eax, eax
083E4777  8A 02                         mov al, [edx]
083E4779  84 C0                         test al, al
083E477B  0F 95 45 64                   setne 100[ebp]

#46		
#47				(* o_val_close_R_FB^:=true; *)
#48				MOVE		true,o_val_close_R_FB^	{LNXT:17|18|-1}
(*) BOOL
083E477F  B8 01 00 00 00                mov eax, 01H
083E4784  8B 55 6F                      mov edx, 111[ebp]
083E4787  84 C0                         test al, al
083E4789  0F 95 02                      setne [edx]

#49		
#50				(* o_val_open_R_FB^:=false; *)
#51				MOVE		false,o_val_open_R_FB^	{LNXT:18|19|-1}
(*) BOOL
083E478C  B8 00 00 00 00                mov eax, 00H
083E4791  8B 55 6B                      mov edx, 107[ebp]
083E4794  84 C0                         test al, al
083E4796  0F 95 02                      setne [edx]

#52		
#53				(* o_val_open_fall_FB^:=true; *)
#54				MOVE		true,o_val_open_fall_FB^	{LNXT:19|20|-1}
(*) BOOL
083E4799  B8 01 00 00 00                mov eax, 01H
083E479E  8B 55 73                      mov edx, 115[ebp]
083E47A1  84 C0                         test al, al
083E47A3  0F 95 02                      setne [edx]

#55		
#56				(* o_val_close_fall_FB^:=false; *)
#57				MOVE		false,o_val_close_fall_FB^	{LNXT:20|22|-1}
(*) BOOL
083E47A6  B8 00 00 00 00                mov eax, 00H
083E47AB  8B 55 77                      mov edx, 119[ebp]
083E47AE  84 C0                         test al, al
083E47B0  0F 95 02                      setne [edx]

#58		
#59				(* valve_rising :=
#60		    (o_val_open_fall_FB^ AND NOT prev_val_open_fall) OR
#61			(o_val_close_fall_FB^ AND NOT prev_val_close_fall) OR
#62			(o_val_open_R_FB^ AND NOT prev_val_open_R) OR
#63			(o_val_close_R_FB^ AND NOT prev_val_close_R); *)
#64				LD		prev_val_close_R	{LNXT:22|30|-1}
(*) UNDEF
083E47B3  33 C0                         xor eax, eax
083E47B5  8A 45 64                      mov al, 100[ebp]

#65				NOT	{LNXT:22|30|-1}
(*) BOOL
083E47B8  84 C0                         test al, al
083E47BA  0F 94 C0                      sete al

#66				AND		o_val_close_R_FB^	{LNXT:22|30|-1}
(*) BOOL
083E47BD  8B 55 6F                      mov edx, 111[ebp]
083E47C0  8B 55 6F                      mov edx, 111[ebp]
083E47C3  33 C9                         xor ecx, ecx
083E47C5  8A 0A                         mov cl, [edx]
083E47C7  23 C1                         and eax, ecx

#67				OR(		prev_val_open_R	{LNXT:22|30|-1}
(*) BOOL
083E47C9  50                            push eax
083E47CA  33 C0                         xor eax, eax
083E47CC  8A 45 63                      mov al, 99[ebp]

#68				NOT	{LNXT:22|30|-1}
(*) BOOL
083E47CF  84 C0                         test al, al
083E47D1  0F 94 C0                      sete al

#69				AND		o_val_open_R_FB^	{LNXT:22|30|-1}
(*) BOOL
083E47D4  8B 55 6B                      mov edx, 107[ebp]
083E47D7  8B 55 6B                      mov edx, 107[ebp]
083E47DA  33 C9                         xor ecx, ecx
083E47DC  8A 0A                         mov cl, [edx]
083E47DE  23 C1                         and eax, ecx

#70				OR(		prev_val_close_fall	{LNXT:22|30|-1}
(*) BOOL
083E47E0  50                            push eax
083E47E1  33 C0                         xor eax, eax
083E47E3  8A 45 62                      mov al, 98[ebp]

#71				NOT	{LNXT:22|30|-1}
(*) BOOL
083E47E6  84 C0                         test al, al
083E47E8  0F 94 C0                      sete al

#72				AND		o_val_close_fall_FB^	{LNXT:22|30|-1}
(*) BOOL
083E47EB  8B 55 77                      mov edx, 119[ebp]
083E47EE  8B 55 77                      mov edx, 119[ebp]
083E47F1  33 C9                         xor ecx, ecx
083E47F3  8A 0A                         mov cl, [edx]
083E47F5  23 C1                         and eax, ecx

#73				OR(		prev_val_open_fall	{LNXT:22|30|-1}
(*) BOOL
083E47F7  50                            push eax
083E47F8  33 C0                         xor eax, eax
083E47FA  8A 45 61                      mov al, 97[ebp]

#74				NOT	{LNXT:22|30|-1}
(*) BOOL
083E47FD  84 C0                         test al, al
083E47FF  0F 94 C0                      sete al

#75				AND		o_val_open_fall_FB^	{LNXT:22|30|-1}
(*) BOOL
083E4802  8B 55 73                      mov edx, 115[ebp]
083E4805  8B 55 73                      mov edx, 115[ebp]
083E4808  33 C9                         xor ecx, ecx
083E480A  8A 0A                         mov cl, [edx]
083E480C  23 C1                         and eax, ecx

#76				)	{LNXT:22|30|-1}
(*) BOOL
083E480E  8B C8                         mov ecx, eax
083E4810  58                            pop eax
083E4811  0B C1                         or eax, ecx

#77				)	{LNXT:22|30|-1}
(*) BOOL
083E4813  8B C8                         mov ecx, eax
083E4815  58                            pop eax
083E4816  0B C1                         or eax, ecx

#78				)	{LNXT:22|30|-1}
(*) BOOL
083E4818  8B C8                         mov ecx, eax
083E481A  58                            pop eax
083E481B  0B C1                         or eax, ecx

#79				ST		valve_rising	{LNXT:22|30|-1}
(*) BOOL
083E481D  84 C0                         test al, al
083E481F  0F 95 45 60                   setne 96[ebp]

#80		
#81				(* checkAlarmVal *)
#82				MOVE		di_val_open_state_fall_FB,checkAlarmVal.di_val_open_state_fall_FB	{LNXT:30|-1|-1}
(*) BOOL
083E4823  8B 95 87 00 00 00             mov edx, 135[ebp]
083E4829  8D 02                         lea eax, [edx]
083E482B  89 45 30                      mov 48[ebp], eax

#83				MOVE		di_val_close_state_fall_FB,checkAlarmVal.di_val_close_state_fall_FB	{LNXT:30|-1|-1}
(*) INT^
083E482E  8B 95 8B 00 00 00             mov edx, 139[ebp]
083E4834  8D 02                         lea eax, [edx]
083E4836  89 45 34                      mov 52[ebp], eax

#84				MOVE		di_val_open_state_R_FB,checkAlarmVal.di_val_open_state_R_FB	{LNXT:31|-1|-1}
(*) INT^
083E4839  8B 95 8F 00 00 00             mov edx, 143[ebp]
083E483F  8D 02                         lea eax, [edx]
083E4841  89 45 38                      mov 56[ebp], eax

#85				MOVE		di_val_close_state_R_FB,checkAlarmVal.di_val_close_state_R_FB	{LNXT:32|-1|-1}
(*) INT^
083E4844  8B 95 93 00 00 00             mov edx, 147[ebp]
083E484A  8D 02                         lea eax, [edx]
083E484C  89 45 3C                      mov 60[ebp], eax

#86				MOVE		Alarm_Val_FB,checkAlarmVal.Alarm_Val_FB	{LNXT:33|-1|-1}
(*) BOOL^
083E484F  8B 95 97 00 00 00             mov edx, 151[ebp]
083E4855  8D 02                         lea eax, [edx]
083E4857  89 45 40                      mov 64[ebp], eax

#87				MOVE		o_val_open_R_FB,checkAlarmVal.o_val_open_R_FB	{LNXT:34|-1|-1}
(*) WORD^
083E485A  8B 55 6B                      mov edx, 107[ebp]
083E485D  8D 02                         lea eax, [edx]
083E485F  89 45 44                      mov 68[ebp], eax

#88				MOVE		o_val_close_R_FB,checkAlarmVal.o_val_close_R_FB	{LNXT:35|-1|-1}
(*) BOOL^
083E4862  8B 55 6F                      mov edx, 111[ebp]
083E4865  8D 02                         lea eax, [edx]
083E4867  89 45 48                      mov 72[ebp], eax

#89				MOVE		o_val_open_fall_FB,checkAlarmVal.o_val_open_fall_FB	{LNXT:36|-1|-1}
(*) BOOL^
083E486A  8B 55 73                      mov edx, 115[ebp]
083E486D  8D 02                         lea eax, [edx]
083E486F  89 45 4C                      mov 76[ebp], eax

#90				MOVE		o_val_close_fall_FB,checkAlarmVal.o_val_close_fall_FB	{LNXT:37|-1|-1}
(*) BOOL^
083E4872  8B 55 77                      mov edx, 119[ebp]
083E4875  8D 02                         lea eax, [edx]
083E4877  89 45 50                      mov 80[ebp], eax

#91				MOVE		valve_rising,checkAlarmVal.start_check	{LNXT:38|-1|-1}
(*) BOOL^
083E487A  8D 45 60                      lea eax, 96[ebp]
083E487D  89 45 54                      mov 84[ebp], eax

#92				CAL		checkAlarmVal	{LNXT:30|43|-1}
(*) BOOL^
083E4880  50                            push eax
083E4881  8B DD                         mov ebx, ebp
083E4883  81 C3 17 00 00 00             add ebx, 23
083E4889  E8 B3 FC FF FF                call 083E4541H ; $$CODE$$+17729
083E488E  58                            pop eax

#93		
#94		
#95				(* IF checkAlarmVal.is_check_done and checkAlarmVal.isOK *)
#96				LD		checkAlarmVal.is_check_done	{LNXT:43|-1|-1}
(*) UNDEF
083E488F  33 C0                         xor eax, eax
083E4891  8A 45 2E                      mov al, 46[ebp]

#97				AND		checkAlarmVal.isOK	{LNXT:43|-1|-1}
(*) BOOL
083E4894  33 C9                         xor ecx, ecx
083E4896  8A 4D 2F                      mov cl, 47[ebp]
083E4899  23 C1                         and eax, ecx

#98				JMPCN	$label4	{LNXT:43|44|47}
(-) BOOL
083E489B  84 C0                         test al, al
083E489D  90 74 15 90 90 90             je 083E48B5H

#99		
#100				(* THEN *)
#101		
#102					(* q_start_ats_FB^:=true; *)
#103					MOVE		true,q_start_ats_FB^	{LNXT:44|57|-1}
(*) BOOL
083E48A3  B8 01 00 00 00                mov eax, 01H
083E48A8  8B 55 7B                      mov edx, 123[ebp]
083E48AB  84 C0                         test al, al
083E48AD  0F 95 02                      setne [edx]

#104					JMP		$label5	{LNXT:43|44|47}
(-) BOOL
083E48B0  EB 10 90 90 90                jmp 083E48C2H

#105		$label4:
#106		
#107				(* ELSE *)
#108		
#109					(* q_start_ats_FB^:=false; *)
#110					MOVE		false,q_start_ats_FB^	{LNXT:47|57|-1}
(*) BOOL
083E48B5  B8 00 00 00 00                mov eax, 00H
083E48BA  8B 55 7B                      mov edx, 123[ebp]
083E48BD  84 C0                         test al, al
083E48BF  0F 95 02                      setne [edx]

#111		
#112		$label5:
#113				(* END_IF *)
#114				JMP		$label3	{LNXT:7|10|53}
(-) BOOL
083E48C2  EB 10 90 90 90                jmp 083E48D4H

#115		$label2:
#116		
#117			(* ELSE *)
#118		
#119				(* q_start_ats_FB^:=true; *)
#120				MOVE		true,q_start_ats_FB^	{LNXT:53|57|-1}
(*) BOOL
083E48C7  B8 01 00 00 00                mov eax, 01H
083E48CC  8B 55 7B                      mov edx, 123[ebp]
083E48CF  84 C0                         test al, al
083E48D1  0F 95 02                      setne [edx]

#121		
#122		$label3:
#123			(* END_IF *)
#124		
#125		
#126			(* IF washing_timer.Q *)
#127			LD		washing_timer.Q	{LNXT:57|-1|-1}
(*) UNDEF
083E48D4  33 C0                         xor eax, eax
083E48D6  8A 45 09                      mov al, 9[ebp]

#128			JMPCN	$label6	{LNXT:57|60|93}
(-) BOOL
083E48D9  84 C0                         test al, al
083E48DB  0F 84 F0 00 00 00             je 083E49D1H

#129		
#130			(* THEN *)
#131		
#132				(* prev_val_open_fall:=o_val_open_fall_FB^; *)
#133				MOVE		o_val_open_fall_FB^,prev_val_open_fall	{LNXT:60|61|-1}
(*) BOOL
083E48E1  8B 55 73                      mov edx, 115[ebp]
083E48E4  33 C0                         xor eax, eax
083E48E6  8A 02                         mov al, [edx]
083E48E8  84 C0                         test al, al
083E48EA  0F 95 45 61                   setne 97[ebp]

#134		
#135				(* prev_val_close_fall:=o_val_close_fall_FB^; *)
#136				MOVE		o_val_close_fall_FB^,prev_val_close_fall	{LNXT:61|62|-1}
(*) BOOL
083E48EE  8B 55 77                      mov edx, 119[ebp]
083E48F1  33 C0                         xor eax, eax
083E48F3  8A 02                         mov al, [edx]
083E48F5  84 C0                         test al, al
083E48F7  0F 95 45 62                   setne 98[ebp]

#137		
#138				(* prev_val_open_R:=o_val_open_R_FB^; *)
#139				MOVE		o_val_open_R_FB^,prev_val_open_R	{LNXT:62|63|-1}
(*) BOOL
083E48FB  8B 55 6B                      mov edx, 107[ebp]
083E48FE  33 C0                         xor eax, eax
083E4900  8A 02                         mov al, [edx]
083E4902  84 C0                         test al, al
083E4904  0F 95 45 63                   setne 99[ebp]

#140		
#141				(* prev_val_close_R:=o_val_close_R_FB^; *)
#142				MOVE		o_val_close_R_FB^,prev_val_close_R	{LNXT:63|66|-1}
(*) BOOL
083E4908  8B 55 6F                      mov edx, 111[ebp]
083E490B  33 C0                         xor eax, eax
083E490D  8A 02                         mov al, [edx]
083E490F  84 C0                         test al, al
083E4911  0F 95 45 64                   setne 100[ebp]

#143		
#144				(* o_val_close_R_FB^:=false; *)
#145				MOVE		false,o_val_close_R_FB^	{LNXT:66|67|-1}
(*) BOOL
083E4915  B8 00 00 00 00                mov eax, 00H
083E491A  8B 55 6F                      mov edx, 111[ebp]
083E491D  84 C0                         test al, al
083E491F  0F 95 02                      setne [edx]

#146		
#147				(* o_val_open_fall_FB^:=false; *)
#148				MOVE		false,o_val_open_fall_FB^	{LNXT:67|69|-1}
(*) BOOL
083E4922  B8 00 00 00 00                mov eax, 00H
083E4927  8B 55 73                      mov edx, 115[ebp]
083E492A  84 C0                         test al, al
083E492C  0F 95 02                      setne [edx]

#149		
#150				(* o_val_open_R_FB^:=true; *)
#151				MOVE		true,o_val_open_R_FB^	{LNXT:69|70|-1}
(*) BOOL
083E492F  B8 01 00 00 00                mov eax, 01H
083E4934  8B 55 6B                      mov edx, 107[ebp]
083E4937  84 C0                         test al, al
083E4939  0F 95 02                      setne [edx]

#152		
#153				(* o_val_close_fall_FB^:=true; *)
#154				MOVE		true,o_val_close_fall_FB^	{LNXT:70|72|-1}
(*) BOOL
083E493C  B8 01 00 00 00                mov eax, 01H
083E4941  8B 55 77                      mov edx, 119[ebp]
083E4944  84 C0                         test al, al
083E4946  0F 95 02                      setne [edx]

#155		
#156				(* valve_rising :=
#157		    (o_val_open_fall_FB^ AND NOT prev_val_open_fall) OR
#158			(o_val_close_fall_FB^ AND NOT prev_val_close_fall) OR
#159			(o_val_open_R_FB^ AND NOT prev_val_open_R) OR
#160			(o_val_close_R_FB^ AND NOT prev_val_close_R); *)
#161				LD		prev_val_close_R	{LNXT:72|78|-1}
(*) UNDEF
083E4949  33 C0                         xor eax, eax
083E494B  8A 45 64                      mov al, 100[ebp]

#162				NOT	{LNXT:72|78|-1}
(*) BOOL
083E494E  84 C0                         test al, al
083E4950  0F 94 C0                      sete al

#163				AND		o_val_close_R_FB^	{LNXT:72|78|-1}
(*) BOOL
083E4953  8B 55 6F                      mov edx, 111[ebp]
083E4956  8B 55 6F                      mov edx, 111[ebp]
083E4959  33 C9                         xor ecx, ecx
083E495B  8A 0A                         mov cl, [edx]
083E495D  23 C1                         and eax, ecx

#164				OR(		prev_val_open_R	{LNXT:72|78|-1}
(*) BOOL
083E495F  50                            push eax
083E4960  33 C0                         xor eax, eax
083E4962  8A 45 63                      mov al, 99[ebp]

#165				NOT	{LNXT:72|78|-1}
(*) BOOL
083E4965  84 C0                         test al, al
083E4967  0F 94 C0                      sete al

#166				AND		o_val_open_R_FB^	{LNXT:72|78|-1}
(*) BOOL
083E496A  8B 55 6B                      mov edx, 107[ebp]
083E496D  8B 55 6B                      mov edx, 107[ebp]
083E4970  33 C9                         xor ecx, ecx
083E4972  8A 0A                         mov cl, [edx]
083E4974  23 C1                         and eax, ecx

#167				OR(		prev_val_close_fall	{LNXT:72|78|-1}
(*) BOOL
083E4976  50                            push eax
083E4977  33 C0                         xor eax, eax
083E4979  8A 45 62                      mov al, 98[ebp]

#168				NOT	{LNXT:72|78|-1}
(*) BOOL
083E497C  84 C0                         test al, al
083E497E  0F 94 C0                      sete al

#169				AND		o_val_close_fall_FB^	{LNXT:72|78|-1}
(*) BOOL
083E4981  8B 55 77                      mov edx, 119[ebp]
083E4984  8B 55 77                      mov edx, 119[ebp]
083E4987  33 C9                         xor ecx, ecx
083E4989  8A 0A                         mov cl, [edx]
083E498B  23 C1                         and eax, ecx

#170				OR(		prev_val_open_fall	{LNXT:72|78|-1}
(*) BOOL
083E498D  50                            push eax
083E498E  33 C0                         xor eax, eax
083E4990  8A 45 61                      mov al, 97[ebp]

#171				NOT	{LNXT:72|78|-1}
(*) BOOL
083E4993  84 C0                         test al, al
083E4995  0F 94 C0                      sete al

#172				AND		o_val_open_fall_FB^	{LNXT:72|78|-1}
(*) BOOL
083E4998  8B 55 73                      mov edx, 115[ebp]
083E499B  8B 55 73                      mov edx, 115[ebp]
083E499E  33 C9                         xor ecx, ecx
083E49A0  8A 0A                         mov cl, [edx]
083E49A2  23 C1                         and eax, ecx

#173				)	{LNXT:72|78|-1}
(*) BOOL
083E49A4  8B C8                         mov ecx, eax
083E49A6  58                            pop eax
083E49A7  0B C1                         or eax, ecx

#174				)	{LNXT:72|78|-1}
(*) BOOL
083E49A9  8B C8                         mov ecx, eax
083E49AB  58                            pop eax
083E49AC  0B C1                         or eax, ecx

#175				)	{LNXT:72|78|-1}
(*) BOOL
083E49AE  8B C8                         mov ecx, eax
083E49B0  58                            pop eax
083E49B1  0B C1                         or eax, ecx

#176				ST		valve_rising	{LNXT:72|78|-1}
(*) BOOL
083E49B3  84 C0                         test al, al
083E49B5  0F 95 45 60                   setne 96[ebp]

#177		
#178		
#179				(* IF valve_rising *)
#180				LD		valve_rising	{LNXT:78|-1|-1}
(*) UNDEF
083E49B9  33 C0                         xor eax, eax
083E49BB  8A 45 60                      mov al, 96[ebp]

#181				JMPCN	$label7	{LNXT:78|79|93}
(-) BOOL
083E49BE  84 C0                         test al, al
083E49C0  90 74 0E 90 90 90             je 083E49D1H

#182		
#183				(* THEN *)
#184		
#185					(* finish_val_rising :=true; *)
#186					MOVE		true,finish_val_rising	{LNXT:79|93|-1}
(*) BOOL
083E49C6  B8 01 00 00 00                mov eax, 01H
083E49CB  84 C0                         test al, al
083E49CD  0F 95 45 65                   setne 101[ebp]

#187		
#188		$label7:
#189				(* END_IF *)
#190		
#191		$label6:
#192			(* END_IF *)
#193		
#194		
#195			(* IF finish_val_rising *)
#196			LD		finish_val_rising	{LNXT:93|-1|-1}
(*) UNDEF
083E49D1  33 C0                         xor eax, eax
083E49D3  8A 45 65                      mov al, 101[ebp]

#197			JMPCN	$label8	{LNXT:93|94|98}
(-) BOOL
083E49D6  84 C0                         test al, al
083E49D8  90 74 1B 90 90 90             je 083E49F6H

#198		
#199			(* THEN *)
#200		
#201				(* sv_washing_FB^:=false; *)
#202				MOVE		false,sv_washing_FB^	{LNXT:94|95|-1}
(*) BOOL
083E49DE  B8 00 00 00 00                mov eax, 00H
083E49E3  8B 55 67                      mov edx, 103[ebp]
083E49E6  84 C0                         test al, al
083E49E8  0F 95 02                      setne [edx]

#203		
#204				(* onWash :=false; *)
#205				MOVE		false,onWash	{LNXT:95|98|-1}
(*) BOOL
083E49EB  B8 00 00 00 00                mov eax, 00H
083E49F0  84 C0                         test al, al
083E49F2  0F 95 45 16                   setne 22[ebp]

#206		
#207		$label8:
#208			(* END_IF *)
#209		
#210		
#211			(* IF checkAlarmVal.check_timer.Q *)
#212			LD		checkAlarmVal.check_timer.Q	{LNXT:98|-1|-1}
(*) UNDEF
083E49F6  33 C0                         xor eax, eax
083E49F8  8A 45 21                      mov al, 33[ebp]

#213			JMPCN	$label9	{LNXT:98|100|106}
(-) BOOL
083E49FB  84 C0                         test al, al
083E49FD  90 74 0E 90 90 90             je 083E4A0EH

#214		
#215			(* THEN *)
#216		
#217				(* is_running_wash :=false; *)
#218				MOVE		false,is_running_wash	{LNXT:100|106|-1}
(*) BOOL
083E4A03  B8 00 00 00 00                mov eax, 00H
083E4A08  84 C0                         test al, al
083E4A0A  0F 95 45 66                   setne 102[ebp]

#219		
#220		$label9:
#221			(* END_IF *)
#222		
#223			(* checkAlarmVal *)
#224			MOVE		di_val_open_state_fall_FB,checkAlarmVal.di_val_open_state_fall_FB	{LNXT:106|-1|-1}
(*) BOOL
083E4A0E  8B 95 87 00 00 00             mov edx, 135[ebp]
083E4A14  8D 02                         lea eax, [edx]
083E4A16  89 45 30                      mov 48[ebp], eax

#225			MOVE		di_val_close_state_fall_FB,checkAlarmVal.di_val_close_state_fall_FB	{LNXT:106|-1|-1}
(*) INT^
083E4A19  8B 95 8B 00 00 00             mov edx, 139[ebp]
083E4A1F  8D 02                         lea eax, [edx]
083E4A21  89 45 34                      mov 52[ebp], eax

#226			MOVE		di_val_open_state_R_FB,checkAlarmVal.di_val_open_state_R_FB	{LNXT:107|-1|-1}
(*) INT^
083E4A24  8B 95 8F 00 00 00             mov edx, 143[ebp]
083E4A2A  8D 02                         lea eax, [edx]
083E4A2C  89 45 38                      mov 56[ebp], eax

#227			MOVE		di_val_close_state_R_FB,checkAlarmVal.di_val_close_state_R_FB	{LNXT:108|-1|-1}
(*) INT^
083E4A2F  8B 95 93 00 00 00             mov edx, 147[ebp]
083E4A35  8D 02                         lea eax, [edx]
083E4A37  89 45 3C                      mov 60[ebp], eax

#228			MOVE		Alarm_Val_FB,checkAlarmVal.Alarm_Val_FB	{LNXT:109|-1|-1}
(*) BOOL^
083E4A3A  8B 95 97 00 00 00             mov edx, 151[ebp]
083E4A40  8D 02                         lea eax, [edx]
083E4A42  89 45 40                      mov 64[ebp], eax

#229			MOVE		o_val_open_R_FB,checkAlarmVal.o_val_open_R_FB	{LNXT:110|-1|-1}
(*) WORD^
083E4A45  8B 55 6B                      mov edx, 107[ebp]
083E4A48  8D 02                         lea eax, [edx]
083E4A4A  89 45 44                      mov 68[ebp], eax

#230			MOVE		o_val_close_R_FB,checkAlarmVal.o_val_close_R_FB	{LNXT:111|-1|-1}
(*) BOOL^
083E4A4D  8B 55 6F                      mov edx, 111[ebp]
083E4A50  8D 02                         lea eax, [edx]
083E4A52  89 45 48                      mov 72[ebp], eax

#231			MOVE		o_val_open_fall_FB,checkAlarmVal.o_val_open_fall_FB	{LNXT:112|-1|-1}
(*) BOOL^
083E4A55  8B 55 73                      mov edx, 115[ebp]
083E4A58  8D 02                         lea eax, [edx]
083E4A5A  89 45 4C                      mov 76[ebp], eax

#232			MOVE		o_val_close_fall_FB,checkAlarmVal.o_val_close_fall_FB	{LNXT:113|-1|-1}
(*) BOOL^
083E4A5D  8B 55 77                      mov edx, 119[ebp]
083E4A60  8D 02                         lea eax, [edx]
083E4A62  89 45 50                      mov 80[ebp], eax

#233			MOVE		finish_val_rising,checkAlarmVal.start_check	{LNXT:114|-1|-1}
(*) BOOL^
083E4A65  8D 45 65                      lea eax, 101[ebp]
083E4A68  89 45 54                      mov 84[ebp], eax

#234			CAL		checkAlarmVal	{LNXT:106|117|-1}
(*) BOOL^
083E4A6B  50                            push eax
083E4A6C  8B DD                         mov ebx, ebp
083E4A6E  81 C3 17 00 00 00             add ebx, 23
083E4A74  E8 C8 FA FF FF                call 083E4541H ; $$CODE$$+17729
083E4A79  58                            pop eax

#235		
#236		
#237			(* IF finish_val_rising *)
#238			LD		finish_val_rising	{LNXT:117|-1|-1}
(*) UNDEF
083E4A7A  33 C0                         xor eax, eax
083E4A7C  8A 45 65                      mov al, 101[ebp]

#239			JMPCN	$label10	{LNXT:117|118|121}
(-) BOOL
083E4A7F  84 C0                         test al, al
083E4A81  90 74 0E 90 90 90             je 083E4A92H

#240		
#241			(* THEN *)
#242		
#243				(* finish_val_rising:=false; *)
#244				MOVE		false,finish_val_rising	{LNXT:118|121|-1}
(*) BOOL
083E4A87  B8 00 00 00 00                mov eax, 00H
083E4A8C  84 C0                         test al, al
083E4A8E  0F 95 45 65                   setne 101[ebp]

#245		
#246		$label10:
#247			(* END_IF *)
#248		
#249			(* washing_timer *)
#250			LD		onWash	{LNXT:121|-1|-1}
(*) UNDEF
083E4A92  33 C0                         xor eax, eax
083E4A94  8A 45 16                      mov al, 22[ebp]

#251			AND		q_start_ats_FB^	{LNXT:121|-1|-1}
(*) BOOL
083E4A97  8B 55 7B                      mov edx, 123[ebp]
083E4A9A  8B 55 7B                      mov edx, 123[ebp]
083E4A9D  33 C9                         xor ecx, ecx
083E4A9F  8A 0A                         mov cl, [edx]
083E4AA1  23 C1                         and eax, ecx

#252			ST		washing_timer.IN	{LNXT:121|-1|-1}
(*) BOOL
083E4AA3  84 C0                         test al, al
083E4AA5  0F 95 45 04                   setne 4[ebp]

#253			MOVE		ep_time_wash_FB^,washing_timer.PT	{LNXT:121|-1|-1}
(*) BOOL
083E4AA9  8B 55 7F                      mov edx, 127[ebp]
083E4AAC  0F BF 02                      movsx eax, word ptr [edx]
083E4AAF  89 45 05                      mov 5[ebp], eax

#254			CAL		washing_timer	{LNXT:121|-1|-1}
(*) INT
083E4AB2  50                            push eax
083E4AB3  8B DD                         mov ebx, ebp
083E4AB5  E8 FF F9 FF FF                call 083E44B9H ; $$CODE$$+17593
083E4ABA  58                            pop eax

083E4ABB  5F                            pop edi
083E4ABC  5D                            pop ebp

083E4ABD  C3                            ret


Frame allocation (hex):

	0000       : FB washing_timer
	0016 bit  0: VAR onWash
	0017       : FB checkAlarmVal
	0060 bit  0: VAR valve_rising
	0061 bit  0: VAR prev_val_open_fall
	0062 bit  0: VAR prev_val_close_fall
	0063 bit  0: VAR prev_val_open_R
	0064 bit  0: VAR prev_val_close_R
	0065 bit  0: VAR finish_val_rising
	0066 bit  0: VAR is_running_wash
	0067       : VAR sv_washing_FB
	006B       : VAR o_val_open_R_FB
	006F       : VAR o_val_close_R_FB
	0073       : VAR o_val_open_fall_FB
	0077       : VAR o_val_close_fall_FB
	007B       : VAR q_start_ats_FB
	007F       : VAR ep_time_wash_FB
	0083       : VAR i_val_state_FB
	0087       : VAR di_val_open_state_fall_FB
	008B       : VAR di_val_close_state_fall_FB
	008F       : VAR di_val_open_state_R_FB
	0093       : VAR di_val_close_state_R_FB
	0097       : VAR Alarm_Val_FB

END_FUNCTION_BLOCK
**************************************************
	List program: ATS_mdb
**************************************************

PROGRAM ATS_mdb

        VAR
res_eta_lcr : UINT;
resp_eta_lcr : ARRAY[0..3] OF INT;
res : INT;
xTON : TON;
	END_VAR

END_PROGRAM

083E4AC0  55                            push ebp
083E4AC1  8B EC                         mov ebp, esp
083E4AC3  60                            pushad

#0		{SRC:ATS_mdb}
#1		(*$WAITSWITCH$*)
#2		
#3			(* res := sysMbMRTU_FC03(	addr := 1, 
#4											base := 257, // 256
#5											no := 4, 
#6											object := ADR(resp_eta_lcr), 
#7											timeout := 200); *)
#8			ADR		resp_eta_lcr	{LNXT:2|8|-1}
(*) UDINT
083E4AC4  B8 CC CC CC CC                mov eax, CCCCCCCCH ; $$DATA$$+12

#9			ST		$$TMP0	{LNXT:2|8|-1}
(*) @INT
083E4AC9  89 05 CC CC CC CC             mov [CCCCCCCCH], eax ; $$DATA$$+20

#10			LDP0		1	{LNXT:2|8|-1}
(*) @INT
#11			sysMbMRTU_FC03		257, 4, $$TMP0, 200	{LNXT:2|8|-1}
(*) @INT
083E4ACF  68 C8 00 00 00                push 200
083E4AD4  FF 35 CC CC CC CC             push [CCCCCCCCH] ; $$DATA$$+20
083E4ADA  68 04 00 00 00                push 4
083E4ADF  68 01 01 00 00                push 257
083E4AE4  68 01 00 00 00                push 1
083E4AE9  B9 CC CC CC CC                mov ecx, CCCCCCCCH ; sysMbMRTU_FC03
083E4AEE  FF D1                         call ecx
083E4AF0  81 C4 14 00 00 00             add esp, 20

#12			ST		res	{LNXT:2|8|-1}
(*) UINT
083E4AF6  66 89 05 CC CC CC CC          mov [CCCCCCCCH], ax ; $$DATA$$+24

#13		
#14			(* ATS22_DUT.Ready 	:= to_bool(resp_eta_lcr[0] And 16#01); *)
#15			LD		resp_eta_lcr[0]	{LNXT:8|9|-1}
(*) UNDEF
083E4AFD  0F BF 05 CC CC CC CC          movsx eax, word ptr [CCCCCCCCH] ; $$DATA$$+12

#16			AND		16#01	{LNXT:8|9|-1}
(*) INT
083E4B04  25 01 00 00 00                and eax, 00000001H

#17			to_bool	{LNXT:8|9|-1}
(*) INT
083E4B09  66 85 C0                      test ax, ax
083E4B0C  0F 95 C0                      setne al

#18			ST		ATS22_DUT.Ready	{LNXT:8|9|-1}
(*) BOOL
083E4B0F  84 C0                         test al, al
083E4B11  0F 95 05 CC CC CC CC          setne [CCCCCCCCH] ; $$DATA$$+26

#19		
#20			(* ATS22_DUT.On 		:= to_bool(resp_eta_lcr[0] And 16#02); *)
#21			LD		resp_eta_lcr[0]	{LNXT:9|10|-1}
(*) UNDEF
083E4B18  0F BF 05 CC CC CC CC          movsx eax, word ptr [CCCCCCCCH] ; $$DATA$$+12

#22			AND		16#02	{LNXT:9|10|-1}
(*) INT
083E4B1F  25 02 00 00 00                and eax, 00000002H

#23			to_bool	{LNXT:9|10|-1}
(*) INT
083E4B24  66 85 C0                      test ax, ax
083E4B27  0F 95 C0                      setne al

#24			ST		ATS22_DUT.On	{LNXT:9|10|-1}
(*) BOOL
083E4B2A  84 C0                         test al, al
083E4B2C  0F 95 05 CC CC CC CC          setne [CCCCCCCCH] ; $$DATA$$+27

#25		
#26			(* ATS22_DUT.Trip 		:= to_bool(resp_eta_lcr[0] And 16#04); *)
#27			LD		resp_eta_lcr[0]	{LNXT:10|11|-1}
(*) UNDEF
083E4B33  0F BF 05 CC CC CC CC          movsx eax, word ptr [CCCCCCCCH] ; $$DATA$$+12

#28			AND		16#04	{LNXT:10|11|-1}
(*) INT
083E4B3A  25 04 00 00 00                and eax, 00000004H

#29			to_bool	{LNXT:10|11|-1}
(*) INT
083E4B3F  66 85 C0                      test ax, ax
083E4B42  0F 95 C0                      setne al

#30			ST		ATS22_DUT.Trip	{LNXT:10|11|-1}
(*) BOOL
083E4B45  84 C0                         test al, al
083E4B47  0F 95 05 CC CC CC CC          setne [CCCCCCCCH] ; $$DATA$$+28

#31		
#32			(* ATS22_DUT.Warning 	:= to_bool(resp_eta_lcr[0] And 16#08); *)
#33			LD		resp_eta_lcr[0]	{LNXT:11|12|-1}
(*) UNDEF
083E4B4E  0F BF 05 CC CC CC CC          movsx eax, word ptr [CCCCCCCCH] ; $$DATA$$+12

#34			AND		16#08	{LNXT:11|12|-1}
(*) INT
083E4B55  25 08 00 00 00                and eax, 00000008H

#35			to_bool	{LNXT:11|12|-1}
(*) INT
083E4B5A  66 85 C0                      test ax, ax
083E4B5D  0F 95 C0                      setne al

#36			ST		ATS22_DUT.Warning	{LNXT:11|12|-1}
(*) BOOL
083E4B60  84 C0                         test al, al
083E4B62  0F 95 05 CC CC CC CC          setne [CCCCCCCCH] ; $$DATA$$+29

#37		
#38			(* ATS22_DUT.LI3 		:= to_bool(resp_eta_lcr[0] And 16#20); *)
#39			LD		resp_eta_lcr[0]	{LNXT:12|13|-1}
(*) UNDEF
083E4B69  0F BF 05 CC CC CC CC          movsx eax, word ptr [CCCCCCCCH] ; $$DATA$$+12

#40			AND		16#20	{LNXT:12|13|-1}
(*) INT
083E4B70  25 20 00 00 00                and eax, 00000020H

#41			to_bool	{LNXT:12|13|-1}
(*) INT
083E4B75  66 85 C0                      test ax, ax
083E4B78  0F 95 C0                      setne al

#42			ST		ATS22_DUT.LI3	{LNXT:12|13|-1}
(*) BOOL
083E4B7B  84 C0                         test al, al
083E4B7D  0F 95 05 CC CC CC CC          setne [CCCCCCCCH] ; $$DATA$$+30

#43		
#44			(* ATS22_DUT.LI2 		:= to_bool(resp_eta_lcr[0] And 16#40); *)
#45			LD		resp_eta_lcr[0]	{LNXT:13|14|-1}
(*) UNDEF
083E4B84  0F BF 05 CC CC CC CC          movsx eax, word ptr [CCCCCCCCH] ; $$DATA$$+12

#46			AND		16#40	{LNXT:13|14|-1}
(*) INT
083E4B8B  25 40 00 00 00                and eax, 00000040H

#47			to_bool	{LNXT:13|14|-1}
(*) INT
083E4B90  66 85 C0                      test ax, ax
083E4B93  0F 95 C0                      setne al

#48			ST		ATS22_DUT.LI2	{LNXT:13|14|-1}
(*) BOOL
083E4B96  84 C0                         test al, al
083E4B98  0F 95 05 CC CC CC CC          setne [CCCCCCCCH] ; $$DATA$$+31

#49		
#50			(* ATS22_DUT.LI1 		:= to_bool(resp_eta_lcr[0] And 16#80); *)
#51			LD		resp_eta_lcr[0]	{LNXT:14|17|-1}
(*) UNDEF
083E4B9F  0F BF 05 CC CC CC CC          movsx eax, word ptr [CCCCCCCCH] ; $$DATA$$+12

#52			AND		16#80	{LNXT:14|17|-1}
(*) INT
083E4BA6  25 80 00 00 00                and eax, 00000080H

#53			to_bool	{LNXT:14|17|-1}
(*) INT
083E4BAB  66 85 C0                      test ax, ax
083E4BAE  0F 95 C0                      setne al

#54			ST		ATS22_DUT.LI1	{LNXT:14|17|-1}
(*) BOOL
083E4BB1  84 C0                         test al, al
083E4BB3  0F 95 05 CC CC CC CC          setne [CCCCCCCCH] ; $$DATA$$+32

#55		
#56			(* ATS_State_bits.0 := ATS22_DUT.Ready; *)
#57			MOVE		ATS22_DUT.Ready,ATS_State_bits.0	{LNXT:17|18|-1}
(*) BOOL
083E4BBA  33 C0                         xor eax, eax
083E4BBC  8A 05 CC CC CC CC             mov al, [CCCCCCCCH] ; $$DATA$$+26
083E4BC2  84 C0                         test al, al
083E4BC4  90 75 11 90 90 90             jne 00000014H@
083E4BCA  66 0F BA 35 CC CC CC CC 00    btr word ptr [CCCCCCCCH], 0 ; %M110+16
083E4BD3  EB 0C 90 90 90                jmp 0000000EH@
083E4BD8  66 0F BA 2D CC CC CC CC 00    bts word ptr [CCCCCCCCH], 0 ; %M110+16

#58		
#59			(* ATS_State_bits.1 := ATS22_DUT.On And i_run_ats; *)
#60			LD		ATS22_DUT.On	{LNXT:18|19|-1}
(*) UNDEF
083E4BE1  33 C0                         xor eax, eax
083E4BE3  8A 05 CC CC CC CC             mov al, [CCCCCCCCH] ; $$DATA$$+27

#61			AND		i_run_ats	{LNXT:18|19|-1}
(*) BOOL
083E4BE9  33 C9                         xor ecx, ecx
083E4BEB  8A 0D CC CC CC CC             mov cl, [CCCCCCCCH] ; $$DATA$$+52
083E4BF1  23 C1                         and eax, ecx

#62			ST		ATS_State_bits.1	{LNXT:18|19|-1}
(*) BOOL
083E4BF3  84 C0                         test al, al
083E4BF5  90 75 11 90 90 90             jne 00000014H@
083E4BFB  66 0F BA 35 CC CC CC CC 01    btr word ptr [CCCCCCCCH], 1 ; %M110+16
083E4C04  EB 0C 90 90 90                jmp 0000000EH@
083E4C09  66 0F BA 2D CC CC CC CC 01    bts word ptr [CCCCCCCCH], 1 ; %M110+16

#63		
#64			(* ATS_State_bits.2 := ATS22_DUT.Trip Or Not i_no_alm_ats ; *)
#65			LD		i_no_alm_ats	{LNXT:19|20|-1}
(*) UNDEF
083E4C12  33 C0                         xor eax, eax
083E4C14  8A 05 CC CC CC CC             mov al, [CCCCCCCCH] ; $$DATA$$+53

#66			NOT	{LNXT:19|20|-1}
(*) BOOL
083E4C1A  84 C0                         test al, al
083E4C1C  0F 94 C0                      sete al

#67			OR		ATS22_DUT.Trip	{LNXT:19|20|-1}
(*) BOOL
083E4C1F  33 C9                         xor ecx, ecx
083E4C21  8A 0D CC CC CC CC             mov cl, [CCCCCCCCH] ; $$DATA$$+28
083E4C27  0B C1                         or eax, ecx

#68			ST		ATS_State_bits.2	{LNXT:19|20|-1}
(*) BOOL
083E4C29  84 C0                         test al, al
083E4C2B  90 75 11 90 90 90             jne 00000014H@
083E4C31  66 0F BA 35 CC CC CC CC 02    btr word ptr [CCCCCCCCH], 2 ; %M110+16
083E4C3A  EB 0C 90 90 90                jmp 0000000EH@
083E4C3F  66 0F BA 2D CC CC CC CC 02    bts word ptr [CCCCCCCCH], 2 ; %M110+16

#69		
#70			(* ATS_State_bits.3 := ATS22_DUT.Warning; *)
#71			MOVE		ATS22_DUT.Warning,ATS_State_bits.3	{LNXT:20|21|-1}
(*) BOOL
083E4C48  33 C0                         xor eax, eax
083E4C4A  8A 05 CC CC CC CC             mov al, [CCCCCCCCH] ; $$DATA$$+29
083E4C50  84 C0                         test al, al
083E4C52  90 75 11 90 90 90             jne 00000014H@
083E4C58  66 0F BA 35 CC CC CC CC 03    btr word ptr [CCCCCCCCH], 3 ; %M110+16
083E4C61  EB 0C 90 90 90                jmp 0000000EH@
083E4C66  66 0F BA 2D CC CC CC CC 03    bts word ptr [CCCCCCCCH], 3 ; %M110+16

#72		
#73			(* ATS_State_bits.4 := ATS22_DUT.Local; *)
#74			MOVE		ATS22_DUT.Local,ATS_State_bits.4	{LNXT:21|22|-1}
(*) BOOL
083E4C6F  33 C0                         xor eax, eax
083E4C71  8A 05 CC CC CC CC             mov al, [CCCCCCCCH] ; $$DATA$$+34
083E4C77  84 C0                         test al, al
083E4C79  90 75 11 90 90 90             jne 00000014H@
083E4C7F  66 0F BA 35 CC CC CC CC 04    btr word ptr [CCCCCCCCH], 4 ; %M110+16
083E4C88  EB 0C 90 90 90                jmp 0000000EH@
083E4C8D  66 0F BA 2D CC CC CC CC 04    bts word ptr [CCCCCCCCH], 4 ; %M110+16

#75		
#76			(* ATS_State_bits.5 := ATS22_DUT.Ramping; *)
#77			MOVE		ATS22_DUT.Ramping,ATS_State_bits.5	{LNXT:22|23|-1}
(*) BOOL
083E4C96  33 C0                         xor eax, eax
083E4C98  8A 05 CC CC CC CC             mov al, [CCCCCCCCH] ; $$DATA$$+35
083E4C9E  84 C0                         test al, al
083E4CA0  90 75 11 90 90 90             jne 00000014H@
083E4CA6  66 0F BA 35 CC CC CC CC 05    btr word ptr [CCCCCCCCH], 5 ; %M110+16
083E4CAF  EB 0C 90 90 90                jmp 0000000EH@
083E4CB4  66 0F BA 2D CC CC CC CC 05    bts word ptr [CCCCCCCCH], 5 ; %M110+16

#78		
#79			(* ATS_State_bits.6 := ATS22_DUT.LI1; *)
#80			MOVE		ATS22_DUT.LI1,ATS_State_bits.6	{LNXT:23|24|-1}
(*) BOOL
083E4CBD  33 C0                         xor eax, eax
083E4CBF  8A 05 CC CC CC CC             mov al, [CCCCCCCCH] ; $$DATA$$+32
083E4CC5  84 C0                         test al, al
083E4CC7  90 75 11 90 90 90             jne 00000014H@
083E4CCD  66 0F BA 35 CC CC CC CC 06    btr word ptr [CCCCCCCCH], 6 ; %M110+16
083E4CD6  EB 0C 90 90 90                jmp 0000000EH@
083E4CDB  66 0F BA 2D CC CC CC CC 06    bts word ptr [CCCCCCCCH], 6 ; %M110+16

#81		
#82			(* ATS_State_bits.7 := ATS22_DUT.LI2; *)
#83			MOVE		ATS22_DUT.LI2,ATS_State_bits.7	{LNXT:24|25|-1}
(*) BOOL
083E4CE4  33 C0                         xor eax, eax
083E4CE6  8A 05 CC CC CC CC             mov al, [CCCCCCCCH] ; $$DATA$$+31
083E4CEC  84 C0                         test al, al
083E4CEE  90 75 11 90 90 90             jne 00000014H@
083E4CF4  66 0F BA 35 CC CC CC CC 07    btr word ptr [CCCCCCCCH], 7 ; %M110+16
083E4CFD  EB 0C 90 90 90                jmp 0000000EH@
083E4D02  66 0F BA 2D CC CC CC CC 07    bts word ptr [CCCCCCCCH], 7 ; %M110+16

#84		
#85			(* ATS_State_bits.8 := ATS22_DUT.LI3; *)
#86			MOVE		ATS22_DUT.LI3,ATS_State_bits.8	{LNXT:25|28|-1}
(*) BOOL
083E4D0B  33 C0                         xor eax, eax
083E4D0D  8A 05 CC CC CC CC             mov al, [CCCCCCCCH] ; $$DATA$$+30
083E4D13  84 C0                         test al, al
083E4D15  90 75 11 90 90 90             jne 00000014H@
083E4D1B  66 0F BA 35 CC CC CC CC 08    btr word ptr [CCCCCCCCH], 8 ; %M110+16
083E4D24  EB 0C 90 90 90                jmp 0000000EH@
083E4D29  66 0F BA 2D CC CC CC CC 08    bts word ptr [CCCCCCCCH], 8 ; %M110+16

#87		
#88			(* ATS_State_bits.9 := i_pb_loc; *)
#89			MOVE		i_pb_loc,ATS_State_bits.9	{LNXT:28|29|-1}
(*) BOOL
083E4D32  0F BF 05 CC CC CC CC          movsx eax, word ptr [CCCCCCCCH] ; $$DATA$$+54
083E4D39  66 85 C0                      test ax, ax
083E4D3C  90 75 11 90 90 90             jne 00000014H@
083E4D42  66 0F BA 35 CC CC CC CC 09    btr word ptr [CCCCCCCCH], 9 ; %M110+16
083E4D4B  EB 0C 90 90 90                jmp 0000000EH@
083E4D50  66 0F BA 2D CC CC CC CC 09    bts word ptr [CCCCCCCCH], 9 ; %M110+16

#90		
#91			(* ATS_State_bits.10 := i_pb_rem; *)
#92			MOVE		i_pb_rem,ATS_State_bits.10	{LNXT:29|31|-1}
(*) INT
083E4D59  0F BF 05 CC CC CC CC          movsx eax, word ptr [CCCCCCCCH] ; $$DATA$$+56
083E4D60  66 85 C0                      test ax, ax
083E4D63  90 75 11 90 90 90             jne 00000014H@
083E4D69  66 0F BA 35 CC CC CC CC 0A    btr word ptr [CCCCCCCCH], 10 ; %M110+16
083E4D72  EB 0C 90 90 90                jmp 0000000EH@
083E4D77  66 0F BA 2D CC CC CC CC 0A    bts word ptr [CCCCCCCCH], 10 ; %M110+16

#93		
#94		
#95			(* IF i_pb_loc AND not i_pb_rem *)
#96			LD		i_pb_rem	{LNXT:31|-1|-1}
(*) UNDEF
083E4D80  0F BF 05 CC CC CC CC          movsx eax, word ptr [CCCCCCCCH] ; $$DATA$$+56

#97			NOT	{LNXT:31|-1|-1}
(*) INT
083E4D87  66 F7 D0                      not ax

#98			AND(		i_pb_loc	{LNXT:31|-1|-1}
(*) INT
083E4D8A  50                            push eax
083E4D8B  0F BF 05 CC CC CC CC          movsx eax, word ptr [CCCCCCCCH] ; $$DATA$$+54

#99			NOT	{LNXT:31|-1|-1}
(*) INT
083E4D92  66 F7 D0                      not ax

#100			)	{LNXT:31|-1|-1}
(*) INT
083E4D95  8B C8                         mov ecx, eax
083E4D97  58                            pop eax
083E4D98  23 C1                         and eax, ecx

#101			JMPCN	$label0	{LNXT:31|32|34}
(-) INT
083E4D9A  66 85 C0                      test ax, ax
083E4D9D  90 74 27 90 90 90             je 083E4DC7H

#102		
#103			(* THEN *)
#104		
#105				(* ATS_State_bits.11 := TRUE; *)
#106				MOVE		TRUE,ATS_State_bits.11	{LNXT:32|34|-1}
(*) INT
083E4DA3  B8 01 00 00 00                mov eax, 01H
083E4DA8  84 C0                         test al, al
083E4DAA  90 75 11 90 90 90             jne 00000014H@
083E4DB0  66 0F BA 35 CC CC CC CC 0B    btr word ptr [CCCCCCCCH], 11 ; %M110+16
083E4DB9  EB 0C 90 90 90                jmp 0000000EH@
083E4DBE  66 0F BA 2D CC CC CC CC 0B    bts word ptr [CCCCCCCCH], 11 ; %M110+16

#107		
#108		$label0:
#109			(* END_IF *)
#110		
#111		
#112			(* IF i_pb_loc AND i_pb_rem *)
#113			LD		i_pb_loc	{LNXT:34|-1|-1}
(*) UNDEF
083E4DC7  0F BF 05 CC CC CC CC          movsx eax, word ptr [CCCCCCCCH] ; $$DATA$$+54

#114			NOT	{LNXT:34|-1|-1}
(*) INT
083E4DCE  66 F7 D0                      not ax

#115			AND		i_pb_rem	{LNXT:34|-1|-1}
(*) INT
083E4DD1  0F BF 0D CC CC CC CC          movsx ecx, word ptr [CCCCCCCCH] ; $$DATA$$+56
083E4DD8  23 C1                         and eax, ecx

#116			JMPCN	$label1	{LNXT:34|35|37}
(-) INT
083E4DDA  66 85 C0                      test ax, ax
083E4DDD  90 74 27 90 90 90             je 083E4E07H

#117		
#118			(* THEN *)
#119		
#120				(* ATS_State_bits.11 := FALSE; *)
#121				MOVE		FALSE,ATS_State_bits.11	{LNXT:35|37|-1}
(*) INT
083E4DE3  B8 00 00 00 00                mov eax, 00H
083E4DE8  84 C0                         test al, al
083E4DEA  90 75 11 90 90 90             jne 00000014H@
083E4DF0  66 0F BA 35 CC CC CC CC 0B    btr word ptr [CCCCCCCCH], 11 ; %M110+16
083E4DF9  EB 0C 90 90 90                jmp 0000000EH@
083E4DFE  66 0F BA 2D CC CC CC CC 0B    bts word ptr [CCCCCCCCH], 11 ; %M110+16

#122		
#123		$label1:
#124			(* END_IF *)
#125		
#126		
#127			(* IF i_pb_loc AND not i_pb_rem *)
#128			LD		i_pb_rem	{LNXT:37|-1|-1}
(*) UNDEF
083E4E07  0F BF 05 CC CC CC CC          movsx eax, word ptr [CCCCCCCCH] ; $$DATA$$+56

#129			NOT	{LNXT:37|-1|-1}
(*) INT
083E4E0E  66 F7 D0                      not ax

#130			AND		i_pb_loc	{LNXT:37|-1|-1}
(*) INT
083E4E11  0F BF 0D CC CC CC CC          movsx ecx, word ptr [CCCCCCCCH] ; $$DATA$$+54
083E4E18  23 C1                         and eax, ecx

#131			JMPCN	$label2	{LNXT:37|38|43}
(-) INT
083E4E1A  66 85 C0                      test ax, ax
083E4E1D  90 74 27 90 90 90             je 083E4E47H

#132		
#133			(* THEN *)
#134		
#135				(* ATS_State_bits.11 := FALSE; *)
#136				MOVE		FALSE,ATS_State_bits.11	{LNXT:38|43|-1}
(*) INT
083E4E23  B8 00 00 00 00                mov eax, 00H
083E4E28  84 C0                         test al, al
083E4E2A  90 75 11 90 90 90             jne 00000014H@
083E4E30  66 0F BA 35 CC CC CC CC 0B    btr word ptr [CCCCCCCCH], 11 ; %M110+16
083E4E39  EB 0C 90 90 90                jmp 0000000EH@
083E4E3E  66 0F BA 2D CC CC CC CC 0B    bts word ptr [CCCCCCCCH], 11 ; %M110+16

#137		
#138		$label2:
#139			(* END_IF *)
#140		
#141			(* ATS22_DUT.EtaCurrent := to_byte(SHR(resp_eta_lcr[0] AND 16#3F00, 16#08) * 200 / 63); *)
#142			LD		resp_eta_lcr[0]	{LNXT:43|44|-1}
(*) UNDEF
083E4E47  0F BF 05 CC CC CC CC          movsx eax, word ptr [CCCCCCCCH] ; $$DATA$$+12

#143			AND		16#3F00	{LNXT:43|44|-1}
(*) INT
083E4E4E  25 00 3F 00 00                and eax, 00003F00H

#144			SHR		16#08	{LNXT:43|44|-1}
(*) INT
083E4E53  C1 E8 08                      shr eax, 8

#145			MUL		200	{LNXT:43|44|-1}
(*) DINT
083E4E56  B9 C8 00 00 00                mov ecx, 200
083E4E5B  F7 E9                         imul ecx

#146			DIV		63	{LNXT:43|44|-1}
(*) DINT
083E4E5D  99                            cdq
083E4E5E  B9 3F 00 00 00                mov ecx, 63
083E4E63  F7 F9                         idiv ecx

#147			to_byte	{LNXT:43|44|-1}
(*) DINT
#148			ST		ATS22_DUT.EtaCurrent	{LNXT:43|44|-1}
(*) BYTE
083E4E65  88 05 CC CC CC CC             mov [CCCCCCCCH], al ; $$DATA$$+33

#149		
#150			(* ATS_Current_prsnt	 := ATS22_DUT.EtaCurrent; *)
#151			MOVE		ATS22_DUT.EtaCurrent,ATS_Current_prsnt	{LNXT:44|46|-1}
(*) BYTE
083E4E6B  33 C0                         xor eax, eax
083E4E6D  8A 05 CC CC CC CC             mov al, [CCCCCCCCH] ; $$DATA$$+33
083E4E73  66 89 05 CC CC CC CC          mov [CCCCCCCCH], ax ; %M110+18

#152		
#153			(* ATS22_DUT.Local 	:= to_bool(resp_eta_lcr[0] And 16#4000); *)
#154			LD		resp_eta_lcr[0]	{LNXT:46|47|-1}
(*) UNDEF
083E4E7A  0F BF 05 CC CC CC CC          movsx eax, word ptr [CCCCCCCCH] ; $$DATA$$+12

#155			AND		16#4000	{LNXT:46|47|-1}
(*) INT
083E4E81  25 00 40 00 00                and eax, 00004000H

#156			to_bool	{LNXT:46|47|-1}
(*) INT
083E4E86  66 85 C0                      test ax, ax
083E4E89  0F 95 C0                      setne al

#157			ST		ATS22_DUT.Local	{LNXT:46|47|-1}
(*) BOOL
083E4E8C  84 C0                         test al, al
083E4E8E  0F 95 05 CC CC CC CC          setne [CCCCCCCCH] ; $$DATA$$+34

#158		
#159			(* ATS22_DUT.Ramping 	:= to_bool(resp_eta_lcr[0] And 16#8000); *)
#160			LD		resp_eta_lcr[0]	{LNXT:47|49|-1}
(*) UNDEF
083E4E95  0F BF 05 CC CC CC CC          movsx eax, word ptr [CCCCCCCCH] ; $$DATA$$+12

#161			AND		16#8000	{LNXT:47|49|-1}
(*) INT
083E4E9C  25 00 80 00 00                and eax, 00008000H

#162			to_bool	{LNXT:47|49|-1}
(*) INT
083E4EA1  66 85 C0                      test ax, ax
083E4EA4  0F 95 C0                      setne al

#163			ST		ATS22_DUT.Ramping	{LNXT:47|49|-1}
(*) BOOL
083E4EA7  84 C0                         test al, al
083E4EA9  0F 95 05 CC CC CC CC          setne [CCCCCCCCH] ; $$DATA$$+35

#164		
#165			(* ATS22_DUT.Lcr1 := resp_eta_lcr[1]; *)
#166			MOVE		resp_eta_lcr[1],ATS22_DUT.Lcr1	{LNXT:49|50|-1}
(*) BOOL
083E4EB0  0F BF 05 CC CC CC CC          movsx eax, word ptr [CCCCCCCCH] ; $$DATA$$+14
083E4EB7  66 89 05 CC CC CC CC          mov [CCCCCCCCH], ax ; $$DATA$$+36

#167		
#168			(* ATS22_DUT.Lcr2 := resp_eta_lcr[2]; *)
#169			MOVE		resp_eta_lcr[2],ATS22_DUT.Lcr2	{LNXT:50|51|-1}
(*) INT
083E4EBE  0F BF 05 CC CC CC CC          movsx eax, word ptr [CCCCCCCCH] ; $$DATA$$+16
083E4EC5  66 89 05 CC CC CC CC          mov [CCCCCCCCH], ax ; $$DATA$$+38

#170		
#171			(* ATS22_DUT.Lcr3 := resp_eta_lcr[3]; *)
#172			MOVE		resp_eta_lcr[3],ATS22_DUT.Lcr3	{LNXT:51|53|-1}
(*) INT
083E4ECC  0F BF 05 CC CC CC CC          movsx eax, word ptr [CCCCCCCCH] ; $$DATA$$+18
083E4ED3  66 89 05 CC CC CC CC          mov [CCCCCCCCH], ax ; $$DATA$$+40

#173		
#174			(* ATS_Current_L1 := ATS22_DUT.Lcr1; *)
#175			MOVE		ATS22_DUT.Lcr1,ATS_Current_L1	{LNXT:53|54|-1}
(*) INT
083E4EDA  0F BF 05 CC CC CC CC          movsx eax, word ptr [CCCCCCCCH] ; $$DATA$$+36
083E4EE1  66 89 05 CC CC CC CC          mov [CCCCCCCCH], ax ; %M110+20

#176		
#177			(* ATS_Current_L2 := ATS22_DUT.Lcr2; *)
#178			MOVE		ATS22_DUT.Lcr2,ATS_Current_L2	{LNXT:54|55|-1}
(*) INT
083E4EE8  0F BF 05 CC CC CC CC          movsx eax, word ptr [CCCCCCCCH] ; $$DATA$$+38
083E4EEF  66 89 05 CC CC CC CC          mov [CCCCCCCCH], ax ; %M110+22

#179		
#180			(* ATS_Current_L3 := ATS22_DUT.Lcr3; *)
#181			MOVE		ATS22_DUT.Lcr3,ATS_Current_L3	{LNXT:55|57|-1}
(*) INT
083E4EF6  0F BF 05 CC CC CC CC          movsx eax, word ptr [CCCCCCCCH] ; $$DATA$$+40
083E4EFD  66 89 05 CC CC CC CC          mov [CCCCCCCCH], ax ; %M110+24

#182		
#183			(* res := sysMbMRTU_FC03(	addr := 1, 
#184											base := 261, // 260
#185											no := 1, 
#186											object := ADR(resp_eta_lcr), 
#187											timeout := 200); *)
#188			ADR		resp_eta_lcr	{LNXT:57|63|-1}
(*) INT
083E4F04  B8 CC CC CC CC                mov eax, CCCCCCCCH ; $$DATA$$+12

#189			ST		$$TMP0	{LNXT:57|63|-1}
(*) @INT
083E4F09  89 05 CC CC CC CC             mov [CCCCCCCCH], eax ; $$DATA$$+20

#190			LDP0		1	{LNXT:57|63|-1}
(*) @INT
#191			sysMbMRTU_FC03		261, 1, $$TMP0, 200	{LNXT:57|63|-1}
(*) @INT
083E4F0F  68 C8 00 00 00                push 200
083E4F14  FF 35 CC CC CC CC             push [CCCCCCCCH] ; $$DATA$$+20
083E4F1A  68 01 00 00 00                push 1
083E4F1F  68 05 01 00 00                push 261
083E4F24  68 01 00 00 00                push 1
083E4F29  B9 CC CC CC CC                mov ecx, CCCCCCCCH ; sysMbMRTU_FC03
083E4F2E  FF D1                         call ecx
083E4F30  81 C4 14 00 00 00             add esp, 20

#192			ST		res	{LNXT:57|63|-1}
(*) UINT
083E4F36  66 89 05 CC CC CC CC          mov [CCCCCCCCH], ax ; $$DATA$$+24

#193		
#194			(* ATS22_DUT.LcrVoltage	:= resp_eta_lcr[0]; *)
#195			MOVE		resp_eta_lcr[0],ATS22_DUT.LcrVoltage	{LNXT:63|64|-1}
(*) UINT
083E4F3D  0F BF 05 CC CC CC CC          movsx eax, word ptr [CCCCCCCCH] ; $$DATA$$+12
083E4F44  66 89 05 CC CC CC CC          mov [CCCCCCCCH], ax ; $$DATA$$+42

#196		
#197			(* ATS_Voltage := ATS22_DUT.LcrVoltage; *)
#198			MOVE		ATS22_DUT.LcrVoltage,ATS_Voltage	{LNXT:64|68|-1}
(*) INT
083E4F4B  0F BF 05 CC CC CC CC          movsx eax, word ptr [CCCCCCCCH] ; $$DATA$$+42
083E4F52  66 89 05 CC CC CC CC          mov [CCCCCCCCH], ax ; %M110+36

#199		
#200			(* res := sysMbMRTU_FC03(	addr := 1, 
#201											base := 280, // 279
#202											no := 1, 
#203											object := ADR(resp_eta_lcr), 
#204											timeout := 200); *)
#205			ADR		resp_eta_lcr	{LNXT:68|74|-1}
(*) INT
083E4F59  B8 CC CC CC CC                mov eax, CCCCCCCCH ; $$DATA$$+12

#206			ST		$$TMP0	{LNXT:68|74|-1}
(*) @INT
083E4F5E  89 05 CC CC CC CC             mov [CCCCCCCCH], eax ; $$DATA$$+20

#207			LDP0		1	{LNXT:68|74|-1}
(*) @INT
#208			sysMbMRTU_FC03		280, 1, $$TMP0, 200	{LNXT:68|74|-1}
(*) @INT
083E4F64  68 C8 00 00 00                push 200
083E4F69  FF 35 CC CC CC CC             push [CCCCCCCCH] ; $$DATA$$+20
083E4F6F  68 01 00 00 00                push 1
083E4F74  68 18 01 00 00                push 280
083E4F79  68 01 00 00 00                push 1
083E4F7E  B9 CC CC CC CC                mov ecx, CCCCCCCCH ; sysMbMRTU_FC03
083E4F83  FF D1                         call ecx
083E4F85  81 C4 14 00 00 00             add esp, 20

#209			ST		res	{LNXT:68|74|-1}
(*) UINT
083E4F8B  66 89 05 CC CC CC CC          mov [CCCCCCCCH], ax ; $$DATA$$+24

#210		
#211			(* ATS22_DUT.LastFLT 	:= resp_eta_lcr[0]; *)
#212			MOVE		resp_eta_lcr[0],ATS22_DUT.LastFLT	{LNXT:74|75|-1}
(*) UINT
083E4F92  0F BF 05 CC CC CC CC          movsx eax, word ptr [CCCCCCCCH] ; $$DATA$$+12
083E4F99  66 89 05 CC CC CC CC          mov [CCCCCCCCH], ax ; $$DATA$$+44

#213		
#214			(* ATS_Last_FaultCode := ATS22_DUT.LastFLT; *)
#215			MOVE		ATS22_DUT.LastFLT,ATS_Last_FaultCode	{LNXT:75|78|-1}
(*) INT
083E4FA0  0F BF 05 CC CC CC CC          movsx eax, word ptr [CCCCCCCCH] ; $$DATA$$+44
083E4FA7  66 89 05 CC CC CC CC          mov [CCCCCCCCH], ax ; %M110+26

#216		
#217			(* res := sysMbMRTU_FC03(	addr := 1, 
#218											base := 274, // 273
#219											no := 3, 
#220											object := ADR(resp_eta_lcr), 
#221											timeout := 200); *)
#222			ADR		resp_eta_lcr	{LNXT:78|84|-1}
(*) INT
083E4FAE  B8 CC CC CC CC                mov eax, CCCCCCCCH ; $$DATA$$+12

#223			ST		$$TMP0	{LNXT:78|84|-1}
(*) @INT
083E4FB3  89 05 CC CC CC CC             mov [CCCCCCCCH], eax ; $$DATA$$+20

#224			LDP0		1	{LNXT:78|84|-1}
(*) @INT
#225			sysMbMRTU_FC03		274, 3, $$TMP0, 200	{LNXT:78|84|-1}
(*) @INT
083E4FB9  68 C8 00 00 00                push 200
083E4FBE  FF 35 CC CC CC CC             push [CCCCCCCCH] ; $$DATA$$+20
083E4FC4  68 03 00 00 00                push 3
083E4FC9  68 12 01 00 00                push 274
083E4FCE  68 01 00 00 00                push 1
083E4FD3  B9 CC CC CC CC                mov ecx, CCCCCCCCH ; sysMbMRTU_FC03
083E4FD8  FF D1                         call ecx
083E4FDA  81 C4 14 00 00 00             add esp, 20

#226			ST		res	{LNXT:78|84|-1}
(*) UINT
083E4FE0  66 89 05 CC CC CC CC          mov [CCCCCCCCH], ax ; $$DATA$$+24

#227		
#228		
#229			(* IF res <> 0 *)
#230			LD		res	{LNXT:84|-1|-1}
(*) UNDEF
083E4FE7  0F BF 05 CC CC CC CC          movsx eax, word ptr [CCCCCCCCH] ; $$DATA$$+24

#231			NE		0	{LNXT:84|-1|-1}
(*) INT
083E4FEE  3D 00 00 00 00                cmp eax, 0
083E4FF3  0F 95 C0                      setne al
083E4FF6  25 FF 00 00 00                and eax, 0FFh

#232			JMPCN	$label3	{LNXT:84|84|86}
(-) BOOL
083E4FFB  84 C0                         test al, al
083E4FFD  90 74 27 90 90 90             je 083E5027H

#233		
#234			(* THEN *)
#235		
#236				(* Alarms.6 := true; *)
#237				MOVE		true,Alarms.6	{LNXT:84|86|-1}
(*) BOOL
083E5003  B8 01 00 00 00                mov eax, 01H
083E5008  84 C0                         test al, al
083E500A  90 75 11 90 90 90             jne 00000014H@
083E5010  66 0F BA 35 CC CC CC CC 06    btr word ptr [CCCCCCCCH], 6 ; %M110+32
083E5019  EB 0C 90 90 90                jmp 0000000EH@
083E501E  66 0F BA 2D CC CC CC CC 06    bts word ptr [CCCCCCCCH], 6 ; %M110+32

#238		
#239		$label3:
#240			(* END_IF *)
#241		
#242			(* ATS22_DUT.MotRunTime 		:= resp_eta_lcr[0]; *)
#243			MOVE		resp_eta_lcr[0],ATS22_DUT.MotRunTime	{LNXT:86|87|-1}
(*) WORD
083E5027  0F BF 05 CC CC CC CC          movsx eax, word ptr [CCCCCCCCH] ; $$DATA$$+12
083E502E  66 89 05 CC CC CC CC          mov [CCCCCCCCH], ax ; $$DATA$$+46

#244		
#245			(* ATS22_DUT.MotStartCnt 		:= resp_eta_lcr[1]; *)
#246			MOVE		resp_eta_lcr[1],ATS22_DUT.MotStartCnt	{LNXT:87|88|-1}
(*) INT
083E5035  0F BF 05 CC CC CC CC          movsx eax, word ptr [CCCCCCCCH] ; $$DATA$$+14
083E503C  66 89 05 CC CC CC CC          mov [CCCCCCCCH], ax ; $$DATA$$+48

#247		
#248			(* ATS22_DUT.MotLastStartTime 	:= resp_eta_lcr[2]; *)
#249			MOVE		resp_eta_lcr[2],ATS22_DUT.MotLastStartTime	{LNXT:88|90|-1}
(*) INT
083E5043  0F BF 05 CC CC CC CC          movsx eax, word ptr [CCCCCCCCH] ; $$DATA$$+16
083E504A  66 89 05 CC CC CC CC          mov [CCCCCCCCH], ax ; $$DATA$$+50

#250		
#251			(* ATS_RunTime_Hors	:= to_word(ATS22_DUT.MotRunTime); *)
#252			LDP0		ATS22_DUT.MotRunTime	{LNXT:90|91|-1}
(*) INT
#253			to_word	{LNXT:90|91|-1}
(*) INT
083E5051  0F BF 05 CC CC CC CC          movsx eax, word ptr [CCCCCCCCH] ; $$DATA$$+46

#254			ST		ATS_RunTime_Hors	{LNXT:90|91|-1}
(*) WORD
083E5058  66 89 05 CC CC CC CC          mov [CCCCCCCCH], ax ; %M110+28

#255		
#256			(* ATS_OnTimes_Cnt		:= to_word(ATS22_DUT.MotStartCnt); *)
#257			LDP0		ATS22_DUT.MotStartCnt	{LNXT:91|2|-1}
(*) WORD
#258			to_word	{LNXT:91|2|-1}
(*) WORD
083E505F  0F BF 05 CC CC CC CC          movsx eax, word ptr [CCCCCCCCH] ; $$DATA$$+48

#259			ST		ATS_OnTimes_Cnt	{LNXT:91|2|-1}
(*) WORD
083E5066  66 89 05 CC CC CC CC          mov [CCCCCCCCH], ax ; %M110+30

083E506D  61                            popad
083E506E  5D                            pop ebp

083E506F  C3                            ret

END_PROGRAM


**************************************************
	Target variable image generation
**************************************************


*** INPUT:
083E5070  55                            push ebp
083E5071  8B EC                         mov ebp, esp

083E5073  8A 0D CC CC CC CC             mov cl, [CCCCCCCCH] ; %I0+7
083E5079  88 0D CC CC CC CC             mov [CCCCCCCCH], cl ; $$DATA$$+52

083E507F  8A 0D CC CC CC CC             mov cl, [CCCCCCCCH] ; %I0+6
083E5085  88 0D CC CC CC CC             mov [CCCCCCCCH], cl ; $$DATA$$+53

083E508B  66 8B 0D CC CC CC CC          mov cx, [CCCCCCCCH] ; %I1+12
083E5092  66 89 0D CC CC CC CC          mov [CCCCCCCCH], cx ; $$DATA$$+54

083E5099  66 8B 0D CC CC CC CC          mov cx, [CCCCCCCCH] ; %I1+14
083E50A0  66 89 0D CC CC CC CC          mov [CCCCCCCCH], cx ; $$DATA$$+56

083E50A7  8B E5                         mov esp, ebp
083E50A9  5D                            pop ebp

083E50AA  C3                            ret


*** OUTPUT:
083E50AB  55                            push ebp
083E50AC  8B EC                         mov ebp, esp

083E50AE  8B E5                         mov esp, ebp
083E50B0  5D                            pop ebp

083E50B1  C3                            ret



**************************************************
	Task Background init code
**************************************************

083E50B2  55                            push ebp
083E50B3  8B EC                         mov ebp, esp

083E50B5  8B E5                         mov esp, ebp
083E50B7  5D                            pop ebp

083E50B8  C3                            ret

**************************************************
	List program: sr_init_counters
**************************************************

PROGRAM sr_init_counters

END_PROGRAM

083E50D0  55                            push ebp
083E50D1  8B EC                         mov ebp, esp
083E50D3  60                            pushad

#0		{SRC:sr_init_counters}
#1		(*$WAITSWITCH$*)
#2		
#3			(* kw_counter 	:= epprom_kw_cnt; *)
#4			MOVE		epprom_kw_cnt,kw_counter	{LNXT:1|2|-1}
(*) UDINT
083E50D4  8B 05 CC CC CC CC             mov eax, [CCCCCCCCH] ; %M101+8
083E50DA  89 05 CC CC CC CC             mov [CCCCCCCCH], eax ; %M110+4

#5		
#6			(* q_counter	:= epprom_q_cnt; *)
#7			MOVE		epprom_q_cnt,q_counter	{LNXT:2|1|-1}
(*) DWORD
083E50E0  8B 05 CC CC CC CC             mov eax, [CCCCCCCCH] ; %M101+0
083E50E6  89 05 CC CC CC CC             mov [CCCCCCCCH], eax ; %M110+8

083E50EC  61                            popad
083E50ED  5D                            pop ebp

083E50EE  C3                            ret

END_PROGRAM


**************************************************
	Target variable image generation
**************************************************


*** INPUT:
083E50EF  C3                            ret


*** OUTPUT:
083E50F0  C3                            ret



**************************************************
	Task Boot init code
**************************************************

083E50F1  55                            push ebp
083E50F2  8B EC                         mov ebp, esp

083E50F4  8B E5                         mov esp, ebp
083E50F6  5D                            pop ebp

083E50F7  C3                            ret

**************************************************
	List program: init_val
**************************************************

PROGRAM init_val

END_PROGRAM

083E5110  55                            push ebp
083E5111  8B EC                         mov ebp, esp
083E5113  60                            pushad

#0		{SRC:init_val}
#1		(*$WAITSWITCH$*)
#2		
#3		
#4			(* IF di_val_close_state_R *)
#5			LD		di_val_close_state_R	{LNXT:1|-1|-1}
(*) UNDEF
083E5114  33 C0                         xor eax, eax
083E5116  8A 05 CC CC CC CC             mov al, [CCCCCCCCH] ; %I0+0

#6			NOT	{LNXT:1|-1|-1}
(*) BOOL
083E511C  84 C0                         test al, al
083E511E  0F 94 C0                      sete al

#7			JMPCN	$label0	{LNXT:1|2|6}
(-) BOOL
083E5121  84 C0                         test al, al
083E5123  90 74 1F 90 90 90             je 083E5145H

#8		
#9			(* THEN *)
#10		
#11				(* o_val_close_R:=true; *)
#12				MOVE		true,o_val_close_R	{LNXT:2|3|-1}
(*) BOOL
083E5129  B8 01 00 00 00                mov eax, 01H
083E512E  84 C0                         test al, al
083E5130  0F 95 05 CC CC CC CC          setne [CCCCCCCCH] ; %Q1+3

#13		
#14				(* o_val_open_R:=false; *)
#15				MOVE		false,o_val_open_R	{LNXT:3|6|-1}
(*) BOOL
083E5137  B8 00 00 00 00                mov eax, 00H
083E513C  84 C0                         test al, al
083E513E  0F 95 05 CC CC CC CC          setne [CCCCCCCCH] ; %Q1+2

#16		
#17		$label0:
#18			(* END_IF *)
#19		
#20		
#21			(* IF di_val_close_state_fall = 0 *)
#22			LD		di_val_close_state_fall	{LNXT:6|-1|-1}
(*) UNDEF
083E5145  0F BF 05 CC CC CC CC          movsx eax, word ptr [CCCCCCCCH] ; %I1+8

#23			EQ		0	{LNXT:6|-1|-1}
(*) INT
083E514C  3D 00 00 00 00                cmp eax, 0
083E5151  0F 94 C0                      sete al
083E5154  25 FF 00 00 00                and eax, 0FFh

#24			JMPCN	$label1	{LNXT:6|7|1}
(-) BOOL
083E5159  84 C0                         test al, al
083E515B  90 74 1F 90 90 90             je 083E517DH

#25		
#26			(* THEN *)
#27		
#28				(* o_val_close_fall:=true; *)
#29				MOVE		true,o_val_close_fall	{LNXT:7|8|-1}
(*) BOOL
083E5161  B8 01 00 00 00                mov eax, 01H
083E5166  84 C0                         test al, al
083E5168  0F 95 05 CC CC CC CC          setne [CCCCCCCCH] ; %Q1+1

#30		
#31				(* o_val_open_fall:=false; *)
#32				MOVE		false,o_val_open_fall	{LNXT:8|1|-1}
(*) BOOL
083E516F  B8 00 00 00 00                mov eax, 00H
083E5174  84 C0                         test al, al
083E5176  0F 95 05 CC CC CC CC          setne [CCCCCCCCH] ; %Q1+0

083E517D  61                            popad
083E517E  5D                            pop ebp

083E517F  C3                            ret

END_PROGRAM


**************************************************
	Target variable image generation
**************************************************


*** INPUT:
083E5180  C3                            ret


*** OUTPUT:
083E5181  C3                            ret



**************************************************
	Task Init init code
**************************************************

083E5182  55                            push ebp
083E5183  8B EC                         mov ebp, esp

083E5185  8B E5                         mov esp, ebp
083E5187  5D                            pop ebp

083E5188  C3                            ret

**************************************************
	List program: InitParDB
**************************************************

PROGRAM InitParDB

        VAR
warningsKiller : USINT;
dummyCrc32 : UDINT;
	END_VAR

END_PROGRAM

083E51A0  55                            push ebp
083E51A1  8B EC                         mov ebp, esp
083E51A3  60                            pushad

#0		{SRC:InitParDB}
#1		(*$WAITSWITCH$*)
#2		
#3			(* dummyCrc32 := 541599759; *)
#4			MOVE		541599759,dummyCrc32	{LNXT:3|5|-1}
(*) UDINT
083E51A4  B8 0F 28 48 20                mov eax, 2048280FH
083E51A9  89 05 CC CC CC CC             mov [CCCCCCCCH], eax ; $$DATA$$+60

#5		
#6			(* warningsKiller := sysDBase_SetExtTable( ADR( $$ParDB ), $$ParDBLength ); *)
#7			ADR		$$ParDB	{LNXT:5|3|-1}
(*) UDINT
083E51AF  B8 CC CC CC CC                mov eax, CCCCCCCCH ; $$CODE$$+336

#8			sysDBase_SetExtTable		$$ParDBLength	{LNXT:5|3|-1}
(*) @USINT
083E51B4  68 16 00 00 00                push 22
083E51B9  8B C8                         mov ecx, eax
083E51BB  51                            push ecx
083E51BC  B9 CC CC CC CC                mov ecx, CCCCCCCCH ; sysDBase_SetExtTable
083E51C1  FF D1                         call ecx
083E51C3  81 C4 08 00 00 00             add esp, 8

#9			ST		warningsKiller	{LNXT:5|3|-1}
(*) USINT
083E51C9  88 05 CC CC CC CC             mov [CCCCCCCCH], al ; $$DATA$$+59

083E51CF  61                            popad
083E51D0  5D                            pop ebp

083E51D1  C3                            ret

END_PROGRAM


**************************************************
	Target variable image generation
**************************************************


*** INPUT:
083E51D2  C3                            ret


*** OUTPUT:
083E51D3  C3                            ret



**************************************************
	Task Serv init code
**************************************************

083E51D4  55                            push ebp
083E51D5  8B EC                         mov ebp, esp

083E51D7  8B E5                         mov esp, ebp
083E51D9  5D                            pop ebp

083E51DA  C3                            ret

**************************************************
	List program: sr_pressure
**************************************************

PROGRAM sr_pressure

        VAR
tmp_test : INT;
	END_VAR

END_PROGRAM

083E51F0  55                            push ebp
083E51F1  8B EC                         mov ebp, esp
083E51F3  60                            pushad

#0		{SRC:sr_pressure}
#1		(*$WAITSWITCH$*)
#2		
#3			(* Pressure := to_int(to_real(i_adc_pressure )/10); *)
#4			LDP0		i_adc_pressure	{LNXT:2|2|-1}
(*) UDINT
#5			to_real	{LNXT:2|2|-1}
(*) UDINT
083E51F4  0F BF 05 CC CC CC CC          movsx eax, word ptr [CCCCCCCCH] ; $$DATA$$+270
083E51FB  50                            push eax
083E51FC  DB 04 24                      fild dword ptr [esp]
083E51FF  58                            pop eax

#6			DIV		10	{LNXT:2|2|-1}
(*) REAL
083E5200  68 0A 00 00 00                push 10
083E5205  DA 34 24                      fidiv [esp]
083E5208  81 C4 04 00 00 00             add esp, 4

#7			to_int	{LNXT:2|2|-1}
(*) REAL
083E520E  81 EC 08 00 00 00             sub esp, 8
083E5214  DF 3C 24                      fistp qword ptr [esp]
083E5217  58                            pop eax
083E5218  81 C4 04 00 00 00             add esp, 4

#8			ST		Pressure	{LNXT:2|2|-1}
(*) INT
083E521E  66 89 05 CC CC CC CC          mov [CCCCCCCCH], ax ; %M110+0

END_PROGRAM
**************************************************
	List program: sr_counters
**************************************************

PROGRAM sr_counters

        VAR
kw_trig : R_TRIG;
q_trig : R_TRIG;
kw_pulses_per_acs : UINT;
q_pulses_per_acs : UINT;
test_freq : UDINT;
	END_VAR

END_PROGRAM

#0		{SRC:sr_counters}
#1		(*$WAITSWITCH$*)
#2		
#3			(* kw_pulses_per_acs 	:= 8000; *)
#4			MOVE		8000,kw_pulses_per_acs	{LNXT:2|3|-1}
(*) UDINT
083E5225  B8 40 1F 00 00                mov eax, 1F40H
083E522A  66 89 05 CC CC CC CC          mov [CCCCCCCCH], ax ; $$DATA$$+266

#5		
#6			(* q_pulses_per_acs	:= 1; *)
#7			MOVE		1,q_pulses_per_acs	{LNXT:3|15|-1}
(*) UINT
083E5231  B8 01 00 00 00                mov eax, 01H
083E5236  66 89 05 CC CC CC CC          mov [CCCCCCCCH], ax ; $$DATA$$+268

#8		
#9		
#10			(* IF fdi_q_cnt >= q_pulses_per_acs *)
#11			LD		fdi_q_cnt	{LNXT:15|-1|-1}
(*) UNDEF
083E523D  8B 05 CC CC CC CC             mov eax, [CCCCCCCCH] ; %M500+0

#12			GE		q_pulses_per_acs	{LNXT:15|-1|-1}
(*) UDINT
083E5243  33 C9                         xor ecx, ecx
083E5245  66 8B 0D CC CC CC CC          mov cx, [CCCCCCCCH] ; $$DATA$$+268
083E524C  3B C1                         cmp eax, ecx
083E524E  0F 93 C0                      setae al
083E5251  25 FF 00 00 00                and eax, 0FFh

#13			JMPCN	$label0	{LNXT:15|16|20}
(-) BOOL
083E5256  84 C0                         test al, al
083E5258  90 74 22 90 90 90             je 083E527DH

#14		
#15			(* THEN *)
#16		
#17				(* q_counter := q_counter + 1; *)
#18				LD		q_counter	{LNXT:16|17|-1}
(*) UNDEF
083E525E  8B 05 CC CC CC CC             mov eax, [CCCCCCCCH] ; %M110+8

#19				ADD		1	{LNXT:16|17|-1}
(*) DWORD
083E5264  05 01 00 00 00                add eax, 1

#20				ST		q_counter	{LNXT:16|17|-1}
(*) DWORD
083E5269  89 05 CC CC CC CC             mov [CCCCCCCCH], eax ; %M110+8

#21		
#22				(* fdi_q_reset := true; *)
#23				MOVE		true,fdi_q_reset	{LNXT:17|20|-1}
(*) DWORD
083E526F  B8 01 00 00 00                mov eax, 01H
083E5274  84 C0                         test al, al
083E5276  0F 95 05 CC CC CC CC          setne [CCCCCCCCH] ; %M550+0

#24		
#25		$label0:
#26			(* END_IF *)
#27		
#28			(* q_value := to_int((3600 * to_real(fdi_q_freq)) / (to_real(q_pulses_per_acs) / 1)); *)
#29			LDP0		fdi_q_freq	{LNXT:20|2|-1}
(*) BOOL
#30			to_real	{LNXT:20|2|-1}
(*) BOOL
083E527D  8B 05 CC CC CC CC             mov eax, [CCCCCCCCH] ; %M500+4
083E5283  68 00 00 00 00                push 0
083E5288  50                            push eax
083E5289  DF 2C 24                      fild qword ptr [esp]
083E528C  81 C4 08 00 00 00             add esp, 8

#31			MUL		3600	{LNXT:20|2|-1}
(*) REAL
083E5292  68 10 0E 00 00                push 3600
083E5297  DA 0C 24                      fimul [esp]
083E529A  81 C4 04 00 00 00             add esp, 4

#32			DIV(		0	{LNXT:20|2|-1}
(*) REAL
083E52A0  81 EC 04 00 00 00             sub esp, 4
083E52A6  D9 1C 24                      fstp dword ptr [esp]
083E52A9  B8 00 00 00 00                mov eax, 00H

#33			LDP0		q_pulses_per_acs	{LNXT:20|2|-1}
(*) USINT
#34			to_real	{LNXT:20|2|-1}
(*) USINT
083E52AE  33 C0                         xor eax, eax
083E52B0  66 8B 05 CC CC CC CC          mov ax, [CCCCCCCCH] ; $$DATA$$+268
083E52B7  68 00 00 00 00                push 0
083E52BC  50                            push eax
083E52BD  DF 2C 24                      fild qword ptr [esp]
083E52C0  81 C4 08 00 00 00             add esp, 8

#35			DIV		1	{LNXT:20|2|-1}
(*) REAL
083E52C6  68 01 00 00 00                push 1
083E52CB  DA 34 24                      fidiv [esp]
083E52CE  81 C4 04 00 00 00             add esp, 4

#36			)	{LNXT:20|2|-1}
(*) REAL
083E52D4  81 EC 04 00 00 00             sub esp, 4
083E52DA  D9 1C 24                      fstp dword ptr [esp]
083E52DD  D9 44 24 04                   fld dword ptr 4[esp]
083E52E1  D8 34 24                      fdiv dword ptr [esp]
083E52E4  81 C4 08 00 00 00             add esp, 8

#37			to_int	{LNXT:20|2|-1}
(*) REAL
083E52EA  81 EC 08 00 00 00             sub esp, 8
083E52F0  DF 3C 24                      fistp qword ptr [esp]
083E52F3  58                            pop eax
083E52F4  81 C4 04 00 00 00             add esp, 4

#38			ST		q_value	{LNXT:20|2|-1}
(*) INT
083E52FA  66 89 05 CC CC CC CC          mov [CCCCCCCCH], ax ; %M110+14

END_PROGRAM
**************************************************
	List program: sr_save_counters
**************************************************

PROGRAM sr_save_counters

        VAR
power_err : R_TRIG;
ton_start_up : TON;
res_q : BOOL;
res_kw : BOOL;
	END_VAR

END_PROGRAM

#0		{SRC:sr_save_counters}
#1		(*$WAITSWITCH$*)
#2		
#3			(* ton_start_up *)
#4			MOVE		true,ton_start_up.IN	{LNXT:1|-1|-1}
(*) UDINT
083E5301  B8 01 00 00 00                mov eax, 01H
083E5306  84 C0                         test al, al
083E5308  0F 95 05 CC CC CC CC          setne [CCCCCCCCH] ; $$DATA$$+276

#5			MOVE		5000,ton_start_up.PT	{LNXT:1|-1|-1}
(*) BOOL
083E530F  B8 88 13 00 00                mov eax, 1388H
083E5314  89 05 CC CC CC CC             mov [CCCCCCCCH], eax ; $$DATA$$+277

#6			CAL		ton_start_up	{LNXT:1|2|-1}
(*) UDINT
083E531A  50                            push eax
083E531B  BB CC CC CC CC                mov ebx, CCCCCCCCH ; $$DATA$$+272
083E5320  E8 94 F1 FF FF                call 083E44B9H ; $$CODE$$+17593
083E5325  58                            pop eax

#7		
#8			(* power_err *)
#9			LD		ton_start_up.Q	{LNXT:2|-1|-1}
(*) UNDEF
083E5326  33 C0                         xor eax, eax
083E5328  8A 05 CC CC CC CC             mov al, [CCCCCCCCH] ; $$DATA$$+281

#10			AND		i_rnpp	{LNXT:2|-1|-1}
(*) BOOL
083E532E  33 C9                         xor ecx, ecx
083E5330  8A 0D CC CC CC CC             mov cl, [CCCCCCCCH] ; $$DATA$$+263
083E5336  23 C1                         and eax, ecx

#11			ST		power_err.clk	{LNXT:2|-1|-1}
(*) BOOL
083E5338  84 C0                         test al, al
083E533A  0F 95 05 CC CC CC CC          setne [CCCCCCCCH] ; $$DATA$$+295

#12			CAL		power_err	{LNXT:2|3|-1}
(*) BOOL
083E5341  50                            push eax
083E5342  BB CC CC CC CC                mov ebx, CCCCCCCCH ; $$DATA$$+294
083E5347  E8 44 F1 FF FF                call 083E4490H ; $$CODE$$+17552
083E534C  58                            pop eax

#13		
#14		
#15			(* IF power_err.q *)
#16			LD		power_err.q	{LNXT:3|-1|-1}
(*) UNDEF
083E534D  33 C0                         xor eax, eax
083E534F  8A 05 CC CC CC CC             mov al, [CCCCCCCCH] ; $$DATA$$+296

#17			JMPCN	$label0	{LNXT:3|4|1}
(-) BOOL
083E5355  84 C0                         test al, al
083E5357  0F 84 82 00 00 00             je 083E53DFH

#18		
#19			(* THEN *)
#20		
#21		
#22				(* IF epprom_q_cnt <> q_counter *)
#23				LD		epprom_q_cnt	{LNXT:4|-1|-1}
(*) UNDEF
083E535D  8B 05 CC CC CC CC             mov eax, [CCCCCCCCH] ; %M101+0

#24				NE		q_counter	{LNXT:4|-1|-1}
(*) DWORD
083E5363  3B 05 CC CC CC CC             cmp eax, [CCCCCCCCH] ; %M110+8
083E5369  0F 95 C0                      setne al
083E536C  25 FF 00 00 00                and eax, 0FFh

#25				JMPCN	$label1	{LNXT:4|4|5}
(-) BOOL
083E5371  84 C0                         test al, al
083E5373  90 74 28 90 90 90             je 083E539EH

#26		
#27				(* THEN *)
#28		
#29					(* res_q := sysWriteParUINT(ADR(epprom_q_cnt), q_counter); *)
#30					ADR		epprom_q_cnt	{LNXT:4|5|-1}
(*) BOOL
083E5379  B8 CC CC CC CC                mov eax, CCCCCCCCH ; %M101+0

#31					sysWriteParUINT		q_counter	{LNXT:4|5|-1}
(*) @DWORD
083E537E  8B 0D CC CC CC CC             mov ecx, [CCCCCCCCH] ; %M110+8
083E5384  51                            push ecx
083E5385  8B C8                         mov ecx, eax
083E5387  51                            push ecx
083E5388  B9 CC CC CC CC                mov ecx, CCCCCCCCH ; sysWriteParUINT
083E538D  FF D1                         call ecx
083E538F  81 C4 08 00 00 00             add esp, 8

#32					ST		res_q	{LNXT:4|5|-1}
(*) BOOL
083E5395  84 C0                         test al, al
083E5397  0F 95 05 CC CC CC CC          setne [CCCCCCCCH] ; $$DATA$$+265

#33		
#34		$label1:
#35				(* END_IF *)
#36		
#37		
#38				(* IF epprom_kw_cnt <> kw_counter *)
#39				LD		epprom_kw_cnt	{LNXT:5|-1|-1}
(*) UNDEF
083E539E  8B 05 CC CC CC CC             mov eax, [CCCCCCCCH] ; %M101+8

#40				NE		kw_counter	{LNXT:5|-1|-1}
(*) DWORD
083E53A4  3B 05 CC CC CC CC             cmp eax, [CCCCCCCCH] ; %M110+4
083E53AA  0F 95 C0                      setne al
083E53AD  25 FF 00 00 00                and eax, 0FFh

#41				JMPCN	$label2	{LNXT:5|5|1}
(-) BOOL
083E53B2  84 C0                         test al, al
083E53B4  90 74 28 90 90 90             je 083E53DFH

#42		
#43				(* THEN *)
#44		
#45					(* res_kw := sysWriteParUINT(ADR(epprom_kw_cnt), kw_counter); *)
#46					ADR		epprom_kw_cnt	{LNXT:5|1|-1}
(*) BOOL
083E53BA  B8 CC CC CC CC                mov eax, CCCCCCCCH ; %M101+8

#47					sysWriteParUINT		kw_counter	{LNXT:5|1|-1}
(*) @DWORD
083E53BF  8B 0D CC CC CC CC             mov ecx, [CCCCCCCCH] ; %M110+4
083E53C5  51                            push ecx
083E53C6  8B C8                         mov ecx, eax
083E53C8  51                            push ecx
083E53C9  B9 CC CC CC CC                mov ecx, CCCCCCCCH ; sysWriteParUINT
083E53CE  FF D1                         call ecx
083E53D0  81 C4 08 00 00 00             add esp, 8

#48					ST		res_kw	{LNXT:5|1|-1}
(*) BOOL
083E53D6  84 C0                         test al, al
083E53D8  0F 95 05 CC CC CC CC          setne [CCCCCCCCH] ; $$DATA$$+305

END_PROGRAM
**************************************************
	List program: sr_ATS_Ctrl
**************************************************

PROGRAM sr_ATS_Ctrl

        VAR
TON_StartUp_1 : TON;
TON_StartUp_2 : TON;
stopping_timer : TON;
downtimeIN : BOOL;
washing_timer : TON;
checkWashAndStart : CheckWashAndStart;
isRunningWash : BOOL;
onWash : BOOL := false;
time_sec : INT := 4000;
	END_VAR

END_PROGRAM

#0		{SRC:sr_ATS_Ctrl}
#1		(*$WAITSWITCH$*)
#2		
#3		
#4			(* IF i_pb_rem = 1 And
#5		Not Alarms.0 And 
#6		Not Alarms.3 And 
#7		Not Alarms.4 And 
#8		Not Alarms.5 And 
#9		Not Alarms.7 *)
#10			LD		Alarms.7	{LNXT:2|-1|-1}
(*) UNDEF
083E53DF  33 C0                         xor eax, eax
083E53E1  66 8B 05 CC CC CC CC          mov ax, [CCCCCCCCH] ; %M110+32
083E53E8  C1 E8 07                      shr eax, 7
083E53EB  25 01 00 00 00                and eax, 1

#11			NOT	{LNXT:2|-1|-1}
(*) BOOL
083E53F0  84 C0                         test al, al
083E53F2  0F 94 C0                      sete al

#12			AND(		Alarms.5	{LNXT:2|-1|-1}
(*) BOOL
083E53F5  50                            push eax
083E53F6  33 C0                         xor eax, eax
083E53F8  66 8B 05 CC CC CC CC          mov ax, [CCCCCCCCH] ; %M110+32
083E53FF  C1 E8 05                      shr eax, 5
083E5402  25 01 00 00 00                and eax, 1

#13			NOT	{LNXT:2|-1|-1}
(*) BOOL
083E5407  84 C0                         test al, al
083E5409  0F 94 C0                      sete al

#14			AND(		Alarms.4	{LNXT:2|-1|-1}
(*) BOOL
083E540C  50                            push eax
083E540D  33 C0                         xor eax, eax
083E540F  66 8B 05 CC CC CC CC          mov ax, [CCCCCCCCH] ; %M110+32
083E5416  C1 E8 04                      shr eax, 4
083E5419  25 01 00 00 00                and eax, 1

#15			NOT	{LNXT:2|-1|-1}
(*) BOOL
083E541E  84 C0                         test al, al
083E5420  0F 94 C0                      sete al

#16			AND(		Alarms.3	{LNXT:2|-1|-1}
(*) BOOL
083E5423  50                            push eax
083E5424  33 C0                         xor eax, eax
083E5426  66 8B 05 CC CC CC CC          mov ax, [CCCCCCCCH] ; %M110+32
083E542D  C1 E8 03                      shr eax, 3
083E5430  25 01 00 00 00                and eax, 1

#17			NOT	{LNXT:2|-1|-1}
(*) BOOL
083E5435  84 C0                         test al, al
083E5437  0F 94 C0                      sete al

#18			AND(		Alarms.0	{LNXT:2|-1|-1}
(*) BOOL
083E543A  50                            push eax
083E543B  33 C0                         xor eax, eax
083E543D  66 8B 05 CC CC CC CC          mov ax, [CCCCCCCCH] ; %M110+32
083E5444  25 01 00 00 00                and eax, 1

#19			NOT	{LNXT:2|-1|-1}
(*) BOOL
083E5449  84 C0                         test al, al
083E544B  0F 94 C0                      sete al

#20			AND(		i_pb_rem	{LNXT:2|-1|-1}
(*) BOOL
083E544E  50                            push eax
083E544F  0F BF 05 CC CC CC CC          movsx eax, word ptr [CCCCCCCCH] ; $$DATA$$+64

#21			EQ		1	{LNXT:2|-1|-1}
(*) INT
083E5456  3D 01 00 00 00                cmp eax, 1
083E545B  0F 94 C0                      sete al
083E545E  25 FF 00 00 00                and eax, 0FFh

#22			)	{LNXT:2|-1|-1}
(*) BOOL
083E5463  8B C8                         mov ecx, eax
083E5465  58                            pop eax
083E5466  23 C1                         and eax, ecx

#23			)	{LNXT:2|-1|-1}
(*) BOOL
083E5468  8B C8                         mov ecx, eax
083E546A  58                            pop eax
083E546B  23 C1                         and eax, ecx

#24			)	{LNXT:2|-1|-1}
(*) BOOL
083E546D  8B C8                         mov ecx, eax
083E546F  58                            pop eax
083E5470  23 C1                         and eax, ecx

#25			)	{LNXT:2|-1|-1}
(*) BOOL
083E5472  8B C8                         mov ecx, eax
083E5474  58                            pop eax
083E5475  23 C1                         and eax, ecx

#26			)	{LNXT:2|-1|-1}
(*) BOOL
083E5477  8B C8                         mov ecx, eax
083E5479  58                            pop eax
083E547A  23 C1                         and eax, ecx

#27			JMPCN	$label0	{LNXT:2|9|30}
(-) BOOL
083E547C  84 C0                         test al, al
083E547E  0F 84 C9 00 00 00             je 083E554DH

#28		
#29			(* THEN *)
#30		
#31		
#32				(* IF CMD.0 *)
#33				LD		CMD.0	{LNXT:9|-1|-1}
(*) UNDEF
083E5484  33 C0                         xor eax, eax
083E5486  66 8B 05 CC CC CC CC          mov ax, [CCCCCCCCH] ; %M110+34
083E548D  25 01 00 00 00                and eax, 1

#34				JMPCN	$label2	{LNXT:9|10|26}
(-) BOOL
083E5492  84 C0                         test al, al
083E5494  0F 84 A0 00 00 00             je 083E553AH

#35		
#36				(* THEN *)
#37		
#38					(* checkWashAndStart *)
#39					MOVE		o_val_close_fall,checkWashAndStart.o_val_close_fall_FB	{LNXT:10|-1|-1}
(*) BOOL
083E549A  B8 CC CC CC CC                mov eax, CCCCCCCCH ; %Q1+1
083E549F  89 05 CC CC CC CC             mov [CCCCCCCCH], eax ; $$DATA$$+185

#40					MOVE		o_val_close_R,checkWashAndStart.o_val_close_R_FB	{LNXT:11|-1|-1}
(*) BOOL^
083E54A5  B8 CC CC CC CC                mov eax, CCCCCCCCH ; %Q1+3
083E54AA  89 05 CC CC CC CC             mov [CCCCCCCCH], eax ; $$DATA$$+177

#41					MOVE		o_val_open_fall,checkWashAndStart.o_val_open_fall_FB	{LNXT:12|-1|-1}
(*) BOOL^
083E54B0  B8 CC CC CC CC                mov eax, CCCCCCCCH ; %Q1+0
083E54B5  89 05 CC CC CC CC             mov [CCCCCCCCH], eax ; $$DATA$$+181

#42					MOVE		o_val_open_R,checkWashAndStart.o_val_open_R_FB	{LNXT:13|-1|-1}
(*) BOOL^
083E54BB  B8 CC CC CC CC                mov eax, CCCCCCCCH ; %Q1+2
083E54C0  89 05 CC CC CC CC             mov [CCCCCCCCH], eax ; $$DATA$$+173

#43					MOVE		sv_washing,checkWashAndStart.sv_washing_FB	{LNXT:14|-1|-1}
(*) BOOL^
083E54C6  B8 CC CC CC CC                mov eax, CCCCCCCCH ; %M110+38
083E54CB  89 05 CC CC CC CC             mov [CCCCCCCCH], eax ; $$DATA$$+169

#44					MOVE		q_start_ats,checkWashAndStart.q_start_ats_FB	{LNXT:15|-1|-1}
(*) BOOL^
083E54D1  B8 CC CC CC CC                mov eax, CCCCCCCCH ; %Q1+7
083E54D6  89 05 CC CC CC CC             mov [CCCCCCCCH], eax ; $$DATA$$+189

#45					MOVE		time_sec,checkWashAndStart.ep_time_wash_FB	{LNXT:16|-1|-1}
(*) BOOL^
083E54DC  B8 CC CC CC CC                mov eax, CCCCCCCCH ; $$DATA$$+230
083E54E1  89 05 CC CC CC CC             mov [CCCCCCCCH], eax ; $$DATA$$+193

#46					MOVE		i_val_state,checkWashAndStart.i_val_state_FB	{LNXT:17|-1|-1}
(*) INT^
083E54E7  B8 CC CC CC CC                mov eax, CCCCCCCCH ; $$DATA$$+232
083E54EC  89 05 CC CC CC CC             mov [CCCCCCCCH], eax ; $$DATA$$+197

#47					MOVE		di_val_open_state_fall,checkWashAndStart.di_val_open_state_fall_FB	{LNXT:18|-1|-1}
(*) INT^
083E54F2  B8 CC CC CC CC                mov eax, CCCCCCCCH ; $$DATA$$+234
083E54F7  89 05 CC CC CC CC             mov [CCCCCCCCH], eax ; $$DATA$$+201

#48					MOVE		di_val_close_state_fall,checkWashAndStart.di_val_close_state_fall_FB	{LNXT:19|-1|-1}
(*) INT^
083E54FD  B8 CC CC CC CC                mov eax, CCCCCCCCH ; $$DATA$$+236
083E5502  89 05 CC CC CC CC             mov [CCCCCCCCH], eax ; $$DATA$$+205

#49					MOVE		di_val_open_state_R,checkWashAndStart.di_val_open_state_R_FB	{LNXT:20|-1|-1}
(*) INT^
083E5508  B8 CC CC CC CC                mov eax, CCCCCCCCH ; $$DATA$$+238
083E550D  89 05 CC CC CC CC             mov [CCCCCCCCH], eax ; $$DATA$$+209

#50					MOVE		di_val_close_state_R,checkWashAndStart.di_val_close_state_R_FB	{LNXT:21|-1|-1}
(*) INT^
083E5513  B8 CC CC CC CC                mov eax, CCCCCCCCH ; $$DATA$$+58
083E5518  89 05 CC CC CC CC             mov [CCCCCCCCH], eax ; $$DATA$$+213

#51					MOVE		Alarms_Val,checkWashAndStart.Alarm_Val_FB	{LNXT:22|-1|-1}
(*) BOOL^
083E551E  B8 CC CC CC CC                mov eax, CCCCCCCCH ; %M110+40
083E5523  89 05 CC CC CC CC             mov [CCCCCCCCH], eax ; $$DATA$$+217

#52					CAL		checkWashAndStart	{LNXT:10|82|-1}
(*) WORD^
083E5529  50                            push eax
083E552A  BB CC CC CC CC                mov ebx, CCCCCCCCH ; $$DATA$$+66
083E552F  E8 B6 F1 FF FF                call 083E46EAH ; $$CODE$$+18154
083E5534  58                            pop eax

#53					JMP		$label3	{LNXT:9|10|26}
(-) WORD^
083E5535  EB 11 90 90 90                jmp 083E5548H

#54		$label2:
#55		
#56				(* ELSE *)
#57		
#58					(* q_start_ats := False; *)
#59					MOVE		False,q_start_ats	{LNXT:26|82|-1}
(*) WORD^
083E553A  B8 00 00 00 00                mov eax, 00H
083E553F  84 C0                         test al, al
083E5541  0F 95 05 CC CC CC CC          setne [CCCCCCCCH] ; %Q1+7

#60		
#61		$label3:
#62				(* END_IF *)
#63				JMP		$label1	{LNXT:2|9|30}
(-) BOOL
083E5548  EB 35 90 90 90                jmp 083E557FH

#64		$label0:
#65		
#66			(* ELSE *)
#67		
#68				(* CMD.0 := False; *)
#69				MOVE		False,CMD.0	{LNXT:30|31|-1}
(*) BOOL
083E554D  B8 00 00 00 00                mov eax, 00H
083E5552  84 C0                         test al, al
083E5554  90 75 11 90 90 90             jne 00000014H@
083E555A  66 0F BA 35 CC CC CC CC 00    btr word ptr [CCCCCCCCH], 0 ; %M110+34
083E5563  EB 0C 90 90 90                jmp 0000000EH@
083E5568  66 0F BA 2D CC CC CC CC 00    bts word ptr [CCCCCCCCH], 0 ; %M110+34

#70		
#71				(* q_start_ats := False; *)
#72				MOVE		False,q_start_ats	{LNXT:31|82|-1}
(*) WORD
083E5571  B8 00 00 00 00                mov eax, 00H
083E5576  84 C0                         test al, al
083E5578  0F 95 05 CC CC CC CC          setne [CCCCCCCCH] ; %Q1+7

#73		
#74		$label1:
#75			(* END_IF *)
#76		
#77		
#78			(* IF q_start_ats *)
#79			LD		q_start_ats	{LNXT:82|-1|-1}
(*) UNDEF
083E557F  33 C0                         xor eax, eax
083E5581  8A 05 CC CC CC CC             mov al, [CCCCCCCCH] ; %Q1+7

#80			NOT	{LNXT:82|-1|-1}
(*) BOOL
083E5587  84 C0                         test al, al
083E5589  0F 94 C0                      sete al

#81			JMPCN	$label4	{LNXT:82|83|85}
(-) BOOL
083E558C  84 C0                         test al, al
083E558E  90 74 16 90 90 90             je 083E55A7H

#82		
#83			(* THEN *)
#84		
#85				(* downtimeIN:=true; *)
#86				MOVE		true,downtimeIN	{LNXT:83|89|-1}
(*) BOOL
083E5594  B8 01 00 00 00                mov eax, 01H
083E5599  84 C0                         test al, al
083E559B  0F 95 05 CC CC CC CC          setne [CCCCCCCCH] ; $$DATA$$+229

#87				JMP		$label5	{LNXT:82|83|85}
(-) BOOL
083E55A2  EB 11 90 90 90                jmp 083E55B5H

#88		$label4:
#89		
#90			(* ELSE *)
#91		
#92				(* downtimeIN:=false; *)
#93				MOVE		false,downtimeIN	{LNXT:85|89|-1}
(*) BOOL
083E55A7  B8 00 00 00 00                mov eax, 00H
083E55AC  84 C0                         test al, al
083E55AE  0F 95 05 CC CC CC CC          setne [CCCCCCCCH] ; $$DATA$$+229

#94		
#95		$label5:
#96			(* END_IF *)
#97		
#98			(* stopping_timer *)
#99			MOVE		downtimeIN,stopping_timer.IN	{LNXT:89|-1|-1}
(*) BOOL
083E55B5  33 C0                         xor eax, eax
083E55B7  8A 05 CC CC CC CC             mov al, [CCCCCCCCH] ; $$DATA$$+229
083E55BD  84 C0                         test al, al
083E55BF  0F 95 05 CC CC CC CC          setne [CCCCCCCCH] ; $$DATA$$+244

#100			MOVE		50000,stopping_timer.PT	{LNXT:89|-1|-1}
(*) BOOL
083E55C6  B8 50 C3 00 00                mov eax, C350H
083E55CB  89 05 CC CC CC CC             mov [CCCCCCCCH], eax ; $$DATA$$+245

#101			CAL		stopping_timer	{LNXT:89|91|-1}
(*) UDINT
083E55D1  50                            push eax
083E55D2  BB CC CC CC CC                mov ebx, CCCCCCCCH ; $$DATA$$+240
083E55D7  E8 DD EE FF FF                call 083E44B9H ; $$CODE$$+17593
083E55DC  58                            pop eax

#102		
#103		
#104			(* IF stopping_timer.Q *)
#105			LD		stopping_timer.Q	{LNXT:91|-1|-1}
(*) UNDEF
083E55DD  33 C0                         xor eax, eax
083E55DF  8A 05 CC CC CC CC             mov al, [CCCCCCCCH] ; $$DATA$$+249

#106			JMPCN	$label6	{LNXT:91|92|96}
(-) BOOL
083E55E5  84 C0                         test al, al
083E55E7  90 74 11 90 90 90             je 083E55FBH

#107		
#108			(* THEN *)
#109		
#110				(* sv_washing :=true; *)
#111				MOVE		true,sv_washing	{LNXT:92|96|-1}
(*) BOOL
083E55ED  B8 01 00 00 00                mov eax, 01H
083E55F2  84 C0                         test al, al
083E55F4  0F 95 05 CC CC CC CC          setne [CCCCCCCCH] ; %M110+38

#112		
#113		$label6:
#114			(* END_IF *)
#115		
#116			(* Alarms.2 := i_sns_door; *)
#117			MOVE		i_sns_door,Alarms.2	{LNXT:96|99|-1}
(*) BOOL
083E55FB  33 C0                         xor eax, eax
083E55FD  8A 05 CC CC CC CC             mov al, [CCCCCCCCH] ; $$DATA$$+262
083E5603  84 C0                         test al, al
083E5605  90 75 11 90 90 90             jne 00000014H@
083E560B  66 0F BA 35 CC CC CC CC 02    btr word ptr [CCCCCCCCH], 2 ; %M110+32
083E5614  EB 0C 90 90 90                jmp 0000000EH@
083E5619  66 0F BA 2D CC CC CC CC 02    bts word ptr [CCCCCCCCH], 2 ; %M110+32

#118		
#119			(* Alarms.3 := i_rnpp; *)
#120			MOVE		i_rnpp,Alarms.3	{LNXT:99|105|-1}
(*) BOOL
083E5622  33 C0                         xor eax, eax
083E5624  8A 05 CC CC CC CC             mov al, [CCCCCCCCH] ; $$DATA$$+263
083E562A  84 C0                         test al, al
083E562C  90 75 11 90 90 90             jne 00000014H@
083E5632  66 0F BA 35 CC CC CC CC 03    btr word ptr [CCCCCCCCH], 3 ; %M110+32
083E563B  EB 0C 90 90 90                jmp 0000000EH@
083E5640  66 0F BA 2D CC CC CC CC 03    bts word ptr [CCCCCCCCH], 3 ; %M110+32

#121		
#122			(* Alarms.5 := i_no_alm_ats; *)
#123			MOVE		i_no_alm_ats,Alarms.5	{LNXT:105|146|-1}
(*) BOOL
083E5649  33 C0                         xor eax, eax
083E564B  8A 05 CC CC CC CC             mov al, [CCCCCCCCH] ; $$DATA$$+264
083E5651  84 C0                         test al, al
083E5653  90 75 11 90 90 90             jne 00000014H@
083E5659  66 0F BA 35 CC CC CC CC 05    btr word ptr [CCCCCCCCH], 5 ; %M110+32
083E5662  EB 0C 90 90 90                jmp 0000000EH@
083E5667  66 0F BA 2D CC CC CC CC 05    bts word ptr [CCCCCCCCH], 5 ; %M110+32

#124		
#125		
#126			(* IF CMD.1 *)
#127			LD		CMD.1	{LNXT:146|-1|-1}
(*) UNDEF
083E5670  33 C0                         xor eax, eax
083E5672  66 8B 05 CC CC CC CC          mov ax, [CCCCCCCCH] ; %M110+34
083E5679  C1 E8 01                      shr eax, 1
083E567C  25 01 00 00 00                and eax, 1

#128			JMPCN	$label7	{LNXT:146|147|2}
(-) BOOL
083E5681  84 C0                         test al, al
083E5683  90 74 33 90 90 90             je 083E56B9H

#129		
#130			(* THEN *)
#131		
#132				(* Alarms := 0; *)
#133				MOVE		0,Alarms	{LNXT:147|148|-1}
(*) BOOL
083E5689  B8 00 00 00 00                mov eax, 00H
083E568E  66 89 05 CC CC CC CC          mov [CCCCCCCCH], ax ; %M110+32

#134		
#135				(* CMD.1 := False; *)
#136				MOVE		False,CMD.1	{LNXT:148|2|-1}
(*) WORD
083E5695  B8 00 00 00 00                mov eax, 00H
083E569A  84 C0                         test al, al
083E569C  90 75 11 90 90 90             jne 00000014H@
083E56A2  66 0F BA 35 CC CC CC CC 01    btr word ptr [CCCCCCCCH], 1 ; %M110+34
083E56AB  EB 0C 90 90 90                jmp 0000000EH@
083E56B0  66 0F BA 2D CC CC CC CC 01    bts word ptr [CCCCCCCCH], 1 ; %M110+34

083E56B9  61                            popad
083E56BA  5D                            pop ebp

083E56BB  C3                            ret

END_PROGRAM


**************************************************
	Target variable image generation
**************************************************


*** INPUT:
083E56BC  55                            push ebp
083E56BD  8B EC                         mov ebp, esp

083E56BF  66 8B 0D CC CC CC CC          mov cx, [CCCCCCCCH] ; %I1+14
083E56C6  66 89 0D CC CC CC CC          mov [CCCCCCCCH], cx ; $$DATA$$+64

083E56CD  66 8B 0D CC CC CC CC          mov cx, [CCCCCCCCH] ; %I1+4
083E56D4  66 89 0D CC CC CC CC          mov [CCCCCCCCH], cx ; $$DATA$$+232

083E56DB  66 8B 0D CC CC CC CC          mov cx, [CCCCCCCCH] ; %I1+6
083E56E2  66 89 0D CC CC CC CC          mov [CCCCCCCCH], cx ; $$DATA$$+234

083E56E9  66 8B 0D CC CC CC CC          mov cx, [CCCCCCCCH] ; %I1+8
083E56F0  66 89 0D CC CC CC CC          mov [CCCCCCCCH], cx ; $$DATA$$+236

083E56F7  66 8B 0D CC CC CC CC          mov cx, [CCCCCCCCH] ; %I1+10
083E56FE  66 89 0D CC CC CC CC          mov [CCCCCCCCH], cx ; $$DATA$$+238

083E5705  8A 0D CC CC CC CC             mov cl, [CCCCCCCCH] ; %I0+0
083E570B  88 0D CC CC CC CC             mov [CCCCCCCCH], cl ; $$DATA$$+58

083E5711  8A 0D CC CC CC CC             mov cl, [CCCCCCCCH] ; %I0+3
083E5717  88 0D CC CC CC CC             mov [CCCCCCCCH], cl ; $$DATA$$+262

083E571D  8A 0D CC CC CC CC             mov cl, [CCCCCCCCH] ; %I0+4
083E5723  88 0D CC CC CC CC             mov [CCCCCCCCH], cl ; $$DATA$$+263

083E5729  8A 0D CC CC CC CC             mov cl, [CCCCCCCCH] ; %I0+6
083E572F  88 0D CC CC CC CC             mov [CCCCCCCCH], cl ; $$DATA$$+264

083E5735  66 8B 0D CC CC CC CC          mov cx, [CCCCCCCCH] ; %I1+0
083E573C  66 89 0D CC CC CC CC          mov [CCCCCCCCH], cx ; $$DATA$$+270

083E5743  8B E5                         mov esp, ebp
083E5745  5D                            pop ebp

083E5746  C3                            ret


*** OUTPUT:
083E5747  55                            push ebp
083E5748  8B EC                         mov ebp, esp

083E574A  8B E5                         mov esp, ebp
083E574C  5D                            pop ebp

083E574D  C3                            ret



**************************************************
	Task Timed init code
**************************************************

083E574E  55                            push ebp
083E574F  8B EC                         mov ebp, esp

Var init: V::SR_ATS_CTRL.TIME_SEC = 4000
083E5751  66 C7 05 CC CC CC CC A0 0F    mov word ptr [CCCCCCCCH], 0FA0H ; $$DATA$$+230

083E575A  8B E5                         mov esp, ebp
083E575C  5D                            pop ebp

083E575D  C3                            ret



**************************************************
	Global init code
**************************************************

083E5770  55                            push ebp
083E5771  8B EC                         mov ebp, esp

Var init: V:EMBEDDEDELEMENTS:$$POUCBARRAY$$BACKGROUND = [?ATS_mdb.$$POUCB$$, 0]
083E5773  B9 CC CC CC CC                mov ecx, CCCCCCCCH ; $$DATA$$+360
083E5778  89 0D CC CC CC CC             mov [CCCCCCCCH], ecx ; $$DATA$$+308

Var init: V:EMBEDDEDELEMENTS:$$POUCBARRAY$$BOOT = [?sr_init_counters.$$POUCB$$, 0]
083E577E  B9 CC CC CC CC                mov ecx, CCCCCCCCH ; $$DATA$$+366
083E5783  89 0D CC CC CC CC             mov [CCCCCCCCH], ecx ; $$DATA$$+316

Var init: V:EMBEDDEDELEMENTS:$$POUCBARRAY$$INIT = [?init_val.$$POUCB$$, 0]
083E5789  B9 CC CC CC CC                mov ecx, CCCCCCCCH ; $$DATA$$+372
083E578E  89 0D CC CC CC CC             mov [CCCCCCCCH], ecx ; $$DATA$$+324

Var init: V:EMBEDDEDELEMENTS:$$POUCBARRAY$$SERV = [?InitParDB.$$POUCB$$, 0]
083E5794  B9 CC CC CC CC                mov ecx, CCCCCCCCH ; $$DATA$$+378
083E5799  89 0D CC CC CC CC             mov [CCCCCCCCH], ecx ; $$DATA$$+332

Var init: V:EMBEDDEDELEMENTS:$$POUCBARRAY$$TIMED = [?sr_pressure.$$POUCB$$, ?sr_counters.$$POUCB$$, ?sr_save_counters.$$POUCB$$, ?sr_ATS_Ctrl.$$POUCB$$, 0]
083E579F  B9 CC CC CC CC                mov ecx, CCCCCCCCH ; $$DATA$$+384
083E57A4  89 0D CC CC CC CC             mov [CCCCCCCCH], ecx ; $$DATA$$+340
083E57AA  B9 CC CC CC CC                mov ecx, CCCCCCCCH ; $$DATA$$+390
083E57AF  89 0D CC CC CC CC             mov [CCCCCCCCH], ecx ; $$DATA$$+344
083E57B5  B9 CC CC CC CC                mov ecx, CCCCCCCCH ; $$DATA$$+396
083E57BA  89 0D CC CC CC CC             mov [CCCCCCCCH], ecx ; $$DATA$$+348
083E57C0  B9 CC CC CC CC                mov ecx, CCCCCCCCH ; $$DATA$$+402
083E57C5  89 0D CC CC CC CC             mov [CCCCCCCCH], ecx ; $$DATA$$+352

083E57CB  8B E5                         mov esp, ebp
083E57CD  5D                            pop ebp

083E57CE  C3                            ret



**************************************************
	Global RETAIN init code
**************************************************

083E57CF  55                            push ebp
083E57D0  8B EC                         mov ebp, esp

083E57D2  8B E5                         mov esp, ebp
083E57D4  5D                            pop ebp

083E57D5  C3                            ret



**************************************************
	Task $$VirtualTables init code
**************************************************

083E57D6  55                            push ebp
083E57D7  8B EC                         mov ebp, esp

083E57D9  8B E5                         mov esp, ebp
083E57DB  5D                            pop ebp

083E57DC  C3                            ret



********************************************
MEMORY MAP
********************************************

Code area type:          		       main code
Start code area:          		00000000083E0000h
End code area:            		00000000083E61C4h
Code size:                		000061C4h

Start local data area:    		0000000008360000h
End local data area:      		0000000008360198h
Local data size:          		00000198h

Start retentive data area:		0000000000000000h
End retentive data area:  		0000000000000000h
Retentive data size:      		00000000h

Start bit data area:      		0000000000000000h
End bit data area:        		0000000000000000h
Bit data size:            		00000000h



********************************************
CODE ID:                                24CC4AC7
DEBUG MEMO ID:                          000034F7
FULL MEMO ID:                           0000CDD9
RELOCATION ADDR:                        00000000083E0000
********************************************
