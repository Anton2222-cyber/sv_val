***********************************************************************
*
*	CODE GENERATION LISTING FOR: sw37
*	COMPILER VERSION: 6.0.0.52
*
***********************************************************************

**************************************************
	List function block: R_TRIG
**************************************************

FUNCTION_BLOCK R_TRIG

	{ DE:"<HTML>The output Q will remain FALSE as long as the input variable CLK is FALSE.<br>
As soon as CLK returns TRUE, Q will first return TRUE.<br><br>
This means each time the function is called up, Q will return FALSE until CLK has falling edge followed by an rising edge.<br><br>
<img src= r_trig.png>" }

        VAR_INPUT
clk : BOOL;	{ DE:"Input for edge detection" }
	END_VAR

        VAR_OUTPUT
q : BOOL;	{ DE:"Raising edge output" }
	END_VAR

        VAR
m : BOOL := FALSE;
	END_VAR

END_FUNCTION_BLOCK

08244490  55                            push ebp
08244491  8B EB                         mov ebp, ebx
08244493  57                            push edi

#0		{SRC:R_TRIG}
#1		
#2			LD		clk
(*) UNDEF
08244494  33 C0                         xor eax, eax
08244496  8A 45 01                      mov al, 1[ebp]

#3			ANDN	m
(*) BOOL
08244499  33 C9                         xor ecx, ecx
0824449B  8A 4D 00                      mov cl, [ebp]
0824449E  84 C9                         test cl, cl
082444A0  0F 94 C1                      sete cl
082444A3  23 C1                         and eax, ecx

#4			ST		q
(*) BOOL
082444A5  84 C0                         test al, al
082444A7  0F 95 45 02                   setne 2[ebp]

#5		
#6			LD		clk
(*) UNDEF
082444AB  33 C0                         xor eax, eax
082444AD  8A 45 01                      mov al, 1[ebp]

#7			ST		m
(*) BOOL
082444B0  84 C0                         test al, al
082444B2  0F 95 45 00                   setne [ebp]

082444B6  5F                            pop edi
082444B7  5D                            pop ebp

082444B8  C3                            ret


Frame allocation (hex):

	0000 bit  0: VAR m
	0001 bit  0: VAR clk
	0002 bit  0: VAR q

END_FUNCTION_BLOCK
**************************************************
	List function block: TON
**************************************************

FUNCTION_BLOCK TON

	{ DE:"<HTML>The TON block produces a delayed output Q of the input IN. The delay time is expressed in milliseconds on the PT input.</br></br>
<img src= tonscheme.png>
<ul>
<li>if IN is FALSE Q is false</li>
<li>Q becomes TRUE as IN remains TRUE for PT milliseconds</li>
<li>Q remains TRUE until IN remains TRUE</li>
</ul>" }

        VAR_INPUT
IN : BOOL;	{ DE:"Timer input source" }
PT : UDINT;	{ DE:"Preset time value (ms)" }
	END_VAR

        VAR_OUTPUT
Q : BOOL;	{ DE:"Timer output" }
ET : UDINT;	{ DE:"Timer current value (ms)" }
	END_VAR

        VAR_EXTERNAL
	{G:"System_Timers"}
sysTimer AT %MD0.0 : UDINT;	{ DE:"System timer [ms]" }
	END_VAR

        VAR
timStart : UDINT;	{ DE:"Time value at start of counting" }
	END_VAR

END_FUNCTION_BLOCK

082444B9  55                            push ebp
082444BA  8B EB                         mov ebp, ebx
082444BC  57                            push edi

#0		{SRC:TON}
#1		
#2			(*	Check if in counting	*)
#3		
#4			LD		IN
(*) UNDEF
082444BD  33 C0                         xor eax, eax
082444BF  8A 45 04                      mov al, 4[ebp]

#5			JMPCN	lReset
(-) BOOL
082444C2  84 C0                         test al, al
082444C4  90 74 61 90 90 90             je 08244528H

#6		
#7			(*	Check if Q is TRUE *)
#8			LD		Q
(*) UNDEF
082444CA  33 C0                         xor eax, eax
082444CC  8A 45 09                      mov al, 9[ebp]

#9			RETC
#10			
(-) BOOL
082444CF  84 C0                         test al, al
082444D1  90 75 6A 90 90 90             jne 0824453EH

#11			(*	Check if already in counting *)
#12			LD		timStart
(*) UNDEF
082444D7  8B 45 00                      mov eax, [ebp]

#13			EQ		0
(*) UDINT
082444DA  3D 00 00 00 00                cmp eax, 0
082444DF  0F 94 C0                      sete al
082444E2  25 FF 00 00 00                and eax, 0FFh

#14			JMPCN	lUpdate
(-) BOOL
082444E7  84 C0                         test al, al
082444E9  90 74 0C 90 90 90             je 082444F8H

#15		
#16			(*	Start of counting *)
#17			LD		sysTimer
(*) UNDEF
082444EF  8B 05 CC CC CC CC             mov eax, [CCCCCCCCH] ; %M0+0

#18			ST		timStart
(*) UDINT
082444F5  89 45 00                      mov [ebp], eax

#19			
#20		lUpdate:
#21		
#22			(*	Update timer and check if time elapsed *)
#23			LD		sysTimer
(*) UNDEF
082444F8  8B 05 CC CC CC CC             mov eax, [CCCCCCCCH] ; %M0+0

#24			SUB		timStart
(*) UDINT
082444FE  2B 45 00                      sub eax, [ebp]

#25			ST		ET
(*) UDINT
08244501  89 45 0A                      mov 10[ebp], eax

#26			GE		PT
(*) UDINT
08244504  3B 45 05                      cmp eax, [ebp+5]
08244507  0F 93 C0                      setae al
0824450A  25 FF 00 00 00                and eax, 0FFh

#27			ST		Q
(*) BOOL
0824450F  84 C0                         test al, al
08244511  0F 95 45 09                   setne 9[ebp]

#28			RETCN
#29		
(-) BOOL
08244515  84 C0                         test al, al
08244517  90 74 24 90 90 90             je 0824453EH

#30			(*	Limit actual time value *)
#31			LD		PT
(*) UNDEF
0824451D  8B 45 05                      mov eax, 5[ebp]

#32			ST		ET
(*) UDINT
08244520  89 45 0A                      mov 10[ebp], eax

#33			RET
#34		
(-) UDINT
08244523  EB 19 90 90 90                jmp 0824453EH

#35		lReset:
#36		
#37			(*	Reset status *)
#38			LD		0
(*) UNDEF
08244528  B8 00 00 00 00                mov eax, 00H

#39			ST		ET
(*) USINT
0824452D  89 45 0A                      mov 10[ebp], eax

#40			ST		timStart
(*) UDINT
08244530  89 45 00                      mov [ebp], eax

#41			LD		FALSE
(*) UNDEF
08244533  B8 00 00 00 00                mov eax, 00H

#42			ST		Q
(*) BOOL
08244538  84 C0                         test al, al
0824453A  0F 95 45 09                   setne 9[ebp]

0824453E  5F                            pop edi
0824453F  5D                            pop ebp

08244540  C3                            ret


Frame allocation (hex):

	0000       : VAR timStart
	0004 bit  0: VAR IN
	0005       : VAR PT
	0009 bit  0: VAR Q
	000A       : VAR ET

END_FUNCTION_BLOCK
**************************************************
	List function block: CheckAlarmVal
**************************************************

FUNCTION_BLOCK CheckAlarmVal

        VAR_IN_OUT
di_val_open_state_fall_FB : INT^;
di_val_close_state_fall_FB : INT^;
di_val_open_state_R_FB : INT^;
di_val_close_state_R_FB : BOOL^;
Alarm_Val_FB : WORD^;
o_val_open_R_FB : BOOL^;
o_val_close_R_FB : BOOL^;
o_val_open_fall_FB : BOOL^;
o_val_close_fall_FB : BOOL^;
start_check : BOOL^;
	END_VAR

        VAR_OUTPUT
check_timer : TON;	{ DE:"локальний FB таймера" }
is_check_done : BOOL;
isOK : BOOL;
	END_VAR

        VAR
should_run_timer : BOOL;
	END_VAR

END_FUNCTION_BLOCK

08244541  55                            push ebp
08244542  8B EB                         mov ebp, ebx
08244544  57                            push edi

#0		{SRC:CheckAlarmVal}
#1		(*$WAITSWITCH$*)
#2		
#3		
#4			(* IF check_timer.IN *)
#5			LD		check_timer.IN	{LNXT:3|-1|-1}
(*) UNDEF
08244545  33 C0                         xor eax, eax
08244547  8A 45 05                      mov al, 5[ebp]

#6			JMPCN	$label0	{LNXT:3|4|8}
(-) BOOL
0824454A  84 C0                         test al, al
0824454C  90 74 19 90 90 90             je 08244568H

#7		
#8			(* THEN *)
#9		
#10				(* isOK := TRUE; *)
#11				MOVE		TRUE,isOK	{LNXT:4|5|-1}
(*) BOOL
08244552  B8 01 00 00 00                mov eax, 01H
08244557  84 C0                         test al, al
08244559  0F 95 45 18                   setne 24[ebp]

#12		
#13				(* is_check_done := false; *)
#14				MOVE		false,is_check_done	{LNXT:5|8|-1}
(*) BOOL
0824455D  B8 00 00 00 00                mov eax, 00H
08244562  84 C0                         test al, al
08244564  0F 95 45 17                   setne 23[ebp]

#15		
#16		$label0:
#17			(* END_IF *)
#18		
#19		
#20			(* IF start_check *)
#21			LD		start_check	{LNXT:8|-1|-1}
(*) UNDEF
08244568  8B 55 3D                      mov edx, 61[ebp]
0824456B  33 C0                         xor eax, eax
0824456D  8A 02                         mov al, [edx]

#22			JMPCN	$label1	{LNXT:8|9|13}
(-) BOOL
0824456F  84 C0                         test al, al
08244571  90 74 25 90 90 90             je 08244599H

#23		
#24			(* THEN *)
#25		
#26				(* check_timer *)
#27				MOVE		true,check_timer.IN	{LNXT:9|-1|-1}
(*) BOOL
08244577  B8 01 00 00 00                mov eax, 01H
0824457C  84 C0                         test al, al
0824457E  0F 95 45 05                   setne 5[ebp]

#28				MOVE		10000,check_timer.PT	{LNXT:9|-1|-1}
(*) BOOL
08244582  B8 10 27 00 00                mov eax, 2710H
08244587  89 45 06                      mov 6[ebp], eax

#29				CAL		check_timer	{LNXT:9|13|-1}
(*) UDINT
0824458A  50                            push eax
0824458B  8B DD                         mov ebx, ebp
0824458D  81 C3 01 00 00 00             add ebx, 1
08244593  E8 21 FF FF FF                call 082444B9H ; $$CODE$$+17593
08244598  58                            pop eax

#30		
#31		$label1:
#32			(* END_IF *)
#33		
#34		
#35			(* IF check_timer.Q *)
#36			LD		check_timer.Q	{LNXT:13|-1|-1}
(*) UNDEF
08244599  33 C0                         xor eax, eax
0824459B  8A 45 0A                      mov al, 10[ebp]

#37			JMPCN	$label2	{LNXT:13|15|41}
(-) BOOL
0824459E  84 C0                         test al, al
082445A0  0F 84 32 01 00 00             je 082446D8H

#38		
#39			(* THEN *)
#40		
#41				(* check_timer *)
#42				MOVE		false,check_timer.IN	{LNXT:15|-1|-1}
(*) BOOL
082445A6  B8 00 00 00 00                mov eax, 00H
082445AB  84 C0                         test al, al
082445AD  0F 95 45 05                   setne 5[ebp]

#43				CAL		check_timer	{LNXT:15|17|-1}
(*) BOOL
082445B1  50                            push eax
082445B2  8B DD                         mov ebx, ebp
082445B4  81 C3 01 00 00 00             add ebx, 1
082445BA  E8 FA FE FF FF                call 082444B9H ; $$CODE$$+17593
082445BF  58                            pop eax

#44		
#45		
#46				(* IF o_val_open_R_FB^ AND NOT di_val_open_state_R_FB^ *)
#47				LD		di_val_open_state_R_FB^	{LNXT:17|-1|-1}
(*) UNDEF
082445C0  8B 55 21                      mov edx, 33[ebp]
082445C3  0F BF 02                      movsx eax, word ptr [edx]

#48				NOT	{LNXT:17|-1|-1}
(*) INT
082445C6  66 F7 D0                      not ax

#49				AND		o_val_open_R_FB^	{LNXT:17|-1|-1}
(*) INT
082445C9  8B 55 2D                      mov edx, 45[ebp]
082445CC  33 C9                         xor ecx, ecx
082445CE  8A 0A                         mov cl, [edx]
082445D0  23 C1                         and eax, ecx

#50				JMPCN	$label3	{LNXT:17|18|21}
(-) INT
082445D2  66 85 C0                      test ax, ax
082445D5  90 74 20 90 90 90             je 082445F8H

#51		
#52				(* THEN *)
#53		
#54					(* Alarm_Val_FB^.0 := TRUE; *)
#55					MOVE		TRUE,Alarm_Val_FB^.0	{LNXT:18|21|-1}
(*) INT
082445DB  B8 01 00 00 00                mov eax, 01H
082445E0  8B 55 29                      mov edx, 41[ebp]
082445E3  84 C0                         test al, al
082445E5  90 75 0C 90 90 90             jne 0000000FH@
082445EB  0F BA 32 00                   btr [edx], 0
082445EF  EB 07 90 90 90                jmp 00000009H@
082445F4  0F BA 2A 00                   bts [edx], 0

#56		
#57		$label3:
#58				(* END_IF *)
#59		
#60		
#61				(* IF o_val_close_R_FB^ AND NOT di_val_close_state_R_FB^ *)
#62				LD		di_val_close_state_R_FB^	{LNXT:21|-1|-1}
(*) UNDEF
082445F8  8B 55 25                      mov edx, 37[ebp]
082445FB  33 C0                         xor eax, eax
082445FD  8A 02                         mov al, [edx]

#63				NOT	{LNXT:21|-1|-1}
(*) BOOL
082445FF  84 C0                         test al, al
08244601  0F 94 C0                      sete al

#64				AND		o_val_close_R_FB^	{LNXT:21|-1|-1}
(*) BOOL
08244604  8B 55 31                      mov edx, 49[ebp]
08244607  8B 55 31                      mov edx, 49[ebp]
0824460A  33 C9                         xor ecx, ecx
0824460C  8A 0A                         mov cl, [edx]
0824460E  23 C1                         and eax, ecx

#65				JMPCN	$label4	{LNXT:21|22|25}
(-) BOOL
08244610  84 C0                         test al, al
08244612  90 74 20 90 90 90             je 08244635H

#66		
#67				(* THEN *)
#68		
#69					(* Alarm_Val_FB^.1 := TRUE; *)
#70					MOVE		TRUE,Alarm_Val_FB^.1	{LNXT:22|25|-1}
(*) BOOL
08244618  B8 01 00 00 00                mov eax, 01H
0824461D  8B 55 29                      mov edx, 41[ebp]
08244620  84 C0                         test al, al
08244622  90 75 0C 90 90 90             jne 0000000FH@
08244628  0F BA 32 01                   btr [edx], 1
0824462C  EB 07 90 90 90                jmp 00000009H@
08244631  0F BA 2A 01                   bts [edx], 1

#71		
#72		$label4:
#73				(* END_IF *)
#74		
#75		
#76				(* IF o_val_open_fall_FB^ AND NOT di_val_open_state_fall_FB^ *)
#77				LD		di_val_open_state_fall_FB^	{LNXT:25|-1|-1}
(*) UNDEF
08244635  8B 55 19                      mov edx, 25[ebp]
08244638  0F BF 02                      movsx eax, word ptr [edx]

#78				NOT	{LNXT:25|-1|-1}
(*) INT
0824463B  66 F7 D0                      not ax

#79				AND		o_val_open_fall_FB^	{LNXT:25|-1|-1}
(*) INT
0824463E  8B 55 35                      mov edx, 53[ebp]
08244641  33 C9                         xor ecx, ecx
08244643  8A 0A                         mov cl, [edx]
08244645  23 C1                         and eax, ecx

#80				JMPCN	$label5	{LNXT:25|26|29}
(-) INT
08244647  66 85 C0                      test ax, ax
0824464A  90 74 20 90 90 90             je 0824466DH

#81		
#82				(* THEN *)
#83		
#84					(* Alarm_Val_FB^.2 := TRUE; *)
#85					MOVE		TRUE,Alarm_Val_FB^.2	{LNXT:26|29|-1}
(*) INT
08244650  B8 01 00 00 00                mov eax, 01H
08244655  8B 55 29                      mov edx, 41[ebp]
08244658  84 C0                         test al, al
0824465A  90 75 0C 90 90 90             jne 0000000FH@
08244660  0F BA 32 02                   btr [edx], 2
08244664  EB 07 90 90 90                jmp 00000009H@
08244669  0F BA 2A 02                   bts [edx], 2

#86		
#87		$label5:
#88				(* END_IF *)
#89		
#90		
#91				(* IF o_val_close_fall_FB^ AND NOT di_val_close_state_fall_FB^ *)
#92				LD		di_val_close_state_fall_FB^	{LNXT:29|-1|-1}
(*) UNDEF
0824466D  8B 55 1D                      mov edx, 29[ebp]
08244670  0F BF 02                      movsx eax, word ptr [edx]

#93				NOT	{LNXT:29|-1|-1}
(*) INT
08244673  66 F7 D0                      not ax

#94				AND		o_val_close_fall_FB^	{LNXT:29|-1|-1}
(*) INT
08244676  8B 55 39                      mov edx, 57[ebp]
08244679  33 C9                         xor ecx, ecx
0824467B  8A 0A                         mov cl, [edx]
0824467D  23 C1                         and eax, ecx

#95				JMPCN	$label6	{LNXT:29|30|34}
(-) INT
0824467F  66 85 C0                      test ax, ax
08244682  90 74 20 90 90 90             je 082446A5H

#96		
#97				(* THEN *)
#98		
#99					(* Alarm_Val_FB^.3 := TRUE; *)
#100					MOVE		TRUE,Alarm_Val_FB^.3	{LNXT:30|34|-1}
(*) INT
08244688  B8 01 00 00 00                mov eax, 01H
0824468D  8B 55 29                      mov edx, 41[ebp]
08244690  84 C0                         test al, al
08244692  90 75 0C 90 90 90             jne 0000000FH@
08244698  0F BA 32 03                   btr [edx], 3
0824469C  EB 07 90 90 90                jmp 00000009H@
082446A1  0F BA 2A 03                   bts [edx], 3

#101		
#102		$label6:
#103				(* END_IF *)
#104		
#105		
#106				(* IF Alarm_Val_FB^ > 0 *)
#107				LD		Alarm_Val_FB^	{LNXT:34|-1|-1}
(*) UNDEF
082446A5  8B 55 29                      mov edx, 41[ebp]
082446A8  33 C0                         xor eax, eax
082446AA  66 8B 02                      mov ax, [edx]

#108				GT		0	{LNXT:34|-1|-1}
(*) WORD
082446AD  3D 00 00 00 00                cmp eax, 0
082446B2  0F 9F C0                      setg al
082446B5  25 FF 00 00 00                and eax, 0FFh

#109				JMPCN	$label7	{LNXT:34|35|38}
(-) BOOL
082446BA  84 C0                         test al, al
082446BC  90 74 0E 90 90 90             je 082446CDH

#110		
#111				(* THEN *)
#112		
#113					(* isOK := FALSE; *)
#114					MOVE		FALSE,isOK	{LNXT:35|38|-1}
(*) BOOL
082446C2  B8 00 00 00 00                mov eax, 00H
082446C7  84 C0                         test al, al
082446C9  0F 95 45 18                   setne 24[ebp]

#115		
#116		$label7:
#117				(* END_IF *)
#118		
#119				(* is_check_done := TRUE; *)
#120				MOVE		TRUE,is_check_done	{LNXT:38|41|-1}
(*) BOOL
082446CD  B8 01 00 00 00                mov eax, 01H
082446D2  84 C0                         test al, al
082446D4  0F 95 45 17                   setne 23[ebp]

#121		
#122		$label2:
#123			(* END_IF *)
#124		
#125			(* check_timer *)
#126			CAL		check_timer	{LNXT:41|-1|-1}
(*) BOOL
082446D8  50                            push eax
082446D9  8B DD                         mov ebx, ebp
082446DB  81 C3 01 00 00 00             add ebx, 1
082446E1  E8 D3 FD FF FF                call 082444B9H ; $$CODE$$+17593
082446E6  58                            pop eax

082446E7  5F                            pop edi
082446E8  5D                            pop ebp

082446E9  C3                            ret


Frame allocation (hex):

	0000 bit  0: VAR should_run_timer
	0001       : FB check_timer
	0017 bit  0: VAR is_check_done
	0018 bit  0: VAR isOK
	0019       : VAR di_val_open_state_fall_FB
	001D       : VAR di_val_close_state_fall_FB
	0021       : VAR di_val_open_state_R_FB
	0025       : VAR di_val_close_state_R_FB
	0029       : VAR Alarm_Val_FB
	002D       : VAR o_val_open_R_FB
	0031       : VAR o_val_close_R_FB
	0035       : VAR o_val_open_fall_FB
	0039       : VAR o_val_close_fall_FB
	003D       : VAR start_check

END_FUNCTION_BLOCK
**************************************************
	List function block: CheckWashAndStart
**************************************************

FUNCTION_BLOCK CheckWashAndStart

        VAR_IN_OUT
sv_washing_FB : BOOL^;
o_val_open_R_FB : BOOL^;
o_val_close_R_FB : BOOL^;
o_val_open_fall_FB : BOOL^;
o_val_close_fall_FB : BOOL^;
q_start_ats_FB : BOOL^;
ep_time_wash_FB : INT^;
i_val_state_FB : INT^;
di_val_open_state_fall_FB : INT^;
di_val_close_state_fall_FB : INT^;
di_val_open_state_R_FB : INT^;
di_val_close_state_R_FB : BOOL^;
Alarm_Val_FB : WORD^;
	END_VAR

        VAR_OUTPUT
is_running_wash : BOOL;
	END_VAR

        VAR
washing_timer : TON;	{ DE:"локальний FB таймера" }
onWash : BOOL;
checkAlarmVal : CheckAlarmVal;
valve_rising : BOOL;
prev_val_open_fall : BOOL;
prev_val_close_fall : BOOL;
prev_val_open_R : BOOL;
prev_val_close_R : BOOL;
finish_val_rising : BOOL;
	END_VAR

END_FUNCTION_BLOCK

082446EA  55                            push ebp
082446EB  8B EB                         mov ebp, ebx
082446ED  57                            push edi

#0		{SRC:CheckWashAndStart}
#1		(*$WAITSWITCH$*)
#2		
#3		
#4			(* IF sv_washing_FB^ and i_val_state_FB^=1 *)
#5			LD		i_val_state_FB^	{LNXT:1|-1|-1}
(*) UNDEF
082446EE  8B 95 83 00 00 00             mov edx, 131[ebp]
082446F4  0F BF 02                      movsx eax, word ptr [edx]

#6			EQ		1	{LNXT:1|-1|-1}
(*) INT
082446F7  3D 01 00 00 00                cmp eax, 1
082446FC  0F 94 C0                      sete al
082446FF  25 FF 00 00 00                and eax, 0FFh

#7			AND		sv_washing_FB^	{LNXT:1|-1|-1}
(*) BOOL
08244704  8B 55 67                      mov edx, 103[ebp]
08244707  8B 55 67                      mov edx, 103[ebp]
0824470A  33 C9                         xor ecx, ecx
0824470C  8A 0A                         mov cl, [edx]
0824470E  23 C1                         and eax, ecx

#8			JMPCN	$label0	{LNXT:1|2|4}
(-) BOOL
08244710  84 C0                         test al, al
08244712  90 74 13 90 90 90             je 08244728H

#9		
#10			(* THEN *)
#11		
#12				(* onWash :=true; *)
#13				MOVE		true,onWash	{LNXT:2|7|-1}
(*) BOOL
08244718  B8 01 00 00 00                mov eax, 01H
0824471D  84 C0                         test al, al
0824471F  0F 95 45 16                   setne 22[ebp]

#14				JMP		$label1	{LNXT:1|2|4}
(-) BOOL
08244723  EB 0E 90 90 90                jmp 08244733H

#15		$label0:
#16		
#17			(* ELSE *)
#18		
#19				(* onWash :=false; *)
#20				MOVE		false,onWash	{LNXT:4|7|-1}
(*) BOOL
08244728  B8 00 00 00 00                mov eax, 00H
0824472D  84 C0                         test al, al
0824472F  0F 95 45 16                   setne 22[ebp]

#21		
#22		$label1:
#23			(* END_IF *)
#24		
#25		
#26			(* IF onWash *)
#27			LD		onWash	{LNXT:7|-1|-1}
(*) UNDEF
08244733  33 C0                         xor eax, eax
08244735  8A 45 16                      mov al, 22[ebp]

#28			JMPCN	$label2	{LNXT:7|10|53}
(-) BOOL
08244738  84 C0                         test al, al
0824473A  0F 84 87 01 00 00             je 082448C7H

#29		
#30			(* THEN *)
#31		
#32				(* is_running_wash :=true; *)
#33				MOVE		true,is_running_wash	{LNXT:10|12|-1}
(*) BOOL
08244740  B8 01 00 00 00                mov eax, 01H
08244745  84 C0                         test al, al
08244747  0F 95 45 66                   setne 102[ebp]

#34		
#35				(* prev_val_open_fall:=o_val_open_fall_FB^; *)
#36				MOVE		o_val_open_fall_FB^,prev_val_open_fall	{LNXT:12|13|-1}
(*) BOOL
0824474B  8B 55 73                      mov edx, 115[ebp]
0824474E  33 C0                         xor eax, eax
08244750  8A 02                         mov al, [edx]
08244752  84 C0                         test al, al
08244754  0F 95 45 61                   setne 97[ebp]

#37		
#38				(* prev_val_close_fall:=o_val_close_fall_FB^; *)
#39				MOVE		o_val_close_fall_FB^,prev_val_close_fall	{LNXT:13|14|-1}
(*) BOOL
08244758  8B 55 77                      mov edx, 119[ebp]
0824475B  33 C0                         xor eax, eax
0824475D  8A 02                         mov al, [edx]
0824475F  84 C0                         test al, al
08244761  0F 95 45 62                   setne 98[ebp]

#40		
#41				(* prev_val_open_R:=o_val_open_R_FB^; *)
#42				MOVE		o_val_open_R_FB^,prev_val_open_R	{LNXT:14|15|-1}
(*) BOOL
08244765  8B 55 6B                      mov edx, 107[ebp]
08244768  33 C0                         xor eax, eax
0824476A  8A 02                         mov al, [edx]
0824476C  84 C0                         test al, al
0824476E  0F 95 45 63                   setne 99[ebp]

#43		
#44				(* prev_val_close_R:=o_val_close_R_FB^; *)
#45				MOVE		o_val_close_R_FB^,prev_val_close_R	{LNXT:15|17|-1}
(*) BOOL
08244772  8B 55 6F                      mov edx, 111[ebp]
08244775  33 C0                         xor eax, eax
08244777  8A 02                         mov al, [edx]
08244779  84 C0                         test al, al
0824477B  0F 95 45 64                   setne 100[ebp]

#46		
#47				(* o_val_close_R_FB^:=true; *)
#48				MOVE		true,o_val_close_R_FB^	{LNXT:17|18|-1}
(*) BOOL
0824477F  B8 01 00 00 00                mov eax, 01H
08244784  8B 55 6F                      mov edx, 111[ebp]
08244787  84 C0                         test al, al
08244789  0F 95 02                      setne [edx]

#49		
#50				(* o_val_open_R_FB^:=false; *)
#51				MOVE		false,o_val_open_R_FB^	{LNXT:18|19|-1}
(*) BOOL
0824478C  B8 00 00 00 00                mov eax, 00H
08244791  8B 55 6B                      mov edx, 107[ebp]
08244794  84 C0                         test al, al
08244796  0F 95 02                      setne [edx]

#52		
#53				(* o_val_open_fall_FB^:=true; *)
#54				MOVE		true,o_val_open_fall_FB^	{LNXT:19|20|-1}
(*) BOOL
08244799  B8 01 00 00 00                mov eax, 01H
0824479E  8B 55 73                      mov edx, 115[ebp]
082447A1  84 C0                         test al, al
082447A3  0F 95 02                      setne [edx]

#55		
#56				(* o_val_close_fall_FB^:=false; *)
#57				MOVE		false,o_val_close_fall_FB^	{LNXT:20|22|-1}
(*) BOOL
082447A6  B8 00 00 00 00                mov eax, 00H
082447AB  8B 55 77                      mov edx, 119[ebp]
082447AE  84 C0                         test al, al
082447B0  0F 95 02                      setne [edx]

#58		
#59				(* valve_rising :=
#60		    (o_val_open_fall_FB^ AND NOT prev_val_open_fall) OR
#61			(o_val_close_fall_FB^ AND NOT prev_val_close_fall) OR
#62			(o_val_open_R_FB^ AND NOT prev_val_open_R) OR
#63			(o_val_close_R_FB^ AND NOT prev_val_close_R); *)
#64				LD		prev_val_close_R	{LNXT:22|30|-1}
(*) UNDEF
082447B3  33 C0                         xor eax, eax
082447B5  8A 45 64                      mov al, 100[ebp]

#65				NOT	{LNXT:22|30|-1}
(*) BOOL
082447B8  84 C0                         test al, al
082447BA  0F 94 C0                      sete al

#66				AND		o_val_close_R_FB^	{LNXT:22|30|-1}
(*) BOOL
082447BD  8B 55 6F                      mov edx, 111[ebp]
082447C0  8B 55 6F                      mov edx, 111[ebp]
082447C3  33 C9                         xor ecx, ecx
082447C5  8A 0A                         mov cl, [edx]
082447C7  23 C1                         and eax, ecx

#67				OR(		prev_val_open_R	{LNXT:22|30|-1}
(*) BOOL
082447C9  50                            push eax
082447CA  33 C0                         xor eax, eax
082447CC  8A 45 63                      mov al, 99[ebp]

#68				NOT	{LNXT:22|30|-1}
(*) BOOL
082447CF  84 C0                         test al, al
082447D1  0F 94 C0                      sete al

#69				AND		o_val_open_R_FB^	{LNXT:22|30|-1}
(*) BOOL
082447D4  8B 55 6B                      mov edx, 107[ebp]
082447D7  8B 55 6B                      mov edx, 107[ebp]
082447DA  33 C9                         xor ecx, ecx
082447DC  8A 0A                         mov cl, [edx]
082447DE  23 C1                         and eax, ecx

#70				OR(		prev_val_close_fall	{LNXT:22|30|-1}
(*) BOOL
082447E0  50                            push eax
082447E1  33 C0                         xor eax, eax
082447E3  8A 45 62                      mov al, 98[ebp]

#71				NOT	{LNXT:22|30|-1}
(*) BOOL
082447E6  84 C0                         test al, al
082447E8  0F 94 C0                      sete al

#72				AND		o_val_close_fall_FB^	{LNXT:22|30|-1}
(*) BOOL
082447EB  8B 55 77                      mov edx, 119[ebp]
082447EE  8B 55 77                      mov edx, 119[ebp]
082447F1  33 C9                         xor ecx, ecx
082447F3  8A 0A                         mov cl, [edx]
082447F5  23 C1                         and eax, ecx

#73				OR(		prev_val_open_fall	{LNXT:22|30|-1}
(*) BOOL
082447F7  50                            push eax
082447F8  33 C0                         xor eax, eax
082447FA  8A 45 61                      mov al, 97[ebp]

#74				NOT	{LNXT:22|30|-1}
(*) BOOL
082447FD  84 C0                         test al, al
082447FF  0F 94 C0                      sete al

#75				AND		o_val_open_fall_FB^	{LNXT:22|30|-1}
(*) BOOL
08244802  8B 55 73                      mov edx, 115[ebp]
08244805  8B 55 73                      mov edx, 115[ebp]
08244808  33 C9                         xor ecx, ecx
0824480A  8A 0A                         mov cl, [edx]
0824480C  23 C1                         and eax, ecx

#76				)	{LNXT:22|30|-1}
(*) BOOL
0824480E  8B C8                         mov ecx, eax
08244810  58                            pop eax
08244811  0B C1                         or eax, ecx

#77				)	{LNXT:22|30|-1}
(*) BOOL
08244813  8B C8                         mov ecx, eax
08244815  58                            pop eax
08244816  0B C1                         or eax, ecx

#78				)	{LNXT:22|30|-1}
(*) BOOL
08244818  8B C8                         mov ecx, eax
0824481A  58                            pop eax
0824481B  0B C1                         or eax, ecx

#79				ST		valve_rising	{LNXT:22|30|-1}
(*) BOOL
0824481D  84 C0                         test al, al
0824481F  0F 95 45 60                   setne 96[ebp]

#80		
#81				(* checkAlarmVal *)
#82				MOVE		di_val_open_state_fall_FB,checkAlarmVal.di_val_open_state_fall_FB	{LNXT:30|-1|-1}
(*) BOOL
08244823  8B 95 87 00 00 00             mov edx, 135[ebp]
08244829  8D 02                         lea eax, [edx]
0824482B  89 45 30                      mov 48[ebp], eax

#83				MOVE		di_val_close_state_fall_FB,checkAlarmVal.di_val_close_state_fall_FB	{LNXT:30|-1|-1}
(*) INT^
0824482E  8B 95 8B 00 00 00             mov edx, 139[ebp]
08244834  8D 02                         lea eax, [edx]
08244836  89 45 34                      mov 52[ebp], eax

#84				MOVE		di_val_open_state_R_FB,checkAlarmVal.di_val_open_state_R_FB	{LNXT:31|-1|-1}
(*) INT^
08244839  8B 95 8F 00 00 00             mov edx, 143[ebp]
0824483F  8D 02                         lea eax, [edx]
08244841  89 45 38                      mov 56[ebp], eax

#85				MOVE		di_val_close_state_R_FB,checkAlarmVal.di_val_close_state_R_FB	{LNXT:32|-1|-1}
(*) INT^
08244844  8B 95 93 00 00 00             mov edx, 147[ebp]
0824484A  8D 02                         lea eax, [edx]
0824484C  89 45 3C                      mov 60[ebp], eax

#86				MOVE		Alarm_Val_FB,checkAlarmVal.Alarm_Val_FB	{LNXT:33|-1|-1}
(*) BOOL^
0824484F  8B 95 97 00 00 00             mov edx, 151[ebp]
08244855  8D 02                         lea eax, [edx]
08244857  89 45 40                      mov 64[ebp], eax

#87				MOVE		o_val_open_R_FB,checkAlarmVal.o_val_open_R_FB	{LNXT:34|-1|-1}
(*) WORD^
0824485A  8B 55 6B                      mov edx, 107[ebp]
0824485D  8D 02                         lea eax, [edx]
0824485F  89 45 44                      mov 68[ebp], eax

#88				MOVE		o_val_close_R_FB,checkAlarmVal.o_val_close_R_FB	{LNXT:35|-1|-1}
(*) BOOL^
08244862  8B 55 6F                      mov edx, 111[ebp]
08244865  8D 02                         lea eax, [edx]
08244867  89 45 48                      mov 72[ebp], eax

#89				MOVE		o_val_open_fall_FB,checkAlarmVal.o_val_open_fall_FB	{LNXT:36|-1|-1}
(*) BOOL^
0824486A  8B 55 73                      mov edx, 115[ebp]
0824486D  8D 02                         lea eax, [edx]
0824486F  89 45 4C                      mov 76[ebp], eax

#90				MOVE		o_val_close_fall_FB,checkAlarmVal.o_val_close_fall_FB	{LNXT:37|-1|-1}
(*) BOOL^
08244872  8B 55 77                      mov edx, 119[ebp]
08244875  8D 02                         lea eax, [edx]
08244877  89 45 50                      mov 80[ebp], eax

#91				MOVE		valve_rising,checkAlarmVal.start_check	{LNXT:38|-1|-1}
(*) BOOL^
0824487A  8D 45 60                      lea eax, 96[ebp]
0824487D  89 45 54                      mov 84[ebp], eax

#92				CAL		checkAlarmVal	{LNXT:30|43|-1}
(*) BOOL^
08244880  50                            push eax
08244881  8B DD                         mov ebx, ebp
08244883  81 C3 17 00 00 00             add ebx, 23
08244889  E8 B3 FC FF FF                call 08244541H ; $$CODE$$+17729
0824488E  58                            pop eax

#93		
#94		
#95				(* IF checkAlarmVal.is_check_done and checkAlarmVal.isOK *)
#96				LD		checkAlarmVal.is_check_done	{LNXT:43|-1|-1}
(*) UNDEF
0824488F  33 C0                         xor eax, eax
08244891  8A 45 2E                      mov al, 46[ebp]

#97				AND		checkAlarmVal.isOK	{LNXT:43|-1|-1}
(*) BOOL
08244894  33 C9                         xor ecx, ecx
08244896  8A 4D 2F                      mov cl, 47[ebp]
08244899  23 C1                         and eax, ecx

#98				JMPCN	$label4	{LNXT:43|44|47}
(-) BOOL
0824489B  84 C0                         test al, al
0824489D  90 74 15 90 90 90             je 082448B5H

#99		
#100				(* THEN *)
#101		
#102					(* q_start_ats_FB^:=true; *)
#103					MOVE		true,q_start_ats_FB^	{LNXT:44|57|-1}
(*) BOOL
082448A3  B8 01 00 00 00                mov eax, 01H
082448A8  8B 55 7B                      mov edx, 123[ebp]
082448AB  84 C0                         test al, al
082448AD  0F 95 02                      setne [edx]

#104					JMP		$label5	{LNXT:43|44|47}
(-) BOOL
082448B0  EB 10 90 90 90                jmp 082448C2H

#105		$label4:
#106		
#107				(* ELSE *)
#108		
#109					(* q_start_ats_FB^:=false; *)
#110					MOVE		false,q_start_ats_FB^	{LNXT:47|57|-1}
(*) BOOL
082448B5  B8 00 00 00 00                mov eax, 00H
082448BA  8B 55 7B                      mov edx, 123[ebp]
082448BD  84 C0                         test al, al
082448BF  0F 95 02                      setne [edx]

#111		
#112		$label5:
#113				(* END_IF *)
#114				JMP		$label3	{LNXT:7|10|53}
(-) BOOL
082448C2  EB 10 90 90 90                jmp 082448D4H

#115		$label2:
#116		
#117			(* ELSE *)
#118		
#119				(* q_start_ats_FB^:=true; *)
#120				MOVE		true,q_start_ats_FB^	{LNXT:53|57|-1}
(*) BOOL
082448C7  B8 01 00 00 00                mov eax, 01H
082448CC  8B 55 7B                      mov edx, 123[ebp]
082448CF  84 C0                         test al, al
082448D1  0F 95 02                      setne [edx]

#121		
#122		$label3:
#123			(* END_IF *)
#124		
#125		
#126			(* IF washing_timer.Q *)
#127			LD		washing_timer.Q	{LNXT:57|-1|-1}
(*) UNDEF
082448D4  33 C0                         xor eax, eax
082448D6  8A 45 09                      mov al, 9[ebp]

#128			JMPCN	$label6	{LNXT:57|60|93}
(-) BOOL
082448D9  84 C0                         test al, al
082448DB  0F 84 F0 00 00 00             je 082449D1H

#129		
#130			(* THEN *)
#131		
#132				(* prev_val_open_fall:=o_val_open_fall_FB^; *)
#133				MOVE		o_val_open_fall_FB^,prev_val_open_fall	{LNXT:60|61|-1}
(*) BOOL
082448E1  8B 55 73                      mov edx, 115[ebp]
082448E4  33 C0                         xor eax, eax
082448E6  8A 02                         mov al, [edx]
082448E8  84 C0                         test al, al
082448EA  0F 95 45 61                   setne 97[ebp]

#134		
#135				(* prev_val_close_fall:=o_val_close_fall_FB^; *)
#136				MOVE		o_val_close_fall_FB^,prev_val_close_fall	{LNXT:61|62|-1}
(*) BOOL
082448EE  8B 55 77                      mov edx, 119[ebp]
082448F1  33 C0                         xor eax, eax
082448F3  8A 02                         mov al, [edx]
082448F5  84 C0                         test al, al
082448F7  0F 95 45 62                   setne 98[ebp]

#137		
#138				(* prev_val_open_R:=o_val_open_R_FB^; *)
#139				MOVE		o_val_open_R_FB^,prev_val_open_R	{LNXT:62|63|-1}
(*) BOOL
082448FB  8B 55 6B                      mov edx, 107[ebp]
082448FE  33 C0                         xor eax, eax
08244900  8A 02                         mov al, [edx]
08244902  84 C0                         test al, al
08244904  0F 95 45 63                   setne 99[ebp]

#140		
#141				(* prev_val_close_R:=o_val_close_R_FB^; *)
#142				MOVE		o_val_close_R_FB^,prev_val_close_R	{LNXT:63|66|-1}
(*) BOOL
08244908  8B 55 6F                      mov edx, 111[ebp]
0824490B  33 C0                         xor eax, eax
0824490D  8A 02                         mov al, [edx]
0824490F  84 C0                         test al, al
08244911  0F 95 45 64                   setne 100[ebp]

#143		
#144				(* o_val_close_R_FB^:=false; *)
#145				MOVE		false,o_val_close_R_FB^	{LNXT:66|67|-1}
(*) BOOL
08244915  B8 00 00 00 00                mov eax, 00H
0824491A  8B 55 6F                      mov edx, 111[ebp]
0824491D  84 C0                         test al, al
0824491F  0F 95 02                      setne [edx]

#146		
#147				(* o_val_open_fall_FB^:=false; *)
#148				MOVE		false,o_val_open_fall_FB^	{LNXT:67|69|-1}
(*) BOOL
08244922  B8 00 00 00 00                mov eax, 00H
08244927  8B 55 73                      mov edx, 115[ebp]
0824492A  84 C0                         test al, al
0824492C  0F 95 02                      setne [edx]

#149		
#150				(* o_val_open_R_FB^:=true; *)
#151				MOVE		true,o_val_open_R_FB^	{LNXT:69|70|-1}
(*) BOOL
0824492F  B8 01 00 00 00                mov eax, 01H
08244934  8B 55 6B                      mov edx, 107[ebp]
08244937  84 C0                         test al, al
08244939  0F 95 02                      setne [edx]

#152		
#153				(* o_val_close_fall_FB^:=true; *)
#154				MOVE		true,o_val_close_fall_FB^	{LNXT:70|72|-1}
(*) BOOL
0824493C  B8 01 00 00 00                mov eax, 01H
08244941  8B 55 77                      mov edx, 119[ebp]
08244944  84 C0                         test al, al
08244946  0F 95 02                      setne [edx]

#155		
#156				(* valve_rising :=
#157		    (o_val_open_fall_FB^ AND NOT prev_val_open_fall) OR
#158			(o_val_close_fall_FB^ AND NOT prev_val_close_fall) OR
#159			(o_val_open_R_FB^ AND NOT prev_val_open_R) OR
#160			(o_val_close_R_FB^ AND NOT prev_val_close_R); *)
#161				LD		prev_val_close_R	{LNXT:72|78|-1}
(*) UNDEF
08244949  33 C0                         xor eax, eax
0824494B  8A 45 64                      mov al, 100[ebp]

#162				NOT	{LNXT:72|78|-1}
(*) BOOL
0824494E  84 C0                         test al, al
08244950  0F 94 C0                      sete al

#163				AND		o_val_close_R_FB^	{LNXT:72|78|-1}
(*) BOOL
08244953  8B 55 6F                      mov edx, 111[ebp]
08244956  8B 55 6F                      mov edx, 111[ebp]
08244959  33 C9                         xor ecx, ecx
0824495B  8A 0A                         mov cl, [edx]
0824495D  23 C1                         and eax, ecx

#164				OR(		prev_val_open_R	{LNXT:72|78|-1}
(*) BOOL
0824495F  50                            push eax
08244960  33 C0                         xor eax, eax
08244962  8A 45 63                      mov al, 99[ebp]

#165				NOT	{LNXT:72|78|-1}
(*) BOOL
08244965  84 C0                         test al, al
08244967  0F 94 C0                      sete al

#166				AND		o_val_open_R_FB^	{LNXT:72|78|-1}
(*) BOOL
0824496A  8B 55 6B                      mov edx, 107[ebp]
0824496D  8B 55 6B                      mov edx, 107[ebp]
08244970  33 C9                         xor ecx, ecx
08244972  8A 0A                         mov cl, [edx]
08244974  23 C1                         and eax, ecx

#167				OR(		prev_val_close_fall	{LNXT:72|78|-1}
(*) BOOL
08244976  50                            push eax
08244977  33 C0                         xor eax, eax
08244979  8A 45 62                      mov al, 98[ebp]

#168				NOT	{LNXT:72|78|-1}
(*) BOOL
0824497C  84 C0                         test al, al
0824497E  0F 94 C0                      sete al

#169				AND		o_val_close_fall_FB^	{LNXT:72|78|-1}
(*) BOOL
08244981  8B 55 77                      mov edx, 119[ebp]
08244984  8B 55 77                      mov edx, 119[ebp]
08244987  33 C9                         xor ecx, ecx
08244989  8A 0A                         mov cl, [edx]
0824498B  23 C1                         and eax, ecx

#170				OR(		prev_val_open_fall	{LNXT:72|78|-1}
(*) BOOL
0824498D  50                            push eax
0824498E  33 C0                         xor eax, eax
08244990  8A 45 61                      mov al, 97[ebp]

#171				NOT	{LNXT:72|78|-1}
(*) BOOL
08244993  84 C0                         test al, al
08244995  0F 94 C0                      sete al

#172				AND		o_val_open_fall_FB^	{LNXT:72|78|-1}
(*) BOOL
08244998  8B 55 73                      mov edx, 115[ebp]
0824499B  8B 55 73                      mov edx, 115[ebp]
0824499E  33 C9                         xor ecx, ecx
082449A0  8A 0A                         mov cl, [edx]
082449A2  23 C1                         and eax, ecx

#173				)	{LNXT:72|78|-1}
(*) BOOL
082449A4  8B C8                         mov ecx, eax
082449A6  58                            pop eax
082449A7  0B C1                         or eax, ecx

#174				)	{LNXT:72|78|-1}
(*) BOOL
082449A9  8B C8                         mov ecx, eax
082449AB  58                            pop eax
082449AC  0B C1                         or eax, ecx

#175				)	{LNXT:72|78|-1}
(*) BOOL
082449AE  8B C8                         mov ecx, eax
082449B0  58                            pop eax
082449B1  0B C1                         or eax, ecx

#176				ST		valve_rising	{LNXT:72|78|-1}
(*) BOOL
082449B3  84 C0                         test al, al
082449B5  0F 95 45 60                   setne 96[ebp]

#177		
#178		
#179				(* IF valve_rising *)
#180				LD		valve_rising	{LNXT:78|-1|-1}
(*) UNDEF
082449B9  33 C0                         xor eax, eax
082449BB  8A 45 60                      mov al, 96[ebp]

#181				JMPCN	$label7	{LNXT:78|79|93}
(-) BOOL
082449BE  84 C0                         test al, al
082449C0  90 74 0E 90 90 90             je 082449D1H

#182		
#183				(* THEN *)
#184		
#185					(* finish_val_rising :=true; *)
#186					MOVE		true,finish_val_rising	{LNXT:79|93|-1}
(*) BOOL
082449C6  B8 01 00 00 00                mov eax, 01H
082449CB  84 C0                         test al, al
082449CD  0F 95 45 65                   setne 101[ebp]

#187		
#188		$label7:
#189				(* END_IF *)
#190		
#191		$label6:
#192			(* END_IF *)
#193		
#194		
#195			(* IF finish_val_rising *)
#196			LD		finish_val_rising	{LNXT:93|-1|-1}
(*) UNDEF
082449D1  33 C0                         xor eax, eax
082449D3  8A 45 65                      mov al, 101[ebp]

#197			JMPCN	$label8	{LNXT:93|94|98}
(-) BOOL
082449D6  84 C0                         test al, al
082449D8  90 74 1B 90 90 90             je 082449F6H

#198		
#199			(* THEN *)
#200		
#201				(* sv_washing_FB^:=false; *)
#202				MOVE		false,sv_washing_FB^	{LNXT:94|95|-1}
(*) BOOL
082449DE  B8 00 00 00 00                mov eax, 00H
082449E3  8B 55 67                      mov edx, 103[ebp]
082449E6  84 C0                         test al, al
082449E8  0F 95 02                      setne [edx]

#203		
#204				(* onWash :=false; *)
#205				MOVE		false,onWash	{LNXT:95|98|-1}
(*) BOOL
082449EB  B8 00 00 00 00                mov eax, 00H
082449F0  84 C0                         test al, al
082449F2  0F 95 45 16                   setne 22[ebp]

#206		
#207		$label8:
#208			(* END_IF *)
#209		
#210		
#211			(* IF checkAlarmVal.check_timer.Q *)
#212			LD		checkAlarmVal.check_timer.Q	{LNXT:98|-1|-1}
(*) UNDEF
082449F6  33 C0                         xor eax, eax
082449F8  8A 45 21                      mov al, 33[ebp]

#213			JMPCN	$label9	{LNXT:98|100|106}
(-) BOOL
082449FB  84 C0                         test al, al
082449FD  90 74 0E 90 90 90             je 08244A0EH

#214		
#215			(* THEN *)
#216		
#217				(* is_running_wash :=false; *)
#218				MOVE		false,is_running_wash	{LNXT:100|106|-1}
(*) BOOL
08244A03  B8 00 00 00 00                mov eax, 00H
08244A08  84 C0                         test al, al
08244A0A  0F 95 45 66                   setne 102[ebp]

#219		
#220		$label9:
#221			(* END_IF *)
#222		
#223			(* checkAlarmVal *)
#224			MOVE		di_val_open_state_fall_FB,checkAlarmVal.di_val_open_state_fall_FB	{LNXT:106|-1|-1}
(*) BOOL
08244A0E  8B 95 87 00 00 00             mov edx, 135[ebp]
08244A14  8D 02                         lea eax, [edx]
08244A16  89 45 30                      mov 48[ebp], eax

#225			MOVE		di_val_close_state_fall_FB,checkAlarmVal.di_val_close_state_fall_FB	{LNXT:106|-1|-1}
(*) INT^
08244A19  8B 95 8B 00 00 00             mov edx, 139[ebp]
08244A1F  8D 02                         lea eax, [edx]
08244A21  89 45 34                      mov 52[ebp], eax

#226			MOVE		di_val_open_state_R_FB,checkAlarmVal.di_val_open_state_R_FB	{LNXT:107|-1|-1}
(*) INT^
08244A24  8B 95 8F 00 00 00             mov edx, 143[ebp]
08244A2A  8D 02                         lea eax, [edx]
08244A2C  89 45 38                      mov 56[ebp], eax

#227			MOVE		di_val_close_state_R_FB,checkAlarmVal.di_val_close_state_R_FB	{LNXT:108|-1|-1}
(*) INT^
08244A2F  8B 95 93 00 00 00             mov edx, 147[ebp]
08244A35  8D 02                         lea eax, [edx]
08244A37  89 45 3C                      mov 60[ebp], eax

#228			MOVE		Alarm_Val_FB,checkAlarmVal.Alarm_Val_FB	{LNXT:109|-1|-1}
(*) BOOL^
08244A3A  8B 95 97 00 00 00             mov edx, 151[ebp]
08244A40  8D 02                         lea eax, [edx]
08244A42  89 45 40                      mov 64[ebp], eax

#229			MOVE		o_val_open_R_FB,checkAlarmVal.o_val_open_R_FB	{LNXT:110|-1|-1}
(*) WORD^
08244A45  8B 55 6B                      mov edx, 107[ebp]
08244A48  8D 02                         lea eax, [edx]
08244A4A  89 45 44                      mov 68[ebp], eax

#230			MOVE		o_val_close_R_FB,checkAlarmVal.o_val_close_R_FB	{LNXT:111|-1|-1}
(*) BOOL^
08244A4D  8B 55 6F                      mov edx, 111[ebp]
08244A50  8D 02                         lea eax, [edx]
08244A52  89 45 48                      mov 72[ebp], eax

#231			MOVE		o_val_open_fall_FB,checkAlarmVal.o_val_open_fall_FB	{LNXT:112|-1|-1}
(*) BOOL^
08244A55  8B 55 73                      mov edx, 115[ebp]
08244A58  8D 02                         lea eax, [edx]
08244A5A  89 45 4C                      mov 76[ebp], eax

#232			MOVE		o_val_close_fall_FB,checkAlarmVal.o_val_close_fall_FB	{LNXT:113|-1|-1}
(*) BOOL^
08244A5D  8B 55 77                      mov edx, 119[ebp]
08244A60  8D 02                         lea eax, [edx]
08244A62  89 45 50                      mov 80[ebp], eax

#233			MOVE		finish_val_rising,checkAlarmVal.start_check	{LNXT:114|-1|-1}
(*) BOOL^
08244A65  8D 45 65                      lea eax, 101[ebp]
08244A68  89 45 54                      mov 84[ebp], eax

#234			CAL		checkAlarmVal	{LNXT:106|117|-1}
(*) BOOL^
08244A6B  50                            push eax
08244A6C  8B DD                         mov ebx, ebp
08244A6E  81 C3 17 00 00 00             add ebx, 23
08244A74  E8 C8 FA FF FF                call 08244541H ; $$CODE$$+17729
08244A79  58                            pop eax

#235		
#236		
#237			(* IF finish_val_rising *)
#238			LD		finish_val_rising	{LNXT:117|-1|-1}
(*) UNDEF
08244A7A  33 C0                         xor eax, eax
08244A7C  8A 45 65                      mov al, 101[ebp]

#239			JMPCN	$label10	{LNXT:117|118|121}
(-) BOOL
08244A7F  84 C0                         test al, al
08244A81  90 74 0E 90 90 90             je 08244A92H

#240		
#241			(* THEN *)
#242		
#243				(* finish_val_rising:=false; *)
#244				MOVE		false,finish_val_rising	{LNXT:118|121|-1}
(*) BOOL
08244A87  B8 00 00 00 00                mov eax, 00H
08244A8C  84 C0                         test al, al
08244A8E  0F 95 45 65                   setne 101[ebp]

#245		
#246		$label10:
#247			(* END_IF *)
#248		
#249			(* washing_timer *)
#250			LD		onWash	{LNXT:121|-1|-1}
(*) UNDEF
08244A92  33 C0                         xor eax, eax
08244A94  8A 45 16                      mov al, 22[ebp]

#251			AND		q_start_ats_FB^	{LNXT:121|-1|-1}
(*) BOOL
08244A97  8B 55 7B                      mov edx, 123[ebp]
08244A9A  8B 55 7B                      mov edx, 123[ebp]
08244A9D  33 C9                         xor ecx, ecx
08244A9F  8A 0A                         mov cl, [edx]
08244AA1  23 C1                         and eax, ecx

#252			ST		washing_timer.IN	{LNXT:121|-1|-1}
(*) BOOL
08244AA3  84 C0                         test al, al
08244AA5  0F 95 45 04                   setne 4[ebp]

#253			MOVE		ep_time_wash_FB^,washing_timer.PT	{LNXT:121|-1|-1}
(*) BOOL
08244AA9  8B 55 7F                      mov edx, 127[ebp]
08244AAC  0F BF 02                      movsx eax, word ptr [edx]
08244AAF  89 45 05                      mov 5[ebp], eax

#254			CAL		washing_timer	{LNXT:121|-1|-1}
(*) INT
08244AB2  50                            push eax
08244AB3  8B DD                         mov ebx, ebp
08244AB5  E8 FF F9 FF FF                call 082444B9H ; $$CODE$$+17593
08244ABA  58                            pop eax

08244ABB  5F                            pop edi
08244ABC  5D                            pop ebp

08244ABD  C3                            ret


Frame allocation (hex):

	0000       : FB washing_timer
	0016 bit  0: VAR onWash
	0017       : FB checkAlarmVal
	0060 bit  0: VAR valve_rising
	0061 bit  0: VAR prev_val_open_fall
	0062 bit  0: VAR prev_val_close_fall
	0063 bit  0: VAR prev_val_open_R
	0064 bit  0: VAR prev_val_close_R
	0065 bit  0: VAR finish_val_rising
	0066 bit  0: VAR is_running_wash
	0067       : VAR sv_washing_FB
	006B       : VAR o_val_open_R_FB
	006F       : VAR o_val_close_R_FB
	0073       : VAR o_val_open_fall_FB
	0077       : VAR o_val_close_fall_FB
	007B       : VAR q_start_ats_FB
	007F       : VAR ep_time_wash_FB
	0083       : VAR i_val_state_FB
	0087       : VAR di_val_open_state_fall_FB
	008B       : VAR di_val_close_state_fall_FB
	008F       : VAR di_val_open_state_R_FB
	0093       : VAR di_val_close_state_R_FB
	0097       : VAR Alarm_Val_FB

END_FUNCTION_BLOCK
**************************************************
	List program: ATS_mdb
**************************************************

PROGRAM ATS_mdb

        VAR
res_eta_lcr : UINT;
resp_eta_lcr : ARRAY[0..3] OF INT;
res : INT;
xTON : TON;
	END_VAR

END_PROGRAM

08244AC0  55                            push ebp
08244AC1  8B EC                         mov ebp, esp
08244AC3  60                            pushad

#0		{SRC:ATS_mdb}
#1		(*$WAITSWITCH$*)
#2		
#3			(* res := sysMbMRTU_FC03(	addr := 1, 
#4											base := 257, // 256
#5											no := 4, 
#6											object := ADR(resp_eta_lcr), 
#7											timeout := 200); *)
#8			ADR		resp_eta_lcr	{LNXT:2|8|-1}
(*) UDINT
08244AC4  B8 CC CC CC CC                mov eax, CCCCCCCCH ; $$DATA$$+12

#9			ST		$$TMP0	{LNXT:2|8|-1}
(*) @INT
08244AC9  89 05 CC CC CC CC             mov [CCCCCCCCH], eax ; $$DATA$$+384

#10			LDP0		1	{LNXT:2|8|-1}
(*) @INT
#11			sysMbMRTU_FC03		257, 4, $$TMP0, 200	{LNXT:2|8|-1}
(*) @INT
08244ACF  68 C8 00 00 00                push 200
08244AD4  FF 35 CC CC CC CC             push [CCCCCCCCH] ; $$DATA$$+384
08244ADA  68 04 00 00 00                push 4
08244ADF  68 01 01 00 00                push 257
08244AE4  68 01 00 00 00                push 1
08244AE9  B9 CC CC CC CC                mov ecx, CCCCCCCCH ; sysMbMRTU_FC03
08244AEE  FF D1                         call ecx
08244AF0  81 C4 14 00 00 00             add esp, 20

#12			ST		res	{LNXT:2|8|-1}
(*) UINT
08244AF6  66 89 05 CC CC CC CC          mov [CCCCCCCCH], ax ; $$DATA$$+24

#13		
#14			(* ATS22_DUT.Ready 	:= to_bool(resp_eta_lcr[0] And 16#01); *)
#15			LD		resp_eta_lcr[0]	{LNXT:8|9|-1}
(*) UNDEF
08244AFD  0F BF 05 CC CC CC CC          movsx eax, word ptr [CCCCCCCCH] ; $$DATA$$+12

#16			AND		16#01	{LNXT:8|9|-1}
(*) INT
08244B04  25 01 00 00 00                and eax, 00000001H

#17			to_bool	{LNXT:8|9|-1}
(*) INT
08244B09  66 85 C0                      test ax, ax
08244B0C  0F 95 C0                      setne al

#18			ST		ATS22_DUT.Ready	{LNXT:8|9|-1}
(*) BOOL
08244B0F  84 C0                         test al, al
08244B11  0F 95 05 CC CC CC CC          setne [CCCCCCCCH] ; $$DATA$$+26

#19		
#20			(* ATS22_DUT.On 		:= to_bool(resp_eta_lcr[0] And 16#02); *)
#21			LD		resp_eta_lcr[0]	{LNXT:9|10|-1}
(*) UNDEF
08244B18  0F BF 05 CC CC CC CC          movsx eax, word ptr [CCCCCCCCH] ; $$DATA$$+12

#22			AND		16#02	{LNXT:9|10|-1}
(*) INT
08244B1F  25 02 00 00 00                and eax, 00000002H

#23			to_bool	{LNXT:9|10|-1}
(*) INT
08244B24  66 85 C0                      test ax, ax
08244B27  0F 95 C0                      setne al

#24			ST		ATS22_DUT.On	{LNXT:9|10|-1}
(*) BOOL
08244B2A  84 C0                         test al, al
08244B2C  0F 95 05 CC CC CC CC          setne [CCCCCCCCH] ; $$DATA$$+27

#25		
#26			(* ATS22_DUT.Trip 		:= to_bool(resp_eta_lcr[0] And 16#04); *)
#27			LD		resp_eta_lcr[0]	{LNXT:10|11|-1}
(*) UNDEF
08244B33  0F BF 05 CC CC CC CC          movsx eax, word ptr [CCCCCCCCH] ; $$DATA$$+12

#28			AND		16#04	{LNXT:10|11|-1}
(*) INT
08244B3A  25 04 00 00 00                and eax, 00000004H

#29			to_bool	{LNXT:10|11|-1}
(*) INT
08244B3F  66 85 C0                      test ax, ax
08244B42  0F 95 C0                      setne al

#30			ST		ATS22_DUT.Trip	{LNXT:10|11|-1}
(*) BOOL
08244B45  84 C0                         test al, al
08244B47  0F 95 05 CC CC CC CC          setne [CCCCCCCCH] ; $$DATA$$+28

#31		
#32			(* ATS22_DUT.Warning 	:= to_bool(resp_eta_lcr[0] And 16#08); *)
#33			LD		resp_eta_lcr[0]	{LNXT:11|12|-1}
(*) UNDEF
08244B4E  0F BF 05 CC CC CC CC          movsx eax, word ptr [CCCCCCCCH] ; $$DATA$$+12

#34			AND		16#08	{LNXT:11|12|-1}
(*) INT
08244B55  25 08 00 00 00                and eax, 00000008H

#35			to_bool	{LNXT:11|12|-1}
(*) INT
08244B5A  66 85 C0                      test ax, ax
08244B5D  0F 95 C0                      setne al

#36			ST		ATS22_DUT.Warning	{LNXT:11|12|-1}
(*) BOOL
08244B60  84 C0                         test al, al
08244B62  0F 95 05 CC CC CC CC          setne [CCCCCCCCH] ; $$DATA$$+29

#37		
#38			(* ATS22_DUT.LI3 		:= to_bool(resp_eta_lcr[0] And 16#20); *)
#39			LD		resp_eta_lcr[0]	{LNXT:12|13|-1}
(*) UNDEF
08244B69  0F BF 05 CC CC CC CC          movsx eax, word ptr [CCCCCCCCH] ; $$DATA$$+12

#40			AND		16#20	{LNXT:12|13|-1}
(*) INT
08244B70  25 20 00 00 00                and eax, 00000020H

#41			to_bool	{LNXT:12|13|-1}
(*) INT
08244B75  66 85 C0                      test ax, ax
08244B78  0F 95 C0                      setne al

#42			ST		ATS22_DUT.LI3	{LNXT:12|13|-1}
(*) BOOL
08244B7B  84 C0                         test al, al
08244B7D  0F 95 05 CC CC CC CC          setne [CCCCCCCCH] ; $$DATA$$+30

#43		
#44			(* ATS22_DUT.LI2 		:= to_bool(resp_eta_lcr[0] And 16#40); *)
#45			LD		resp_eta_lcr[0]	{LNXT:13|14|-1}
(*) UNDEF
08244B84  0F BF 05 CC CC CC CC          movsx eax, word ptr [CCCCCCCCH] ; $$DATA$$+12

#46			AND		16#40	{LNXT:13|14|-1}
(*) INT
08244B8B  25 40 00 00 00                and eax, 00000040H

#47			to_bool	{LNXT:13|14|-1}
(*) INT
08244B90  66 85 C0                      test ax, ax
08244B93  0F 95 C0                      setne al

#48			ST		ATS22_DUT.LI2	{LNXT:13|14|-1}
(*) BOOL
08244B96  84 C0                         test al, al
08244B98  0F 95 05 CC CC CC CC          setne [CCCCCCCCH] ; $$DATA$$+31

#49		
#50			(* ATS22_DUT.LI1 		:= to_bool(resp_eta_lcr[0] And 16#80); *)
#51			LD		resp_eta_lcr[0]	{LNXT:14|17|-1}
(*) UNDEF
08244B9F  0F BF 05 CC CC CC CC          movsx eax, word ptr [CCCCCCCCH] ; $$DATA$$+12

#52			AND		16#80	{LNXT:14|17|-1}
(*) INT
08244BA6  25 80 00 00 00                and eax, 00000080H

#53			to_bool	{LNXT:14|17|-1}
(*) INT
08244BAB  66 85 C0                      test ax, ax
08244BAE  0F 95 C0                      setne al

#54			ST		ATS22_DUT.LI1	{LNXT:14|17|-1}
(*) BOOL
08244BB1  84 C0                         test al, al
08244BB3  0F 95 05 CC CC CC CC          setne [CCCCCCCCH] ; $$DATA$$+32

#55		
#56			(* ATS_State_bits.0 := ATS22_DUT.Ready; *)
#57			MOVE		ATS22_DUT.Ready,ATS_State_bits.0	{LNXT:17|18|-1}
(*) BOOL
08244BBA  33 C0                         xor eax, eax
08244BBC  8A 05 CC CC CC CC             mov al, [CCCCCCCCH] ; $$DATA$$+26
08244BC2  84 C0                         test al, al
08244BC4  90 75 11 90 90 90             jne 00000014H@
08244BCA  66 0F BA 35 CC CC CC CC 00    btr word ptr [CCCCCCCCH], 0 ; %M110+16
08244BD3  EB 0C 90 90 90                jmp 0000000EH@
08244BD8  66 0F BA 2D CC CC CC CC 00    bts word ptr [CCCCCCCCH], 0 ; %M110+16

#58		
#59			(* ATS_State_bits.1 := ATS22_DUT.On And i_run_ats; *)
#60			LD		ATS22_DUT.On	{LNXT:18|19|-1}
(*) UNDEF
08244BE1  33 C0                         xor eax, eax
08244BE3  8A 05 CC CC CC CC             mov al, [CCCCCCCCH] ; $$DATA$$+27

#61			AND		i_run_ats	{LNXT:18|19|-1}
(*) BOOL
08244BE9  33 C9                         xor ecx, ecx
08244BEB  8A 0D CC CC CC CC             mov cl, [CCCCCCCCH] ; $$DATA$$+388
08244BF1  23 C1                         and eax, ecx

#62			ST		ATS_State_bits.1	{LNXT:18|19|-1}
(*) BOOL
08244BF3  84 C0                         test al, al
08244BF5  90 75 11 90 90 90             jne 00000014H@
08244BFB  66 0F BA 35 CC CC CC CC 01    btr word ptr [CCCCCCCCH], 1 ; %M110+16
08244C04  EB 0C 90 90 90                jmp 0000000EH@
08244C09  66 0F BA 2D CC CC CC CC 01    bts word ptr [CCCCCCCCH], 1 ; %M110+16

#63		
#64			(* ATS_State_bits.2 := ATS22_DUT.Trip Or Not i_no_alm_ats ; *)
#65			LD		i_no_alm_ats	{LNXT:19|20|-1}
(*) UNDEF
08244C12  33 C0                         xor eax, eax
08244C14  8A 05 CC CC CC CC             mov al, [CCCCCCCCH] ; $$DATA$$+389

#66			NOT	{LNXT:19|20|-1}
(*) BOOL
08244C1A  84 C0                         test al, al
08244C1C  0F 94 C0                      sete al

#67			OR		ATS22_DUT.Trip	{LNXT:19|20|-1}
(*) BOOL
08244C1F  33 C9                         xor ecx, ecx
08244C21  8A 0D CC CC CC CC             mov cl, [CCCCCCCCH] ; $$DATA$$+28
08244C27  0B C1                         or eax, ecx

#68			ST		ATS_State_bits.2	{LNXT:19|20|-1}
(*) BOOL
08244C29  84 C0                         test al, al
08244C2B  90 75 11 90 90 90             jne 00000014H@
08244C31  66 0F BA 35 CC CC CC CC 02    btr word ptr [CCCCCCCCH], 2 ; %M110+16
08244C3A  EB 0C 90 90 90                jmp 0000000EH@
08244C3F  66 0F BA 2D CC CC CC CC 02    bts word ptr [CCCCCCCCH], 2 ; %M110+16

#69		
#70			(* ATS_State_bits.3 := ATS22_DUT.Warning; *)
#71			MOVE		ATS22_DUT.Warning,ATS_State_bits.3	{LNXT:20|21|-1}
(*) BOOL
08244C48  33 C0                         xor eax, eax
08244C4A  8A 05 CC CC CC CC             mov al, [CCCCCCCCH] ; $$DATA$$+29
08244C50  84 C0                         test al, al
08244C52  90 75 11 90 90 90             jne 00000014H@
08244C58  66 0F BA 35 CC CC CC CC 03    btr word ptr [CCCCCCCCH], 3 ; %M110+16
08244C61  EB 0C 90 90 90                jmp 0000000EH@
08244C66  66 0F BA 2D CC CC CC CC 03    bts word ptr [CCCCCCCCH], 3 ; %M110+16

#72		
#73			(* ATS_State_bits.4 := ATS22_DUT.Local; *)
#74			MOVE		ATS22_DUT.Local,ATS_State_bits.4	{LNXT:21|22|-1}
(*) BOOL
08244C6F  33 C0                         xor eax, eax
08244C71  8A 05 CC CC CC CC             mov al, [CCCCCCCCH] ; $$DATA$$+34
08244C77  84 C0                         test al, al
08244C79  90 75 11 90 90 90             jne 00000014H@
08244C7F  66 0F BA 35 CC CC CC CC 04    btr word ptr [CCCCCCCCH], 4 ; %M110+16
08244C88  EB 0C 90 90 90                jmp 0000000EH@
08244C8D  66 0F BA 2D CC CC CC CC 04    bts word ptr [CCCCCCCCH], 4 ; %M110+16

#75		
#76			(* ATS_State_bits.5 := ATS22_DUT.Ramping; *)
#77			MOVE		ATS22_DUT.Ramping,ATS_State_bits.5	{LNXT:22|23|-1}
(*) BOOL
08244C96  33 C0                         xor eax, eax
08244C98  8A 05 CC CC CC CC             mov al, [CCCCCCCCH] ; $$DATA$$+35
08244C9E  84 C0                         test al, al
08244CA0  90 75 11 90 90 90             jne 00000014H@
08244CA6  66 0F BA 35 CC CC CC CC 05    btr word ptr [CCCCCCCCH], 5 ; %M110+16
08244CAF  EB 0C 90 90 90                jmp 0000000EH@
08244CB4  66 0F BA 2D CC CC CC CC 05    bts word ptr [CCCCCCCCH], 5 ; %M110+16

#78		
#79			(* ATS_State_bits.6 := ATS22_DUT.LI1; *)
#80			MOVE		ATS22_DUT.LI1,ATS_State_bits.6	{LNXT:23|24|-1}
(*) BOOL
08244CBD  33 C0                         xor eax, eax
08244CBF  8A 05 CC CC CC CC             mov al, [CCCCCCCCH] ; $$DATA$$+32
08244CC5  84 C0                         test al, al
08244CC7  90 75 11 90 90 90             jne 00000014H@
08244CCD  66 0F BA 35 CC CC CC CC 06    btr word ptr [CCCCCCCCH], 6 ; %M110+16
08244CD6  EB 0C 90 90 90                jmp 0000000EH@
08244CDB  66 0F BA 2D CC CC CC CC 06    bts word ptr [CCCCCCCCH], 6 ; %M110+16

#81		
#82			(* ATS_State_bits.7 := ATS22_DUT.LI2; *)
#83			MOVE		ATS22_DUT.LI2,ATS_State_bits.7	{LNXT:24|25|-1}
(*) BOOL
08244CE4  33 C0                         xor eax, eax
08244CE6  8A 05 CC CC CC CC             mov al, [CCCCCCCCH] ; $$DATA$$+31
08244CEC  84 C0                         test al, al
08244CEE  90 75 11 90 90 90             jne 00000014H@
08244CF4  66 0F BA 35 CC CC CC CC 07    btr word ptr [CCCCCCCCH], 7 ; %M110+16
08244CFD  EB 0C 90 90 90                jmp 0000000EH@
08244D02  66 0F BA 2D CC CC CC CC 07    bts word ptr [CCCCCCCCH], 7 ; %M110+16

#84		
#85			(* ATS_State_bits.8 := ATS22_DUT.LI3; *)
#86			MOVE		ATS22_DUT.LI3,ATS_State_bits.8	{LNXT:25|28|-1}
(*) BOOL
08244D0B  33 C0                         xor eax, eax
08244D0D  8A 05 CC CC CC CC             mov al, [CCCCCCCCH] ; $$DATA$$+30
08244D13  84 C0                         test al, al
08244D15  90 75 11 90 90 90             jne 00000014H@
08244D1B  66 0F BA 35 CC CC CC CC 08    btr word ptr [CCCCCCCCH], 8 ; %M110+16
08244D24  EB 0C 90 90 90                jmp 0000000EH@
08244D29  66 0F BA 2D CC CC CC CC 08    bts word ptr [CCCCCCCCH], 8 ; %M110+16

#87		
#88			(* ATS_State_bits.9 := i_pb_loc; *)
#89			MOVE		i_pb_loc,ATS_State_bits.9	{LNXT:28|29|-1}
(*) BOOL
08244D32  0F BF 05 CC CC CC CC          movsx eax, word ptr [CCCCCCCCH] ; $$DATA$$+390
08244D39  66 85 C0                      test ax, ax
08244D3C  90 75 11 90 90 90             jne 00000014H@
08244D42  66 0F BA 35 CC CC CC CC 09    btr word ptr [CCCCCCCCH], 9 ; %M110+16
08244D4B  EB 0C 90 90 90                jmp 0000000EH@
08244D50  66 0F BA 2D CC CC CC CC 09    bts word ptr [CCCCCCCCH], 9 ; %M110+16

#90		
#91			(* ATS_State_bits.10 := i_pb_rem; *)
#92			MOVE		i_pb_rem,ATS_State_bits.10	{LNXT:29|31|-1}
(*) INT
08244D59  0F BF 05 CC CC CC CC          movsx eax, word ptr [CCCCCCCCH] ; $$DATA$$+392
08244D60  66 85 C0                      test ax, ax
08244D63  90 75 11 90 90 90             jne 00000014H@
08244D69  66 0F BA 35 CC CC CC CC 0A    btr word ptr [CCCCCCCCH], 10 ; %M110+16
08244D72  EB 0C 90 90 90                jmp 0000000EH@
08244D77  66 0F BA 2D CC CC CC CC 0A    bts word ptr [CCCCCCCCH], 10 ; %M110+16

#93		
#94		
#95			(* IF i_pb_loc AND not i_pb_rem *)
#96			LD		i_pb_rem	{LNXT:31|-1|-1}
(*) UNDEF
08244D80  0F BF 05 CC CC CC CC          movsx eax, word ptr [CCCCCCCCH] ; $$DATA$$+392

#97			NOT	{LNXT:31|-1|-1}
(*) INT
08244D87  66 F7 D0                      not ax

#98			AND(		i_pb_loc	{LNXT:31|-1|-1}
(*) INT
08244D8A  50                            push eax
08244D8B  0F BF 05 CC CC CC CC          movsx eax, word ptr [CCCCCCCCH] ; $$DATA$$+390

#99			NOT	{LNXT:31|-1|-1}
(*) INT
08244D92  66 F7 D0                      not ax

#100			)	{LNXT:31|-1|-1}
(*) INT
08244D95  8B C8                         mov ecx, eax
08244D97  58                            pop eax
08244D98  23 C1                         and eax, ecx

#101			JMPCN	$label0	{LNXT:31|32|34}
(-) INT
08244D9A  66 85 C0                      test ax, ax
08244D9D  90 74 27 90 90 90             je 08244DC7H

#102		
#103			(* THEN *)
#104		
#105				(* ATS_State_bits.11 := TRUE; *)
#106				MOVE		TRUE,ATS_State_bits.11	{LNXT:32|34|-1}
(*) INT
08244DA3  B8 01 00 00 00                mov eax, 01H
08244DA8  84 C0                         test al, al
08244DAA  90 75 11 90 90 90             jne 00000014H@
08244DB0  66 0F BA 35 CC CC CC CC 0B    btr word ptr [CCCCCCCCH], 11 ; %M110+16
08244DB9  EB 0C 90 90 90                jmp 0000000EH@
08244DBE  66 0F BA 2D CC CC CC CC 0B    bts word ptr [CCCCCCCCH], 11 ; %M110+16

#107		
#108		$label0:
#109			(* END_IF *)
#110		
#111		
#112			(* IF i_pb_loc AND i_pb_rem *)
#113			LD		i_pb_loc	{LNXT:34|-1|-1}
(*) UNDEF
08244DC7  0F BF 05 CC CC CC CC          movsx eax, word ptr [CCCCCCCCH] ; $$DATA$$+390

#114			NOT	{LNXT:34|-1|-1}
(*) INT
08244DCE  66 F7 D0                      not ax

#115			AND		i_pb_rem	{LNXT:34|-1|-1}
(*) INT
08244DD1  0F BF 0D CC CC CC CC          movsx ecx, word ptr [CCCCCCCCH] ; $$DATA$$+392
08244DD8  23 C1                         and eax, ecx

#116			JMPCN	$label1	{LNXT:34|35|37}
(-) INT
08244DDA  66 85 C0                      test ax, ax
08244DDD  90 74 27 90 90 90             je 08244E07H

#117		
#118			(* THEN *)
#119		
#120				(* ATS_State_bits.11 := FALSE; *)
#121				MOVE		FALSE,ATS_State_bits.11	{LNXT:35|37|-1}
(*) INT
08244DE3  B8 00 00 00 00                mov eax, 00H
08244DE8  84 C0                         test al, al
08244DEA  90 75 11 90 90 90             jne 00000014H@
08244DF0  66 0F BA 35 CC CC CC CC 0B    btr word ptr [CCCCCCCCH], 11 ; %M110+16
08244DF9  EB 0C 90 90 90                jmp 0000000EH@
08244DFE  66 0F BA 2D CC CC CC CC 0B    bts word ptr [CCCCCCCCH], 11 ; %M110+16

#122		
#123		$label1:
#124			(* END_IF *)
#125		
#126		
#127			(* IF i_pb_loc AND not i_pb_rem *)
#128			LD		i_pb_rem	{LNXT:37|-1|-1}
(*) UNDEF
08244E07  0F BF 05 CC CC CC CC          movsx eax, word ptr [CCCCCCCCH] ; $$DATA$$+392

#129			NOT	{LNXT:37|-1|-1}
(*) INT
08244E0E  66 F7 D0                      not ax

#130			AND		i_pb_loc	{LNXT:37|-1|-1}
(*) INT
08244E11  0F BF 0D CC CC CC CC          movsx ecx, word ptr [CCCCCCCCH] ; $$DATA$$+390
08244E18  23 C1                         and eax, ecx

#131			JMPCN	$label2	{LNXT:37|38|43}
(-) INT
08244E1A  66 85 C0                      test ax, ax
08244E1D  90 74 27 90 90 90             je 08244E47H

#132		
#133			(* THEN *)
#134		
#135				(* ATS_State_bits.11 := FALSE; *)
#136				MOVE		FALSE,ATS_State_bits.11	{LNXT:38|43|-1}
(*) INT
08244E23  B8 00 00 00 00                mov eax, 00H
08244E28  84 C0                         test al, al
08244E2A  90 75 11 90 90 90             jne 00000014H@
08244E30  66 0F BA 35 CC CC CC CC 0B    btr word ptr [CCCCCCCCH], 11 ; %M110+16
08244E39  EB 0C 90 90 90                jmp 0000000EH@
08244E3E  66 0F BA 2D CC CC CC CC 0B    bts word ptr [CCCCCCCCH], 11 ; %M110+16

#137		
#138		$label2:
#139			(* END_IF *)
#140		
#141			(* ATS22_DUT.EtaCurrent := to_byte(SHR(resp_eta_lcr[0] AND 16#3F00, 16#08) * 200 / 63); *)
#142			LD		resp_eta_lcr[0]	{LNXT:43|44|-1}
(*) UNDEF
08244E47  0F BF 05 CC CC CC CC          movsx eax, word ptr [CCCCCCCCH] ; $$DATA$$+12

#143			AND		16#3F00	{LNXT:43|44|-1}
(*) INT
08244E4E  25 00 3F 00 00                and eax, 00003F00H

#144			SHR		16#08	{LNXT:43|44|-1}
(*) INT
08244E53  C1 E8 08                      shr eax, 8

#145			MUL		200	{LNXT:43|44|-1}
(*) DINT
08244E56  B9 C8 00 00 00                mov ecx, 200
08244E5B  F7 E9                         imul ecx

#146			DIV		63	{LNXT:43|44|-1}
(*) DINT
08244E5D  99                            cdq
08244E5E  B9 3F 00 00 00                mov ecx, 63
08244E63  F7 F9                         idiv ecx

#147			to_byte	{LNXT:43|44|-1}
(*) DINT
#148			ST		ATS22_DUT.EtaCurrent	{LNXT:43|44|-1}
(*) BYTE
08244E65  88 05 CC CC CC CC             mov [CCCCCCCCH], al ; $$DATA$$+33

#149		
#150			(* ATS_Current_prsnt	 := ATS22_DUT.EtaCurrent; *)
#151			MOVE		ATS22_DUT.EtaCurrent,ATS_Current_prsnt	{LNXT:44|46|-1}
(*) BYTE
08244E6B  33 C0                         xor eax, eax
08244E6D  8A 05 CC CC CC CC             mov al, [CCCCCCCCH] ; $$DATA$$+33
08244E73  66 89 05 CC CC CC CC          mov [CCCCCCCCH], ax ; %M110+18

#152		
#153			(* ATS22_DUT.Local 	:= to_bool(resp_eta_lcr[0] And 16#4000); *)
#154			LD		resp_eta_lcr[0]	{LNXT:46|47|-1}
(*) UNDEF
08244E7A  0F BF 05 CC CC CC CC          movsx eax, word ptr [CCCCCCCCH] ; $$DATA$$+12

#155			AND		16#4000	{LNXT:46|47|-1}
(*) INT
08244E81  25 00 40 00 00                and eax, 00004000H

#156			to_bool	{LNXT:46|47|-1}
(*) INT
08244E86  66 85 C0                      test ax, ax
08244E89  0F 95 C0                      setne al

#157			ST		ATS22_DUT.Local	{LNXT:46|47|-1}
(*) BOOL
08244E8C  84 C0                         test al, al
08244E8E  0F 95 05 CC CC CC CC          setne [CCCCCCCCH] ; $$DATA$$+34

#158		
#159			(* ATS22_DUT.Ramping 	:= to_bool(resp_eta_lcr[0] And 16#8000); *)
#160			LD		resp_eta_lcr[0]	{LNXT:47|49|-1}
(*) UNDEF
08244E95  0F BF 05 CC CC CC CC          movsx eax, word ptr [CCCCCCCCH] ; $$DATA$$+12

#161			AND		16#8000	{LNXT:47|49|-1}
(*) INT
08244E9C  25 00 80 00 00                and eax, 00008000H

#162			to_bool	{LNXT:47|49|-1}
(*) INT
08244EA1  66 85 C0                      test ax, ax
08244EA4  0F 95 C0                      setne al

#163			ST		ATS22_DUT.Ramping	{LNXT:47|49|-1}
(*) BOOL
08244EA7  84 C0                         test al, al
08244EA9  0F 95 05 CC CC CC CC          setne [CCCCCCCCH] ; $$DATA$$+35

#164		
#165			(* ATS22_DUT.Lcr1 := resp_eta_lcr[1]; *)
#166			MOVE		resp_eta_lcr[1],ATS22_DUT.Lcr1	{LNXT:49|50|-1}
(*) BOOL
08244EB0  0F BF 05 CC CC CC CC          movsx eax, word ptr [CCCCCCCCH] ; $$DATA$$+14
08244EB7  66 89 05 CC CC CC CC          mov [CCCCCCCCH], ax ; $$DATA$$+36

#167		
#168			(* ATS22_DUT.Lcr2 := resp_eta_lcr[2]; *)
#169			MOVE		resp_eta_lcr[2],ATS22_DUT.Lcr2	{LNXT:50|51|-1}
(*) INT
08244EBE  0F BF 05 CC CC CC CC          movsx eax, word ptr [CCCCCCCCH] ; $$DATA$$+16
08244EC5  66 89 05 CC CC CC CC          mov [CCCCCCCCH], ax ; $$DATA$$+38

#170		
#171			(* ATS22_DUT.Lcr3 := resp_eta_lcr[3]; *)
#172			MOVE		resp_eta_lcr[3],ATS22_DUT.Lcr3	{LNXT:51|53|-1}
(*) INT
08244ECC  0F BF 05 CC CC CC CC          movsx eax, word ptr [CCCCCCCCH] ; $$DATA$$+18
08244ED3  66 89 05 CC CC CC CC          mov [CCCCCCCCH], ax ; $$DATA$$+40

#173		
#174			(* ATS_Current_L1 := ATS22_DUT.Lcr1; *)
#175			MOVE		ATS22_DUT.Lcr1,ATS_Current_L1	{LNXT:53|54|-1}
(*) INT
08244EDA  0F BF 05 CC CC CC CC          movsx eax, word ptr [CCCCCCCCH] ; $$DATA$$+36
08244EE1  66 89 05 CC CC CC CC          mov [CCCCCCCCH], ax ; %M110+20

#176		
#177			(* ATS_Current_L2 := ATS22_DUT.Lcr2; *)
#178			MOVE		ATS22_DUT.Lcr2,ATS_Current_L2	{LNXT:54|55|-1}
(*) INT
08244EE8  0F BF 05 CC CC CC CC          movsx eax, word ptr [CCCCCCCCH] ; $$DATA$$+38
08244EEF  66 89 05 CC CC CC CC          mov [CCCCCCCCH], ax ; %M110+22

#179		
#180			(* ATS_Current_L3 := ATS22_DUT.Lcr3; *)
#181			MOVE		ATS22_DUT.Lcr3,ATS_Current_L3	{LNXT:55|57|-1}
(*) INT
08244EF6  0F BF 05 CC CC CC CC          movsx eax, word ptr [CCCCCCCCH] ; $$DATA$$+40
08244EFD  66 89 05 CC CC CC CC          mov [CCCCCCCCH], ax ; %M110+24

#182		
#183			(* res := sysMbMRTU_FC03(	addr := 1, 
#184											base := 261, // 260
#185											no := 1, 
#186											object := ADR(resp_eta_lcr), 
#187											timeout := 200); *)
#188			ADR		resp_eta_lcr	{LNXT:57|63|-1}
(*) INT
08244F04  B8 CC CC CC CC                mov eax, CCCCCCCCH ; $$DATA$$+12

#189			ST		$$TMP0	{LNXT:57|63|-1}
(*) @INT
08244F09  89 05 CC CC CC CC             mov [CCCCCCCCH], eax ; $$DATA$$+384

#190			LDP0		1	{LNXT:57|63|-1}
(*) @INT
#191			sysMbMRTU_FC03		261, 1, $$TMP0, 200	{LNXT:57|63|-1}
(*) @INT
08244F0F  68 C8 00 00 00                push 200
08244F14  FF 35 CC CC CC CC             push [CCCCCCCCH] ; $$DATA$$+384
08244F1A  68 01 00 00 00                push 1
08244F1F  68 05 01 00 00                push 261
08244F24  68 01 00 00 00                push 1
08244F29  B9 CC CC CC CC                mov ecx, CCCCCCCCH ; sysMbMRTU_FC03
08244F2E  FF D1                         call ecx
08244F30  81 C4 14 00 00 00             add esp, 20

#192			ST		res	{LNXT:57|63|-1}
(*) UINT
08244F36  66 89 05 CC CC CC CC          mov [CCCCCCCCH], ax ; $$DATA$$+24

#193		
#194			(* ATS22_DUT.LcrVoltage	:= resp_eta_lcr[0]; *)
#195			MOVE		resp_eta_lcr[0],ATS22_DUT.LcrVoltage	{LNXT:63|64|-1}
(*) UINT
08244F3D  0F BF 05 CC CC CC CC          movsx eax, word ptr [CCCCCCCCH] ; $$DATA$$+12
08244F44  66 89 05 CC CC CC CC          mov [CCCCCCCCH], ax ; $$DATA$$+42

#196		
#197			(* ATS_Voltage := ATS22_DUT.LcrVoltage; *)
#198			MOVE		ATS22_DUT.LcrVoltage,ATS_Voltage	{LNXT:64|68|-1}
(*) INT
08244F4B  0F BF 05 CC CC CC CC          movsx eax, word ptr [CCCCCCCCH] ; $$DATA$$+42
08244F52  66 89 05 CC CC CC CC          mov [CCCCCCCCH], ax ; %M110+36

#199		
#200			(* res := sysMbMRTU_FC03(	addr := 1, 
#201											base := 280, // 279
#202											no := 1, 
#203											object := ADR(resp_eta_lcr), 
#204											timeout := 200); *)
#205			ADR		resp_eta_lcr	{LNXT:68|74|-1}
(*) INT
08244F59  B8 CC CC CC CC                mov eax, CCCCCCCCH ; $$DATA$$+12

#206			ST		$$TMP0	{LNXT:68|74|-1}
(*) @INT
08244F5E  89 05 CC CC CC CC             mov [CCCCCCCCH], eax ; $$DATA$$+384

#207			LDP0		1	{LNXT:68|74|-1}
(*) @INT
#208			sysMbMRTU_FC03		280, 1, $$TMP0, 200	{LNXT:68|74|-1}
(*) @INT
08244F64  68 C8 00 00 00                push 200
08244F69  FF 35 CC CC CC CC             push [CCCCCCCCH] ; $$DATA$$+384
08244F6F  68 01 00 00 00                push 1
08244F74  68 18 01 00 00                push 280
08244F79  68 01 00 00 00                push 1
08244F7E  B9 CC CC CC CC                mov ecx, CCCCCCCCH ; sysMbMRTU_FC03
08244F83  FF D1                         call ecx
08244F85  81 C4 14 00 00 00             add esp, 20

#209			ST		res	{LNXT:68|74|-1}
(*) UINT
08244F8B  66 89 05 CC CC CC CC          mov [CCCCCCCCH], ax ; $$DATA$$+24

#210		
#211			(* ATS22_DUT.LastFLT 	:= resp_eta_lcr[0]; *)
#212			MOVE		resp_eta_lcr[0],ATS22_DUT.LastFLT	{LNXT:74|75|-1}
(*) UINT
08244F92  0F BF 05 CC CC CC CC          movsx eax, word ptr [CCCCCCCCH] ; $$DATA$$+12
08244F99  66 89 05 CC CC CC CC          mov [CCCCCCCCH], ax ; $$DATA$$+44

#213		
#214			(* ATS_Last_FaultCode := ATS22_DUT.LastFLT; *)
#215			MOVE		ATS22_DUT.LastFLT,ATS_Last_FaultCode	{LNXT:75|78|-1}
(*) INT
08244FA0  0F BF 05 CC CC CC CC          movsx eax, word ptr [CCCCCCCCH] ; $$DATA$$+44
08244FA7  66 89 05 CC CC CC CC          mov [CCCCCCCCH], ax ; %M110+26

#216		
#217			(* res := sysMbMRTU_FC03(	addr := 1, 
#218											base := 274, // 273
#219											no := 3, 
#220											object := ADR(resp_eta_lcr), 
#221											timeout := 200); *)
#222			ADR		resp_eta_lcr	{LNXT:78|84|-1}
(*) INT
08244FAE  B8 CC CC CC CC                mov eax, CCCCCCCCH ; $$DATA$$+12

#223			ST		$$TMP0	{LNXT:78|84|-1}
(*) @INT
08244FB3  89 05 CC CC CC CC             mov [CCCCCCCCH], eax ; $$DATA$$+384

#224			LDP0		1	{LNXT:78|84|-1}
(*) @INT
#225			sysMbMRTU_FC03		274, 3, $$TMP0, 200	{LNXT:78|84|-1}
(*) @INT
08244FB9  68 C8 00 00 00                push 200
08244FBE  FF 35 CC CC CC CC             push [CCCCCCCCH] ; $$DATA$$+384
08244FC4  68 03 00 00 00                push 3
08244FC9  68 12 01 00 00                push 274
08244FCE  68 01 00 00 00                push 1
08244FD3  B9 CC CC CC CC                mov ecx, CCCCCCCCH ; sysMbMRTU_FC03
08244FD8  FF D1                         call ecx
08244FDA  81 C4 14 00 00 00             add esp, 20

#226			ST		res	{LNXT:78|84|-1}
(*) UINT
08244FE0  66 89 05 CC CC CC CC          mov [CCCCCCCCH], ax ; $$DATA$$+24

#227		
#228		
#229			(* IF res <> 0 *)
#230			LD		res	{LNXT:84|-1|-1}
(*) UNDEF
08244FE7  0F BF 05 CC CC CC CC          movsx eax, word ptr [CCCCCCCCH] ; $$DATA$$+24

#231			NE		0	{LNXT:84|-1|-1}
(*) INT
08244FEE  3D 00 00 00 00                cmp eax, 0
08244FF3  0F 95 C0                      setne al
08244FF6  25 FF 00 00 00                and eax, 0FFh

#232			JMPCN	$label3	{LNXT:84|84|86}
(-) BOOL
08244FFB  84 C0                         test al, al
08244FFD  90 74 27 90 90 90             je 08245027H

#233		
#234			(* THEN *)
#235		
#236				(* Alarms.6 := true; *)
#237				MOVE		true,Alarms.6	{LNXT:84|86|-1}
(*) BOOL
08245003  B8 01 00 00 00                mov eax, 01H
08245008  84 C0                         test al, al
0824500A  90 75 11 90 90 90             jne 00000014H@
08245010  66 0F BA 35 CC CC CC CC 06    btr word ptr [CCCCCCCCH], 6 ; %M110+32
08245019  EB 0C 90 90 90                jmp 0000000EH@
0824501E  66 0F BA 2D CC CC CC CC 06    bts word ptr [CCCCCCCCH], 6 ; %M110+32

#238		
#239		$label3:
#240			(* END_IF *)
#241		
#242			(* ATS22_DUT.MotRunTime 		:= resp_eta_lcr[0]; *)
#243			MOVE		resp_eta_lcr[0],ATS22_DUT.MotRunTime	{LNXT:86|87|-1}
(*) WORD
08245027  0F BF 05 CC CC CC CC          movsx eax, word ptr [CCCCCCCCH] ; $$DATA$$+12
0824502E  66 89 05 CC CC CC CC          mov [CCCCCCCCH], ax ; $$DATA$$+46

#244		
#245			(* ATS22_DUT.MotStartCnt 		:= resp_eta_lcr[1]; *)
#246			MOVE		resp_eta_lcr[1],ATS22_DUT.MotStartCnt	{LNXT:87|88|-1}
(*) INT
08245035  0F BF 05 CC CC CC CC          movsx eax, word ptr [CCCCCCCCH] ; $$DATA$$+14
0824503C  66 89 05 CC CC CC CC          mov [CCCCCCCCH], ax ; $$DATA$$+48

#247		
#248			(* ATS22_DUT.MotLastStartTime 	:= resp_eta_lcr[2]; *)
#249			MOVE		resp_eta_lcr[2],ATS22_DUT.MotLastStartTime	{LNXT:88|90|-1}
(*) INT
08245043  0F BF 05 CC CC CC CC          movsx eax, word ptr [CCCCCCCCH] ; $$DATA$$+16
0824504A  66 89 05 CC CC CC CC          mov [CCCCCCCCH], ax ; $$DATA$$+50

#250		
#251			(* ATS_RunTime_Hors	:= to_word(ATS22_DUT.MotRunTime); *)
#252			LDP0		ATS22_DUT.MotRunTime	{LNXT:90|91|-1}
(*) INT
#253			to_word	{LNXT:90|91|-1}
(*) INT
08245051  0F BF 05 CC CC CC CC          movsx eax, word ptr [CCCCCCCCH] ; $$DATA$$+46

#254			ST		ATS_RunTime_Hors	{LNXT:90|91|-1}
(*) WORD
08245058  66 89 05 CC CC CC CC          mov [CCCCCCCCH], ax ; %M110+28

#255		
#256			(* ATS_OnTimes_Cnt		:= to_word(ATS22_DUT.MotStartCnt); *)
#257			LDP0		ATS22_DUT.MotStartCnt	{LNXT:91|2|-1}
(*) WORD
#258			to_word	{LNXT:91|2|-1}
(*) WORD
0824505F  0F BF 05 CC CC CC CC          movsx eax, word ptr [CCCCCCCCH] ; $$DATA$$+48

#259			ST		ATS_OnTimes_Cnt	{LNXT:91|2|-1}
(*) WORD
08245066  66 89 05 CC CC CC CC          mov [CCCCCCCCH], ax ; %M110+30

0824506D  61                            popad
0824506E  5D                            pop ebp

0824506F  C3                            ret

END_PROGRAM


**************************************************
	Target variable image generation
**************************************************


*** INPUT:
08245070  55                            push ebp
08245071  8B EC                         mov ebp, esp

08245073  8A 0D CC CC CC CC             mov cl, [CCCCCCCCH] ; %I0+7
08245079  88 0D CC CC CC CC             mov [CCCCCCCCH], cl ; $$DATA$$+388

0824507F  8A 0D CC CC CC CC             mov cl, [CCCCCCCCH] ; %I0+6
08245085  88 0D CC CC CC CC             mov [CCCCCCCCH], cl ; $$DATA$$+389

0824508B  66 8B 0D CC CC CC CC          mov cx, [CCCCCCCCH] ; %I1+12
08245092  66 89 0D CC CC CC CC          mov [CCCCCCCCH], cx ; $$DATA$$+390

08245099  66 8B 0D CC CC CC CC          mov cx, [CCCCCCCCH] ; %I1+14
082450A0  66 89 0D CC CC CC CC          mov [CCCCCCCCH], cx ; $$DATA$$+392

082450A7  8B E5                         mov esp, ebp
082450A9  5D                            pop ebp

082450AA  C3                            ret


*** OUTPUT:
082450AB  55                            push ebp
082450AC  8B EC                         mov ebp, esp

082450AE  8B E5                         mov esp, ebp
082450B0  5D                            pop ebp

082450B1  C3                            ret



**************************************************
	Task Background init code
**************************************************

082450B2  55                            push ebp
082450B3  8B EC                         mov ebp, esp

082450B5  8B E5                         mov esp, ebp
082450B7  5D                            pop ebp

082450B8  C3                            ret

**************************************************
	List program: sr_init_counters
**************************************************

PROGRAM sr_init_counters

END_PROGRAM

082450D0  55                            push ebp
082450D1  8B EC                         mov ebp, esp
082450D3  60                            pushad

#0		{SRC:sr_init_counters}
#1		(*$WAITSWITCH$*)
#2		
#3			(* kw_counter 	:= epprom_kw_cnt; *)
#4			MOVE		epprom_kw_cnt,kw_counter	{LNXT:1|2|-1}
(*) UDINT
082450D4  8B 05 CC CC CC CC             mov eax, [CCCCCCCCH] ; %M101+8
082450DA  89 05 CC CC CC CC             mov [CCCCCCCCH], eax ; %M110+4

#5		
#6			(* q_counter	:= epprom_q_cnt; *)
#7			MOVE		epprom_q_cnt,q_counter	{LNXT:2|1|-1}
(*) DWORD
082450E0  8B 05 CC CC CC CC             mov eax, [CCCCCCCCH] ; %M101+0
082450E6  89 05 CC CC CC CC             mov [CCCCCCCCH], eax ; %M110+8

082450EC  61                            popad
082450ED  5D                            pop ebp

082450EE  C3                            ret

END_PROGRAM


**************************************************
	Target variable image generation
**************************************************


*** INPUT:
082450EF  C3                            ret


*** OUTPUT:
082450F0  C3                            ret



**************************************************
	Task Boot init code
**************************************************

082450F1  55                            push ebp
082450F2  8B EC                         mov ebp, esp

082450F4  8B E5                         mov esp, ebp
082450F6  5D                            pop ebp

082450F7  C3                            ret

**************************************************
	List program: init_val
**************************************************

PROGRAM init_val

END_PROGRAM

08245110  55                            push ebp
08245111  8B EC                         mov ebp, esp
08245113  60                            pushad

#0		{SRC:init_val}
#1		(*$WAITSWITCH$*)
#2		
#3		
#4			(* IF di_val_close_state_R *)
#5			LD		di_val_close_state_R	{LNXT:1|-1|-1}
(*) UNDEF
08245114  33 C0                         xor eax, eax
08245116  8A 05 CC CC CC CC             mov al, [CCCCCCCCH] ; %I0+0

#6			NOT	{LNXT:1|-1|-1}
(*) BOOL
0824511C  84 C0                         test al, al
0824511E  0F 94 C0                      sete al

#7			JMPCN	$label0	{LNXT:1|2|6}
(-) BOOL
08245121  84 C0                         test al, al
08245123  90 74 1F 90 90 90             je 08245145H

#8		
#9			(* THEN *)
#10		
#11				(* o_val_close_R:=true; *)
#12				MOVE		true,o_val_close_R	{LNXT:2|3|-1}
(*) BOOL
08245129  B8 01 00 00 00                mov eax, 01H
0824512E  84 C0                         test al, al
08245130  0F 95 05 CC CC CC CC          setne [CCCCCCCCH] ; %Q1+3

#13		
#14				(* o_val_open_R:=false; *)
#15				MOVE		false,o_val_open_R	{LNXT:3|6|-1}
(*) BOOL
08245137  B8 00 00 00 00                mov eax, 00H
0824513C  84 C0                         test al, al
0824513E  0F 95 05 CC CC CC CC          setne [CCCCCCCCH] ; %Q1+2

#16		
#17		$label0:
#18			(* END_IF *)
#19		
#20		
#21			(* IF di_val_close_state_fall = 0 *)
#22			LD		di_val_close_state_fall	{LNXT:6|-1|-1}
(*) UNDEF
08245145  0F BF 05 CC CC CC CC          movsx eax, word ptr [CCCCCCCCH] ; %I1+8

#23			EQ		0	{LNXT:6|-1|-1}
(*) INT
0824514C  3D 00 00 00 00                cmp eax, 0
08245151  0F 94 C0                      sete al
08245154  25 FF 00 00 00                and eax, 0FFh

#24			JMPCN	$label1	{LNXT:6|7|1}
(-) BOOL
08245159  84 C0                         test al, al
0824515B  90 74 1F 90 90 90             je 0824517DH

#25		
#26			(* THEN *)
#27		
#28				(* o_val_close_fall:=true; *)
#29				MOVE		true,o_val_close_fall	{LNXT:7|8|-1}
(*) BOOL
08245161  B8 01 00 00 00                mov eax, 01H
08245166  84 C0                         test al, al
08245168  0F 95 05 CC CC CC CC          setne [CCCCCCCCH] ; %Q1+1

#30		
#31				(* o_val_open_fall:=false; *)
#32				MOVE		false,o_val_open_fall	{LNXT:8|1|-1}
(*) BOOL
0824516F  B8 00 00 00 00                mov eax, 00H
08245174  84 C0                         test al, al
08245176  0F 95 05 CC CC CC CC          setne [CCCCCCCCH] ; %Q1+0

0824517D  61                            popad
0824517E  5D                            pop ebp

0824517F  C3                            ret

END_PROGRAM


**************************************************
	Target variable image generation
**************************************************


*** INPUT:
08245180  C3                            ret


*** OUTPUT:
08245181  C3                            ret



**************************************************
	Task Init init code
**************************************************

08245182  55                            push ebp
08245183  8B EC                         mov ebp, esp

08245185  8B E5                         mov esp, ebp
08245187  5D                            pop ebp

08245188  C3                            ret

**************************************************
	List program: InitParDB
**************************************************

PROGRAM InitParDB

        VAR
warningsKiller : USINT;
dummyCrc32 : UDINT;
	END_VAR

END_PROGRAM

082451A0  55                            push ebp
082451A1  8B EC                         mov ebp, esp
082451A3  60                            pushad

#0		{SRC:InitParDB}
#1		(*$WAITSWITCH$*)
#2		
#3			(* dummyCrc32 := 541599759; *)
#4			MOVE		541599759,dummyCrc32	{LNXT:3|5|-1}
(*) UDINT
082451A4  B8 0F 28 48 20                mov eax, 2048280FH
082451A9  89 05 CC CC CC CC             mov [CCCCCCCCH], eax ; $$DATA$$+60

#5		
#6			(* warningsKiller := sysDBase_SetExtTable( ADR( $$ParDB ), $$ParDBLength ); *)
#7			ADR		$$ParDB	{LNXT:5|3|-1}
(*) UDINT
082451AF  B8 CC CC CC CC                mov eax, CCCCCCCCH ; $$CODE$$+336

#8			sysDBase_SetExtTable		$$ParDBLength	{LNXT:5|3|-1}
(*) @USINT
082451B4  68 16 00 00 00                push 22
082451B9  8B C8                         mov ecx, eax
082451BB  51                            push ecx
082451BC  B9 CC CC CC CC                mov ecx, CCCCCCCCH ; sysDBase_SetExtTable
082451C1  FF D1                         call ecx
082451C3  81 C4 08 00 00 00             add esp, 8

#9			ST		warningsKiller	{LNXT:5|3|-1}
(*) USINT
082451C9  88 05 CC CC CC CC             mov [CCCCCCCCH], al ; $$DATA$$+59

082451CF  61                            popad
082451D0  5D                            pop ebp

082451D1  C3                            ret

END_PROGRAM


**************************************************
	Target variable image generation
**************************************************


*** INPUT:
082451D2  C3                            ret


*** OUTPUT:
082451D3  C3                            ret



**************************************************
	Task Serv init code
**************************************************

082451D4  55                            push ebp
082451D5  8B EC                         mov ebp, esp

082451D7  8B E5                         mov esp, ebp
082451D9  5D                            pop ebp

082451DA  C3                            ret

**************************************************
	List program: sr_pressure
**************************************************

PROGRAM sr_pressure

        VAR
tmp_test : INT;
	END_VAR

END_PROGRAM

082451F0  55                            push ebp
082451F1  8B EC                         mov ebp, esp
082451F3  60                            pushad

#0		{SRC:sr_pressure}
#1		(*$WAITSWITCH$*)
#2		
#3			(* Pressure := to_int(to_real(i_adc_pressure )/10); *)
#4			LDP0		i_adc_pressure	{LNXT:2|2|-1}
(*) UDINT
#5			to_real	{LNXT:2|2|-1}
(*) UDINT
082451F4  0F BF 05 CC CC CC CC          movsx eax, word ptr [CCCCCCCCH] ; $$DATA$$+408
082451FB  50                            push eax
082451FC  DB 04 24                      fild dword ptr [esp]
082451FF  58                            pop eax

#6			DIV		10	{LNXT:2|2|-1}
(*) REAL
08245200  68 0A 00 00 00                push 10
08245205  DA 34 24                      fidiv [esp]
08245208  81 C4 04 00 00 00             add esp, 4

#7			to_int	{LNXT:2|2|-1}
(*) REAL
0824520E  81 EC 08 00 00 00             sub esp, 8
08245214  DF 3C 24                      fistp qword ptr [esp]
08245217  58                            pop eax
08245218  81 C4 04 00 00 00             add esp, 4

#8			ST		Pressure	{LNXT:2|2|-1}
(*) INT
0824521E  66 89 05 CC CC CC CC          mov [CCCCCCCCH], ax ; %M110+0

END_PROGRAM
**************************************************
	List program: sr_counters
**************************************************

PROGRAM sr_counters

        VAR
kw_trig : R_TRIG;
q_trig : R_TRIG;
kw_pulses_per_acs : UINT;
q_pulses_per_acs : UINT;
test_freq : UDINT;
	END_VAR

END_PROGRAM

#0		{SRC:sr_counters}
#1		(*$WAITSWITCH$*)
#2		
#3			(* kw_pulses_per_acs 	:= 8000; *)
#4			MOVE		8000,kw_pulses_per_acs	{LNXT:2|3|-1}
(*) UDINT
08245225  B8 40 1F 00 00                mov eax, 1F40H
0824522A  66 89 05 CC CC CC CC          mov [CCCCCCCCH], ax ; $$DATA$$+244

#5		
#6			(* q_pulses_per_acs	:= 1; *)
#7			MOVE		1,q_pulses_per_acs	{LNXT:3|15|-1}
(*) UINT
08245231  B8 01 00 00 00                mov eax, 01H
08245236  66 89 05 CC CC CC CC          mov [CCCCCCCCH], ax ; $$DATA$$+246

#8		
#9		
#10			(* IF fdi_q_cnt >= q_pulses_per_acs *)
#11			LD		fdi_q_cnt	{LNXT:15|-1|-1}
(*) UNDEF
0824523D  8B 05 CC CC CC CC             mov eax, [CCCCCCCCH] ; %M500+0

#12			GE		q_pulses_per_acs	{LNXT:15|-1|-1}
(*) UDINT
08245243  33 C9                         xor ecx, ecx
08245245  66 8B 0D CC CC CC CC          mov cx, [CCCCCCCCH] ; $$DATA$$+246
0824524C  3B C1                         cmp eax, ecx
0824524E  0F 93 C0                      setae al
08245251  25 FF 00 00 00                and eax, 0FFh

#13			JMPCN	$label0	{LNXT:15|16|20}
(-) BOOL
08245256  84 C0                         test al, al
08245258  90 74 22 90 90 90             je 0824527DH

#14		
#15			(* THEN *)
#16		
#17				(* q_counter := q_counter + 1; *)
#18				LD		q_counter	{LNXT:16|17|-1}
(*) UNDEF
0824525E  8B 05 CC CC CC CC             mov eax, [CCCCCCCCH] ; %M110+8

#19				ADD		1	{LNXT:16|17|-1}
(*) DWORD
08245264  05 01 00 00 00                add eax, 1

#20				ST		q_counter	{LNXT:16|17|-1}
(*) DWORD
08245269  89 05 CC CC CC CC             mov [CCCCCCCCH], eax ; %M110+8

#21		
#22				(* fdi_q_reset := true; *)
#23				MOVE		true,fdi_q_reset	{LNXT:17|20|-1}
(*) DWORD
0824526F  B8 01 00 00 00                mov eax, 01H
08245274  84 C0                         test al, al
08245276  0F 95 05 CC CC CC CC          setne [CCCCCCCCH] ; %M550+0

#24		
#25		$label0:
#26			(* END_IF *)
#27		
#28			(* q_value := to_int((3600 * to_real(fdi_q_freq)) / (to_real(q_pulses_per_acs) / 1)); *)
#29			LDP0		fdi_q_freq	{LNXT:20|2|-1}
(*) BOOL
#30			to_real	{LNXT:20|2|-1}
(*) BOOL
0824527D  8B 05 CC CC CC CC             mov eax, [CCCCCCCCH] ; %M500+4
08245283  68 00 00 00 00                push 0
08245288  50                            push eax
08245289  DF 2C 24                      fild qword ptr [esp]
0824528C  81 C4 08 00 00 00             add esp, 8

#31			MUL		3600	{LNXT:20|2|-1}
(*) REAL
08245292  68 10 0E 00 00                push 3600
08245297  DA 0C 24                      fimul [esp]
0824529A  81 C4 04 00 00 00             add esp, 4

#32			DIV(		0	{LNXT:20|2|-1}
(*) REAL
082452A0  81 EC 04 00 00 00             sub esp, 4
082452A6  D9 1C 24                      fstp dword ptr [esp]
082452A9  B8 00 00 00 00                mov eax, 00H

#33			LDP0		q_pulses_per_acs	{LNXT:20|2|-1}
(*) USINT
#34			to_real	{LNXT:20|2|-1}
(*) USINT
082452AE  33 C0                         xor eax, eax
082452B0  66 8B 05 CC CC CC CC          mov ax, [CCCCCCCCH] ; $$DATA$$+246
082452B7  68 00 00 00 00                push 0
082452BC  50                            push eax
082452BD  DF 2C 24                      fild qword ptr [esp]
082452C0  81 C4 08 00 00 00             add esp, 8

#35			DIV		1	{LNXT:20|2|-1}
(*) REAL
082452C6  68 01 00 00 00                push 1
082452CB  DA 34 24                      fidiv [esp]
082452CE  81 C4 04 00 00 00             add esp, 4

#36			)	{LNXT:20|2|-1}
(*) REAL
082452D4  81 EC 04 00 00 00             sub esp, 4
082452DA  D9 1C 24                      fstp dword ptr [esp]
082452DD  D9 44 24 04                   fld dword ptr 4[esp]
082452E1  D8 34 24                      fdiv dword ptr [esp]
082452E4  81 C4 08 00 00 00             add esp, 8

#37			to_int	{LNXT:20|2|-1}
(*) REAL
082452EA  81 EC 08 00 00 00             sub esp, 8
082452F0  DF 3C 24                      fistp qword ptr [esp]
082452F3  58                            pop eax
082452F4  81 C4 04 00 00 00             add esp, 4

#38			ST		q_value	{LNXT:20|2|-1}
(*) INT
082452FA  66 89 05 CC CC CC CC          mov [CCCCCCCCH], ax ; %M110+14

END_PROGRAM
**************************************************
	List program: sr_save_counters
**************************************************

PROGRAM sr_save_counters

        VAR
power_err : R_TRIG;
ton_start_up : TON;
res_q : BOOL;
res_kw : BOOL;
	END_VAR

END_PROGRAM

#0		{SRC:sr_save_counters}
#1		(*$WAITSWITCH$*)
#2		
#3			(* ton_start_up *)
#4			MOVE		true,ton_start_up.IN	{LNXT:1|-1|-1}
(*) UDINT
08245301  B8 01 00 00 00                mov eax, 01H
08245306  84 C0                         test al, al
08245308  0F 95 05 CC CC CC CC          setne [CCCCCCCCH] ; $$DATA$$+254

#5			MOVE		5000,ton_start_up.PT	{LNXT:1|-1|-1}
(*) BOOL
0824530F  B8 88 13 00 00                mov eax, 1388H
08245314  89 05 CC CC CC CC             mov [CCCCCCCCH], eax ; $$DATA$$+255

#6			CAL		ton_start_up	{LNXT:1|2|-1}
(*) UDINT
0824531A  50                            push eax
0824531B  BB CC CC CC CC                mov ebx, CCCCCCCCH ; $$DATA$$+250
08245320  E8 94 F1 FF FF                call 082444B9H ; $$CODE$$+17593
08245325  58                            pop eax

#7		
#8			(* power_err *)
#9			LD		ton_start_up.Q	{LNXT:2|-1|-1}
(*) UNDEF
08245326  33 C0                         xor eax, eax
08245328  8A 05 CC CC CC CC             mov al, [CCCCCCCCH] ; $$DATA$$+259

#10			AND		i_rnpp	{LNXT:2|-1|-1}
(*) BOOL
0824532E  33 C9                         xor ecx, ecx
08245330  8A 0D CC CC CC CC             mov cl, [CCCCCCCCH] ; $$DATA$$+406
08245336  23 C1                         and eax, ecx

#11			ST		power_err.clk	{LNXT:2|-1|-1}
(*) BOOL
08245338  84 C0                         test al, al
0824533A  0F 95 05 CC CC CC CC          setne [CCCCCCCCH] ; $$DATA$$+273

#12			CAL		power_err	{LNXT:2|3|-1}
(*) BOOL
08245341  50                            push eax
08245342  BB CC CC CC CC                mov ebx, CCCCCCCCH ; $$DATA$$+272
08245347  E8 44 F1 FF FF                call 08244490H ; $$CODE$$+17552
0824534C  58                            pop eax

#13		
#14		
#15			(* IF power_err.q *)
#16			LD		power_err.q	{LNXT:3|-1|-1}
(*) UNDEF
0824534D  33 C0                         xor eax, eax
0824534F  8A 05 CC CC CC CC             mov al, [CCCCCCCCH] ; $$DATA$$+274

#17			JMPCN	$label0	{LNXT:3|4|1}
(-) BOOL
08245355  84 C0                         test al, al
08245357  0F 84 82 00 00 00             je 082453DFH

#18		
#19			(* THEN *)
#20		
#21		
#22				(* IF epprom_q_cnt <> q_counter *)
#23				LD		epprom_q_cnt	{LNXT:4|-1|-1}
(*) UNDEF
0824535D  8B 05 CC CC CC CC             mov eax, [CCCCCCCCH] ; %M101+0

#24				NE		q_counter	{LNXT:4|-1|-1}
(*) DWORD
08245363  3B 05 CC CC CC CC             cmp eax, [CCCCCCCCH] ; %M110+8
08245369  0F 95 C0                      setne al
0824536C  25 FF 00 00 00                and eax, 0FFh

#25				JMPCN	$label1	{LNXT:4|4|5}
(-) BOOL
08245371  84 C0                         test al, al
08245373  90 74 28 90 90 90             je 0824539EH

#26		
#27				(* THEN *)
#28		
#29					(* res_q := sysWriteParUINT(ADR(epprom_q_cnt), q_counter); *)
#30					ADR		epprom_q_cnt	{LNXT:4|5|-1}
(*) BOOL
08245379  B8 CC CC CC CC                mov eax, CCCCCCCCH ; %M101+0

#31					sysWriteParUINT		q_counter	{LNXT:4|5|-1}
(*) @DWORD
0824537E  8B 0D CC CC CC CC             mov ecx, [CCCCCCCCH] ; %M110+8
08245384  51                            push ecx
08245385  8B C8                         mov ecx, eax
08245387  51                            push ecx
08245388  B9 CC CC CC CC                mov ecx, CCCCCCCCH ; sysWriteParUINT
0824538D  FF D1                         call ecx
0824538F  81 C4 08 00 00 00             add esp, 8

#32					ST		res_q	{LNXT:4|5|-1}
(*) BOOL
08245395  84 C0                         test al, al
08245397  0F 95 05 CC CC CC CC          setne [CCCCCCCCH] ; $$DATA$$+243

#33		
#34		$label1:
#35				(* END_IF *)
#36		
#37		
#38				(* IF epprom_kw_cnt <> kw_counter *)
#39				LD		epprom_kw_cnt	{LNXT:5|-1|-1}
(*) UNDEF
0824539E  8B 05 CC CC CC CC             mov eax, [CCCCCCCCH] ; %M101+8

#40				NE		kw_counter	{LNXT:5|-1|-1}
(*) DWORD
082453A4  3B 05 CC CC CC CC             cmp eax, [CCCCCCCCH] ; %M110+4
082453AA  0F 95 C0                      setne al
082453AD  25 FF 00 00 00                and eax, 0FFh

#41				JMPCN	$label2	{LNXT:5|5|1}
(-) BOOL
082453B2  84 C0                         test al, al
082453B4  90 74 28 90 90 90             je 082453DFH

#42		
#43				(* THEN *)
#44		
#45					(* res_kw := sysWriteParUINT(ADR(epprom_kw_cnt), kw_counter); *)
#46					ADR		epprom_kw_cnt	{LNXT:5|1|-1}
(*) BOOL
082453BA  B8 CC CC CC CC                mov eax, CCCCCCCCH ; %M101+8

#47					sysWriteParUINT		kw_counter	{LNXT:5|1|-1}
(*) @DWORD
082453BF  8B 0D CC CC CC CC             mov ecx, [CCCCCCCCH] ; %M110+4
082453C5  51                            push ecx
082453C6  8B C8                         mov ecx, eax
082453C8  51                            push ecx
082453C9  B9 CC CC CC CC                mov ecx, CCCCCCCCH ; sysWriteParUINT
082453CE  FF D1                         call ecx
082453D0  81 C4 08 00 00 00             add esp, 8

#48					ST		res_kw	{LNXT:5|1|-1}
(*) BOOL
082453D6  84 C0                         test al, al
082453D8  0F 95 05 CC CC CC CC          setne [CCCCCCCCH] ; $$DATA$$+283

END_PROGRAM
**************************************************
	List program: sr_ATS_Ctrl
**************************************************

PROGRAM sr_ATS_Ctrl

        VAR
TON_StartUp_1 : TON;
TON_StartUp_2 : TON;
stopping_timer : TON;
downtimeIN : BOOL;
washing_timer : TON;
checkWashAndStart : CheckWashAndStart;
isRunningWash : BOOL;
onWash : BOOL := false;
time_sec : INT := 4000;
	END_VAR

END_PROGRAM

#0		{SRC:sr_ATS_Ctrl}
#1		(*$WAITSWITCH$*)
#2		
#3		
#4			(* IF i_pb_rem = 1 And
#5		Not Alarms.0 And 
#6		Not Alarms.3 And 
#7		Not Alarms.4 And 
#8		Not Alarms.5 And 
#9		Not Alarms.7 *)
#10			LD		Alarms.7	{LNXT:2|-1|-1}
(*) UNDEF
082453DF  33 C0                         xor eax, eax
082453E1  66 8B 05 CC CC CC CC          mov ax, [CCCCCCCCH] ; %M110+32
082453E8  C1 E8 07                      shr eax, 7
082453EB  25 01 00 00 00                and eax, 1

#11			NOT	{LNXT:2|-1|-1}
(*) BOOL
082453F0  84 C0                         test al, al
082453F2  0F 94 C0                      sete al

#12			AND(		Alarms.5	{LNXT:2|-1|-1}
(*) BOOL
082453F5  50                            push eax
082453F6  33 C0                         xor eax, eax
082453F8  66 8B 05 CC CC CC CC          mov ax, [CCCCCCCCH] ; %M110+32
082453FF  C1 E8 05                      shr eax, 5
08245402  25 01 00 00 00                and eax, 1

#13			NOT	{LNXT:2|-1|-1}
(*) BOOL
08245407  84 C0                         test al, al
08245409  0F 94 C0                      sete al

#14			AND(		Alarms.4	{LNXT:2|-1|-1}
(*) BOOL
0824540C  50                            push eax
0824540D  33 C0                         xor eax, eax
0824540F  66 8B 05 CC CC CC CC          mov ax, [CCCCCCCCH] ; %M110+32
08245416  C1 E8 04                      shr eax, 4
08245419  25 01 00 00 00                and eax, 1

#15			NOT	{LNXT:2|-1|-1}
(*) BOOL
0824541E  84 C0                         test al, al
08245420  0F 94 C0                      sete al

#16			AND(		Alarms.3	{LNXT:2|-1|-1}
(*) BOOL
08245423  50                            push eax
08245424  33 C0                         xor eax, eax
08245426  66 8B 05 CC CC CC CC          mov ax, [CCCCCCCCH] ; %M110+32
0824542D  C1 E8 03                      shr eax, 3
08245430  25 01 00 00 00                and eax, 1

#17			NOT	{LNXT:2|-1|-1}
(*) BOOL
08245435  84 C0                         test al, al
08245437  0F 94 C0                      sete al

#18			AND(		Alarms.0	{LNXT:2|-1|-1}
(*) BOOL
0824543A  50                            push eax
0824543B  33 C0                         xor eax, eax
0824543D  66 8B 05 CC CC CC CC          mov ax, [CCCCCCCCH] ; %M110+32
08245444  25 01 00 00 00                and eax, 1

#19			NOT	{LNXT:2|-1|-1}
(*) BOOL
08245449  84 C0                         test al, al
0824544B  0F 94 C0                      sete al

#20			AND(		i_pb_rem	{LNXT:2|-1|-1}
(*) BOOL
0824544E  50                            push eax
0824544F  0F BF 05 CC CC CC CC          movsx eax, word ptr [CCCCCCCCH] ; $$DATA$$+394

#21			EQ		1	{LNXT:2|-1|-1}
(*) INT
08245456  3D 01 00 00 00                cmp eax, 1
0824545B  0F 94 C0                      sete al
0824545E  25 FF 00 00 00                and eax, 0FFh

#22			)	{LNXT:2|-1|-1}
(*) BOOL
08245463  8B C8                         mov ecx, eax
08245465  58                            pop eax
08245466  23 C1                         and eax, ecx

#23			)	{LNXT:2|-1|-1}
(*) BOOL
08245468  8B C8                         mov ecx, eax
0824546A  58                            pop eax
0824546B  23 C1                         and eax, ecx

#24			)	{LNXT:2|-1|-1}
(*) BOOL
0824546D  8B C8                         mov ecx, eax
0824546F  58                            pop eax
08245470  23 C1                         and eax, ecx

#25			)	{LNXT:2|-1|-1}
(*) BOOL
08245472  8B C8                         mov ecx, eax
08245474  58                            pop eax
08245475  23 C1                         and eax, ecx

#26			)	{LNXT:2|-1|-1}
(*) BOOL
08245477  8B C8                         mov ecx, eax
08245479  58                            pop eax
0824547A  23 C1                         and eax, ecx

#27			JMPCN	$label0	{LNXT:2|9|30}
(-) BOOL
0824547C  84 C0                         test al, al
0824547E  0F 84 C9 00 00 00             je 0824554DH

#28		
#29			(* THEN *)
#30		
#31		
#32				(* IF CMD.0 *)
#33				LD		CMD.0	{LNXT:9|-1|-1}
(*) UNDEF
08245484  33 C0                         xor eax, eax
08245486  66 8B 05 CC CC CC CC          mov ax, [CCCCCCCCH] ; %M110+34
0824548D  25 01 00 00 00                and eax, 1

#34				JMPCN	$label2	{LNXT:9|10|26}
(-) BOOL
08245492  84 C0                         test al, al
08245494  0F 84 A0 00 00 00             je 0824553AH

#35		
#36				(* THEN *)
#37		
#38					(* checkWashAndStart *)
#39					MOVE		o_val_close_fall,checkWashAndStart.o_val_close_fall_FB	{LNXT:10|-1|-1}
(*) BOOL
0824549A  B8 CC CC CC CC                mov eax, CCCCCCCCH ; %Q1+1
0824549F  89 05 CC CC CC CC             mov [CCCCCCCCH], eax ; $$DATA$$+185

#40					MOVE		o_val_close_R,checkWashAndStart.o_val_close_R_FB	{LNXT:11|-1|-1}
(*) BOOL^
082454A5  B8 CC CC CC CC                mov eax, CCCCCCCCH ; %Q1+3
082454AA  89 05 CC CC CC CC             mov [CCCCCCCCH], eax ; $$DATA$$+177

#41					MOVE		o_val_open_fall,checkWashAndStart.o_val_open_fall_FB	{LNXT:12|-1|-1}
(*) BOOL^
082454B0  B8 CC CC CC CC                mov eax, CCCCCCCCH ; %Q1+0
082454B5  89 05 CC CC CC CC             mov [CCCCCCCCH], eax ; $$DATA$$+181

#42					MOVE		o_val_open_R,checkWashAndStart.o_val_open_R_FB	{LNXT:13|-1|-1}
(*) BOOL^
082454BB  B8 CC CC CC CC                mov eax, CCCCCCCCH ; %Q1+2
082454C0  89 05 CC CC CC CC             mov [CCCCCCCCH], eax ; $$DATA$$+173

#43					MOVE		sv_washing,checkWashAndStart.sv_washing_FB	{LNXT:14|-1|-1}
(*) BOOL^
082454C6  B8 CC CC CC CC                mov eax, CCCCCCCCH ; %M110+38
082454CB  89 05 CC CC CC CC             mov [CCCCCCCCH], eax ; $$DATA$$+169

#44					MOVE		q_start_ats,checkWashAndStart.q_start_ats_FB	{LNXT:15|-1|-1}
(*) BOOL^
082454D1  B8 CC CC CC CC                mov eax, CCCCCCCCH ; %Q1+7
082454D6  89 05 CC CC CC CC             mov [CCCCCCCCH], eax ; $$DATA$$+189

#45					MOVE		time_sec,checkWashAndStart.ep_time_wash_FB	{LNXT:16|-1|-1}
(*) BOOL^
082454DC  B8 CC CC CC CC                mov eax, CCCCCCCCH ; $$DATA$$+230
082454E1  89 05 CC CC CC CC             mov [CCCCCCCCH], eax ; $$DATA$$+193

#46					MOVE		i_val_state,checkWashAndStart.i_val_state_FB	{LNXT:17|-1|-1}
(*) INT^
082454E7  B8 CC CC CC CC                mov eax, CCCCCCCCH ; $$DATA$$+396
082454EC  89 05 CC CC CC CC             mov [CCCCCCCCH], eax ; $$DATA$$+197

#47					MOVE		di_val_open_state_fall,checkWashAndStart.di_val_open_state_fall_FB	{LNXT:18|-1|-1}
(*) INT^
082454F2  B8 CC CC CC CC                mov eax, CCCCCCCCH ; $$DATA$$+398
082454F7  89 05 CC CC CC CC             mov [CCCCCCCCH], eax ; $$DATA$$+201

#48					MOVE		di_val_close_state_fall,checkWashAndStart.di_val_close_state_fall_FB	{LNXT:19|-1|-1}
(*) INT^
082454FD  B8 CC CC CC CC                mov eax, CCCCCCCCH ; $$DATA$$+400
08245502  89 05 CC CC CC CC             mov [CCCCCCCCH], eax ; $$DATA$$+205

#49					MOVE		di_val_open_state_R,checkWashAndStart.di_val_open_state_R_FB	{LNXT:20|-1|-1}
(*) INT^
08245508  B8 CC CC CC CC                mov eax, CCCCCCCCH ; $$DATA$$+402
0824550D  89 05 CC CC CC CC             mov [CCCCCCCCH], eax ; $$DATA$$+209

#50					MOVE		di_val_close_state_R,checkWashAndStart.di_val_close_state_R_FB	{LNXT:21|-1|-1}
(*) INT^
08245513  B8 CC CC CC CC                mov eax, CCCCCCCCH ; $$DATA$$+404
08245518  89 05 CC CC CC CC             mov [CCCCCCCCH], eax ; $$DATA$$+213

#51					MOVE		Alarms_Val,checkWashAndStart.Alarm_Val_FB	{LNXT:22|-1|-1}
(*) BOOL^
0824551E  B8 CC CC CC CC                mov eax, CCCCCCCCH ; %M110+40
08245523  89 05 CC CC CC CC             mov [CCCCCCCCH], eax ; $$DATA$$+217

#52					CAL		checkWashAndStart	{LNXT:10|82|-1}
(*) WORD^
08245529  50                            push eax
0824552A  BB CC CC CC CC                mov ebx, CCCCCCCCH ; $$DATA$$+66
0824552F  E8 B6 F1 FF FF                call 082446EAH ; $$CODE$$+18154
08245534  58                            pop eax

#53					JMP		$label3	{LNXT:9|10|26}
(-) WORD^
08245535  EB 11 90 90 90                jmp 08245548H

#54		$label2:
#55		
#56				(* ELSE *)
#57		
#58					(* q_start_ats := False; *)
#59					MOVE		False,q_start_ats	{LNXT:26|82|-1}
(*) WORD^
0824553A  B8 00 00 00 00                mov eax, 00H
0824553F  84 C0                         test al, al
08245541  0F 95 05 CC CC CC CC          setne [CCCCCCCCH] ; %Q1+7

#60		
#61		$label3:
#62				(* END_IF *)
#63				JMP		$label1	{LNXT:2|9|30}
(-) BOOL
08245548  EB 35 90 90 90                jmp 0824557FH

#64		$label0:
#65		
#66			(* ELSE *)
#67		
#68				(* CMD.0 := False; *)
#69				MOVE		False,CMD.0	{LNXT:30|31|-1}
(*) BOOL
0824554D  B8 00 00 00 00                mov eax, 00H
08245552  84 C0                         test al, al
08245554  90 75 11 90 90 90             jne 00000014H@
0824555A  66 0F BA 35 CC CC CC CC 00    btr word ptr [CCCCCCCCH], 0 ; %M110+34
08245563  EB 0C 90 90 90                jmp 0000000EH@
08245568  66 0F BA 2D CC CC CC CC 00    bts word ptr [CCCCCCCCH], 0 ; %M110+34

#70		
#71				(* q_start_ats := False; *)
#72				MOVE		False,q_start_ats	{LNXT:31|82|-1}
(*) WORD
08245571  B8 00 00 00 00                mov eax, 00H
08245576  84 C0                         test al, al
08245578  0F 95 05 CC CC CC CC          setne [CCCCCCCCH] ; %Q1+7

#73		
#74		$label1:
#75			(* END_IF *)
#76		
#77		
#78			(* IF q_start_ats *)
#79			LD		q_start_ats	{LNXT:82|-1|-1}
(*) UNDEF
0824557F  33 C0                         xor eax, eax
08245581  8A 05 CC CC CC CC             mov al, [CCCCCCCCH] ; %Q1+7

#80			NOT	{LNXT:82|-1|-1}
(*) BOOL
08245587  84 C0                         test al, al
08245589  0F 94 C0                      sete al

#81			JMPCN	$label4	{LNXT:82|83|85}
(-) BOOL
0824558C  84 C0                         test al, al
0824558E  90 74 16 90 90 90             je 082455A7H

#82		
#83			(* THEN *)
#84		
#85				(* downtimeIN:=true; *)
#86				MOVE		true,downtimeIN	{LNXT:83|95|-1}
(*) BOOL
08245594  B8 01 00 00 00                mov eax, 01H
08245599  84 C0                         test al, al
0824559B  0F 95 05 CC CC CC CC          setne [CCCCCCCCH] ; $$DATA$$+229

#87				JMP		$label5	{LNXT:82|83|85}
(-) BOOL
082455A2  EB 11 90 90 90                jmp 082455B5H

#88		$label4:
#89		
#90			(* ELSE *)
#91		
#92				(* downtimeIN:=false; *)
#93				MOVE		false,downtimeIN	{LNXT:85|95|-1}
(*) BOOL
082455A7  B8 00 00 00 00                mov eax, 00H
082455AC  84 C0                         test al, al
082455AE  0F 95 05 CC CC CC CC          setne [CCCCCCCCH] ; $$DATA$$+229

#94		
#95		$label5:
#96			(* END_IF *)
#97		
#98			(* Alarms.2 := i_sns_door; *)
#99			MOVE		i_sns_door,Alarms.2	{LNXT:95|98|-1}
(*) BOOL
082455B5  33 C0                         xor eax, eax
082455B7  8A 05 CC CC CC CC             mov al, [CCCCCCCCH] ; $$DATA$$+405
082455BD  84 C0                         test al, al
082455BF  90 75 11 90 90 90             jne 00000014H@
082455C5  66 0F BA 35 CC CC CC CC 02    btr word ptr [CCCCCCCCH], 2 ; %M110+32
082455CE  EB 0C 90 90 90                jmp 0000000EH@
082455D3  66 0F BA 2D CC CC CC CC 02    bts word ptr [CCCCCCCCH], 2 ; %M110+32

#100		
#101			(* Alarms.3 := i_rnpp; *)
#102			MOVE		i_rnpp,Alarms.3	{LNXT:98|104|-1}
(*) BOOL
082455DC  33 C0                         xor eax, eax
082455DE  8A 05 CC CC CC CC             mov al, [CCCCCCCCH] ; $$DATA$$+406
082455E4  84 C0                         test al, al
082455E6  90 75 11 90 90 90             jne 00000014H@
082455EC  66 0F BA 35 CC CC CC CC 03    btr word ptr [CCCCCCCCH], 3 ; %M110+32
082455F5  EB 0C 90 90 90                jmp 0000000EH@
082455FA  66 0F BA 2D CC CC CC CC 03    bts word ptr [CCCCCCCCH], 3 ; %M110+32

#103		
#104			(* Alarms.5 := i_no_alm_ats; *)
#105			MOVE		i_no_alm_ats,Alarms.5	{LNXT:104|145|-1}
(*) BOOL
08245603  33 C0                         xor eax, eax
08245605  8A 05 CC CC CC CC             mov al, [CCCCCCCCH] ; $$DATA$$+407
0824560B  84 C0                         test al, al
0824560D  90 75 11 90 90 90             jne 00000014H@
08245613  66 0F BA 35 CC CC CC CC 05    btr word ptr [CCCCCCCCH], 5 ; %M110+32
0824561C  EB 0C 90 90 90                jmp 0000000EH@
08245621  66 0F BA 2D CC CC CC CC 05    bts word ptr [CCCCCCCCH], 5 ; %M110+32

#106		
#107		
#108			(* IF CMD.1 *)
#109			LD		CMD.1	{LNXT:145|-1|-1}
(*) UNDEF
0824562A  33 C0                         xor eax, eax
0824562C  66 8B 05 CC CC CC CC          mov ax, [CCCCCCCCH] ; %M110+34
08245633  C1 E8 01                      shr eax, 1
08245636  25 01 00 00 00                and eax, 1

#110			JMPCN	$label6	{LNXT:145|146|2}
(-) BOOL
0824563B  84 C0                         test al, al
0824563D  90 74 33 90 90 90             je 08245673H

#111		
#112			(* THEN *)
#113		
#114				(* Alarms := 0; *)
#115				MOVE		0,Alarms	{LNXT:146|147|-1}
(*) BOOL
08245643  B8 00 00 00 00                mov eax, 00H
08245648  66 89 05 CC CC CC CC          mov [CCCCCCCCH], ax ; %M110+32

#116		
#117				(* CMD.1 := False; *)
#118				MOVE		False,CMD.1	{LNXT:147|2|-1}
(*) WORD
0824564F  B8 00 00 00 00                mov eax, 00H
08245654  84 C0                         test al, al
08245656  90 75 11 90 90 90             jne 00000014H@
0824565C  66 0F BA 35 CC CC CC CC 01    btr word ptr [CCCCCCCCH], 1 ; %M110+34
08245665  EB 0C 90 90 90                jmp 0000000EH@
0824566A  66 0F BA 2D CC CC CC CC 01    bts word ptr [CCCCCCCCH], 1 ; %M110+34

08245673  61                            popad
08245674  5D                            pop ebp

08245675  C3                            ret

END_PROGRAM


**************************************************
	Target variable image generation
**************************************************


*** INPUT:
08245676  55                            push ebp
08245677  8B EC                         mov ebp, esp

08245679  66 8B 0D CC CC CC CC          mov cx, [CCCCCCCCH] ; %I1+14
08245680  66 89 0D CC CC CC CC          mov [CCCCCCCCH], cx ; $$DATA$$+394

08245687  66 8B 0D CC CC CC CC          mov cx, [CCCCCCCCH] ; %I1+4
0824568E  66 89 0D CC CC CC CC          mov [CCCCCCCCH], cx ; $$DATA$$+396

08245695  66 8B 0D CC CC CC CC          mov cx, [CCCCCCCCH] ; %I1+6
0824569C  66 89 0D CC CC CC CC          mov [CCCCCCCCH], cx ; $$DATA$$+398

082456A3  66 8B 0D CC CC CC CC          mov cx, [CCCCCCCCH] ; %I1+8
082456AA  66 89 0D CC CC CC CC          mov [CCCCCCCCH], cx ; $$DATA$$+400

082456B1  66 8B 0D CC CC CC CC          mov cx, [CCCCCCCCH] ; %I1+10
082456B8  66 89 0D CC CC CC CC          mov [CCCCCCCCH], cx ; $$DATA$$+402

082456BF  8A 0D CC CC CC CC             mov cl, [CCCCCCCCH] ; %I0+0
082456C5  88 0D CC CC CC CC             mov [CCCCCCCCH], cl ; $$DATA$$+404

082456CB  8A 0D CC CC CC CC             mov cl, [CCCCCCCCH] ; %I0+3
082456D1  88 0D CC CC CC CC             mov [CCCCCCCCH], cl ; $$DATA$$+405

082456D7  8A 0D CC CC CC CC             mov cl, [CCCCCCCCH] ; %I0+4
082456DD  88 0D CC CC CC CC             mov [CCCCCCCCH], cl ; $$DATA$$+406

082456E3  8A 0D CC CC CC CC             mov cl, [CCCCCCCCH] ; %I0+6
082456E9  88 0D CC CC CC CC             mov [CCCCCCCCH], cl ; $$DATA$$+407

082456EF  66 8B 0D CC CC CC CC          mov cx, [CCCCCCCCH] ; %I1+0
082456F6  66 89 0D CC CC CC CC          mov [CCCCCCCCH], cx ; $$DATA$$+408

082456FD  8B E5                         mov esp, ebp
082456FF  5D                            pop ebp

08245700  C3                            ret


*** OUTPUT:
08245701  55                            push ebp
08245702  8B EC                         mov ebp, esp

08245704  8B E5                         mov esp, ebp
08245706  5D                            pop ebp

08245707  C3                            ret



**************************************************
	Task Timed init code
**************************************************

08245708  55                            push ebp
08245709  8B EC                         mov ebp, esp

Var init: V::SR_ATS_CTRL.TIME_SEC = 4000
0824570B  66 C7 05 CC CC CC CC A0 0F    mov word ptr [CCCCCCCCH], 0FA0H ; $$DATA$$+230

08245714  8B E5                         mov esp, ebp
08245716  5D                            pop ebp

08245717  C3                            ret



**************************************************
	Global init code
**************************************************

08245730  55                            push ebp
08245731  8B EC                         mov ebp, esp

Var init: V:EMBEDDEDELEMENTS:$$POUCBARRAY$$BACKGROUND = [?ATS_mdb.$$POUCB$$, 0]
08245733  B9 CC CC CC CC                mov ecx, CCCCCCCCH ; $$DATA$$+410
08245738  89 0D CC CC CC CC             mov [CCCCCCCCH], ecx ; $$DATA$$+284

Var init: V:EMBEDDEDELEMENTS:$$POUCBARRAY$$BOOT = [?sr_init_counters.$$POUCB$$, 0]
0824573E  B9 CC CC CC CC                mov ecx, CCCCCCCCH ; $$DATA$$+416
08245743  89 0D CC CC CC CC             mov [CCCCCCCCH], ecx ; $$DATA$$+292

Var init: V:EMBEDDEDELEMENTS:$$POUCBARRAY$$INIT = [?init_val.$$POUCB$$, 0]
08245749  B9 CC CC CC CC                mov ecx, CCCCCCCCH ; $$DATA$$+422
0824574E  89 0D CC CC CC CC             mov [CCCCCCCCH], ecx ; $$DATA$$+300

Var init: V:EMBEDDEDELEMENTS:$$POUCBARRAY$$SERV = [?InitParDB.$$POUCB$$, 0]
08245754  B9 CC CC CC CC                mov ecx, CCCCCCCCH ; $$DATA$$+428
08245759  89 0D CC CC CC CC             mov [CCCCCCCCH], ecx ; $$DATA$$+308

Var init: V:EMBEDDEDELEMENTS:$$POUCBARRAY$$TIMED = [?sr_pressure.$$POUCB$$, ?sr_counters.$$POUCB$$, ?sr_save_counters.$$POUCB$$, ?sr_ATS_Ctrl.$$POUCB$$, 0]
0824575F  B9 CC CC CC CC                mov ecx, CCCCCCCCH ; $$DATA$$+434
08245764  89 0D CC CC CC CC             mov [CCCCCCCCH], ecx ; $$DATA$$+316
0824576A  B9 CC CC CC CC                mov ecx, CCCCCCCCH ; $$DATA$$+440
0824576F  89 0D CC CC CC CC             mov [CCCCCCCCH], ecx ; $$DATA$$+320
08245775  B9 CC CC CC CC                mov ecx, CCCCCCCCH ; $$DATA$$+446
0824577A  89 0D CC CC CC CC             mov [CCCCCCCCH], ecx ; $$DATA$$+324
08245780  B9 CC CC CC CC                mov ecx, CCCCCCCCH ; $$DATA$$+452
08245785  89 0D CC CC CC CC             mov [CCCCCCCCH], ecx ; $$DATA$$+328

0824578B  8B E5                         mov esp, ebp
0824578D  5D                            pop ebp

0824578E  C3                            ret



**************************************************
	Global RETAIN init code
**************************************************

0824578F  55                            push ebp
08245790  8B EC                         mov ebp, esp

08245792  8B E5                         mov esp, ebp
08245794  5D                            pop ebp

08245795  C3                            ret



**************************************************
	Task $$VirtualTables init code
**************************************************

08245796  55                            push ebp
08245797  8B EC                         mov ebp, esp

08245799  8B E5                         mov esp, ebp
0824579B  5D                            pop ebp

0824579C  C3                            ret



********************************************
MEMORY MAP
********************************************

Code area type:          		       main code
Start code area:          		0000000008240000h
End code area:            		0000000008246144h
Code size:                		00006144h

Start local data area:    		00000000080C0000h
End local data area:      		00000000080C01CAh
Local data size:          		000001CAh

Start retentive data area:		0000000000000000h
End retentive data area:  		0000000000000000h
Retentive data size:      		00000000h

Start bit data area:      		0000000000000000h
End bit data area:        		0000000000000000h
Bit data size:            		00000000h



********************************************
CODE ID:                                8CD2EA0D
DEBUG MEMO ID:                          000034F7
FULL MEMO ID:                           0000892D
RELOCATION ADDR:                        0000000008240000
********************************************
