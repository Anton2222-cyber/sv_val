***********************************************************************
*
*	CODE GENERATION LISTING FOR: sw37
*	COMPILER VERSION: 6.0.0.52
*
***********************************************************************

**************************************************
	List function block: R_TRIG
**************************************************

FUNCTION_BLOCK R_TRIG

	{ DE:"<HTML>The output Q will remain FALSE as long as the input variable CLK is FALSE.<br>
As soon as CLK returns TRUE, Q will first return TRUE.<br><br>
This means each time the function is called up, Q will return FALSE until CLK has falling edge followed by an rising edge.<br><br>
<img src= r_trig.png>" }

        VAR_INPUT
clk : BOOL;	{ DE:"Input for edge detection" }
	END_VAR

        VAR_OUTPUT
q : BOOL;	{ DE:"Raising edge output" }
	END_VAR

        VAR
m : BOOL := FALSE;
	END_VAR

END_FUNCTION_BLOCK

07FA4490  55                            push ebp
07FA4491  8B EB                         mov ebp, ebx
07FA4493  57                            push edi

#0		{SRC:R_TRIG}
#1		
#2			LD		clk
(*) UNDEF
07FA4494  33 C0                         xor eax, eax
07FA4496  8A 45 01                      mov al, 1[ebp]

#3			ANDN	m
(*) BOOL
07FA4499  33 C9                         xor ecx, ecx
07FA449B  8A 4D 00                      mov cl, [ebp]
07FA449E  84 C9                         test cl, cl
07FA44A0  0F 94 C1                      sete cl
07FA44A3  23 C1                         and eax, ecx

#4			ST		q
(*) BOOL
07FA44A5  84 C0                         test al, al
07FA44A7  0F 95 45 02                   setne 2[ebp]

#5		
#6			LD		clk
(*) UNDEF
07FA44AB  33 C0                         xor eax, eax
07FA44AD  8A 45 01                      mov al, 1[ebp]

#7			ST		m
(*) BOOL
07FA44B0  84 C0                         test al, al
07FA44B2  0F 95 45 00                   setne [ebp]

07FA44B6  5F                            pop edi
07FA44B7  5D                            pop ebp

07FA44B8  C3                            ret


Frame allocation (hex):

	0000 bit  0: VAR m
	0001 bit  0: VAR clk
	0002 bit  0: VAR q

END_FUNCTION_BLOCK
**************************************************
	List function block: TON
**************************************************

FUNCTION_BLOCK TON

	{ DE:"<HTML>The TON block produces a delayed output Q of the input IN. The delay time is expressed in milliseconds on the PT input.</br></br>
<img src= tonscheme.png>
<ul>
<li>if IN is FALSE Q is false</li>
<li>Q becomes TRUE as IN remains TRUE for PT milliseconds</li>
<li>Q remains TRUE until IN remains TRUE</li>
</ul>" }

        VAR_INPUT
IN : BOOL;	{ DE:"Timer input source" }
PT : UDINT;	{ DE:"Preset time value (ms)" }
	END_VAR

        VAR_OUTPUT
Q : BOOL;	{ DE:"Timer output" }
ET : UDINT;	{ DE:"Timer current value (ms)" }
	END_VAR

        VAR_EXTERNAL
	{G:"System_Timers"}
sysTimer AT %MD0.0 : UDINT;	{ DE:"System timer [ms]" }
	END_VAR

        VAR
timStart : UDINT;	{ DE:"Time value at start of counting" }
	END_VAR

END_FUNCTION_BLOCK

07FA44B9  55                            push ebp
07FA44BA  8B EB                         mov ebp, ebx
07FA44BC  57                            push edi

#0		{SRC:TON}
#1		
#2			(*	Check if in counting	*)
#3		
#4			LD		IN
(*) UNDEF
07FA44BD  33 C0                         xor eax, eax
07FA44BF  8A 45 04                      mov al, 4[ebp]

#5			JMPCN	lReset
(-) BOOL
07FA44C2  84 C0                         test al, al
07FA44C4  90 74 61 90 90 90             je 07FA4528H

#6		
#7			(*	Check if Q is TRUE *)
#8			LD		Q
(*) UNDEF
07FA44CA  33 C0                         xor eax, eax
07FA44CC  8A 45 09                      mov al, 9[ebp]

#9			RETC
#10			
(-) BOOL
07FA44CF  84 C0                         test al, al
07FA44D1  90 75 6A 90 90 90             jne 07FA453EH

#11			(*	Check if already in counting *)
#12			LD		timStart
(*) UNDEF
07FA44D7  8B 45 00                      mov eax, [ebp]

#13			EQ		0
(*) UDINT
07FA44DA  3D 00 00 00 00                cmp eax, 0
07FA44DF  0F 94 C0                      sete al
07FA44E2  25 FF 00 00 00                and eax, 0FFh

#14			JMPCN	lUpdate
(-) BOOL
07FA44E7  84 C0                         test al, al
07FA44E9  90 74 0C 90 90 90             je 07FA44F8H

#15		
#16			(*	Start of counting *)
#17			LD		sysTimer
(*) UNDEF
07FA44EF  8B 05 CC CC CC CC             mov eax, [CCCCCCCCH] ; %M0+0

#18			ST		timStart
(*) UDINT
07FA44F5  89 45 00                      mov [ebp], eax

#19			
#20		lUpdate:
#21		
#22			(*	Update timer and check if time elapsed *)
#23			LD		sysTimer
(*) UNDEF
07FA44F8  8B 05 CC CC CC CC             mov eax, [CCCCCCCCH] ; %M0+0

#24			SUB		timStart
(*) UDINT
07FA44FE  2B 45 00                      sub eax, [ebp]

#25			ST		ET
(*) UDINT
07FA4501  89 45 0A                      mov 10[ebp], eax

#26			GE		PT
(*) UDINT
07FA4504  3B 45 05                      cmp eax, [ebp+5]
07FA4507  0F 93 C0                      setae al
07FA450A  25 FF 00 00 00                and eax, 0FFh

#27			ST		Q
(*) BOOL
07FA450F  84 C0                         test al, al
07FA4511  0F 95 45 09                   setne 9[ebp]

#28			RETCN
#29		
(-) BOOL
07FA4515  84 C0                         test al, al
07FA4517  90 74 24 90 90 90             je 07FA453EH

#30			(*	Limit actual time value *)
#31			LD		PT
(*) UNDEF
07FA451D  8B 45 05                      mov eax, 5[ebp]

#32			ST		ET
(*) UDINT
07FA4520  89 45 0A                      mov 10[ebp], eax

#33			RET
#34		
(-) UDINT
07FA4523  EB 19 90 90 90                jmp 07FA453EH

#35		lReset:
#36		
#37			(*	Reset status *)
#38			LD		0
(*) UNDEF
07FA4528  B8 00 00 00 00                mov eax, 00H

#39			ST		ET
(*) USINT
07FA452D  89 45 0A                      mov 10[ebp], eax

#40			ST		timStart
(*) UDINT
07FA4530  89 45 00                      mov [ebp], eax

#41			LD		FALSE
(*) UNDEF
07FA4533  B8 00 00 00 00                mov eax, 00H

#42			ST		Q
(*) BOOL
07FA4538  84 C0                         test al, al
07FA453A  0F 95 45 09                   setne 9[ebp]

07FA453E  5F                            pop edi
07FA453F  5D                            pop ebp

07FA4540  C3                            ret


Frame allocation (hex):

	0000       : VAR timStart
	0004 bit  0: VAR IN
	0005       : VAR PT
	0009 bit  0: VAR Q
	000A       : VAR ET

END_FUNCTION_BLOCK
**************************************************
	List function block: CheckWashAndStart
**************************************************

FUNCTION_BLOCK CheckWashAndStart

        VAR_IN_OUT
sv_washing_FB : BOOL^;
o_val_open_R_FB : BOOL^;
o_val_close_R_FB : BOOL^;
o_val_open_fall_FB : BOOL^;
o_val_close_fall_FB : BOOL^;
q_start_ats_FB : BOOL^;
ep_time_wash_FB : INT^;
i_val_state_FB : INT^;
	END_VAR

        VAR_OUTPUT
is_running_wash : BOOL;
	END_VAR

        VAR
washing_timer : TON;	{ DE:"локальний FB таймера" }
onWash : BOOL;
	END_VAR

END_FUNCTION_BLOCK

07FA4541  55                            push ebp
07FA4542  8B EB                         mov ebp, ebx
07FA4544  57                            push edi

#0		{SRC:CheckWashAndStart}
#1		(*$WAITSWITCH$*)
#2		
#3		
#4			(* IF sv_washing_FB^ and i_val_state_FB^=1 *)
#5			LD		i_val_state_FB^	{LNXT:1|-1|-1}
(*) UNDEF
07FA4545  8B 55 34                      mov edx, 52[ebp]
07FA4548  0F BF 02                      movsx eax, word ptr [edx]

#6			EQ		1	{LNXT:1|-1|-1}
(*) INT
07FA454B  3D 01 00 00 00                cmp eax, 1
07FA4550  0F 94 C0                      sete al
07FA4553  25 FF 00 00 00                and eax, 0FFh

#7			AND		sv_washing_FB^	{LNXT:1|-1|-1}
(*) BOOL
07FA4558  8B 55 18                      mov edx, 24[ebp]
07FA455B  8B 55 18                      mov edx, 24[ebp]
07FA455E  33 C9                         xor ecx, ecx
07FA4560  8A 0A                         mov cl, [edx]
07FA4562  23 C1                         and eax, ecx

#8			JMPCN	$label0	{LNXT:1|2|5}
(-) BOOL
07FA4564  84 C0                         test al, al
07FA4566  90 74 0E 90 90 90             je 07FA4577H

#9		
#10			(* THEN *)
#11		
#12				(* onWash :=true; *)
#13				MOVE		true,onWash	{LNXT:2|5|-1}
(*) BOOL
07FA456C  B8 01 00 00 00                mov eax, 01H
07FA4571  84 C0                         test al, al
07FA4573  0F 95 45 16                   setne 22[ebp]

#14		
#15		$label0:
#16			(* END_IF *)
#17		
#18		
#19			(* IF onWash *)
#20			LD		onWash	{LNXT:5|-1|-1}
(*) UNDEF
07FA4577  33 C0                         xor eax, eax
07FA4579  8A 45 16                      mov al, 22[ebp]

#21			JMPCN	$label1	{LNXT:5|6|16}
(-) BOOL
07FA457C  84 C0                         test al, al
07FA457E  90 74 54 90 90 90             je 07FA45D5H

#22		
#23			(* THEN *)
#24		
#25				(* is_running_wash :=true; *)
#26				MOVE		true,is_running_wash	{LNXT:6|7|-1}
(*) BOOL
07FA4584  B8 01 00 00 00                mov eax, 01H
07FA4589  84 C0                         test al, al
07FA458B  0F 95 45 17                   setne 23[ebp]

#27		
#28				(* o_val_close_R_FB^:=true; *)
#29				MOVE		true,o_val_close_R_FB^	{LNXT:7|8|-1}
(*) BOOL
07FA458F  B8 01 00 00 00                mov eax, 01H
07FA4594  8B 55 20                      mov edx, 32[ebp]
07FA4597  84 C0                         test al, al
07FA4599  0F 95 02                      setne [edx]

#30		
#31				(* o_val_open_R_FB^:=false; *)
#32				MOVE		false,o_val_open_R_FB^	{LNXT:8|10|-1}
(*) BOOL
07FA459C  B8 00 00 00 00                mov eax, 00H
07FA45A1  8B 55 1C                      mov edx, 28[ebp]
07FA45A4  84 C0                         test al, al
07FA45A6  0F 95 02                      setne [edx]

#33		
#34				(* o_val_open_fall_FB^:=true; *)
#35				MOVE		true,o_val_open_fall_FB^	{LNXT:10|11|-1}
(*) BOOL
07FA45A9  B8 01 00 00 00                mov eax, 01H
07FA45AE  8B 55 24                      mov edx, 36[ebp]
07FA45B1  84 C0                         test al, al
07FA45B3  0F 95 02                      setne [edx]

#36		
#37				(* o_val_close_fall_FB^:=false; *)
#38				MOVE		false,o_val_close_fall_FB^	{LNXT:11|14|-1}
(*) BOOL
07FA45B6  B8 00 00 00 00                mov eax, 00H
07FA45BB  8B 55 28                      mov edx, 40[ebp]
07FA45BE  84 C0                         test al, al
07FA45C0  0F 95 02                      setne [edx]

#39		
#40				(* q_start_ats_FB^:=true; *)
#41				MOVE		true,q_start_ats_FB^	{LNXT:14|20|-1}
(*) BOOL
07FA45C3  B8 01 00 00 00                mov eax, 01H
07FA45C8  8B 55 2C                      mov edx, 44[ebp]
07FA45CB  84 C0                         test al, al
07FA45CD  0F 95 02                      setne [edx]

#42				JMP		$label2	{LNXT:5|6|16}
(-) BOOL
07FA45D0  EB 10 90 90 90                jmp 07FA45E2H

#43		$label1:
#44		
#45			(* ELSE *)
#46		
#47				(* q_start_ats_FB^:=true; *)
#48				MOVE		true,q_start_ats_FB^	{LNXT:16|20|-1}
(*) BOOL
07FA45D5  B8 01 00 00 00                mov eax, 01H
07FA45DA  8B 55 2C                      mov edx, 44[ebp]
07FA45DD  84 C0                         test al, al
07FA45DF  0F 95 02                      setne [edx]

#49		
#50		$label2:
#51			(* END_IF *)
#52		
#53		
#54			(* IF washing_timer.Q *)
#55			LD		washing_timer.Q	{LNXT:20|-1|-1}
(*) UNDEF
07FA45E2  33 C0                         xor eax, eax
07FA45E4  8A 45 09                      mov al, 9[ebp]

#56			JMPCN	$label3	{LNXT:20|21|34}
(-) BOOL
07FA45E7  84 C0                         test al, al
07FA45E9  90 74 5A 90 90 90             je 07FA4646H

#57		
#58			(* THEN *)
#59		
#60				(* sv_washing_FB^:=false; *)
#61				MOVE		false,sv_washing_FB^	{LNXT:21|22|-1}
(*) BOOL
07FA45EF  B8 00 00 00 00                mov eax, 00H
07FA45F4  8B 55 18                      mov edx, 24[ebp]
07FA45F7  84 C0                         test al, al
07FA45F9  0F 95 02                      setne [edx]

#62		
#63				(* onWash :=false; *)
#64				MOVE		false,onWash	{LNXT:22|25|-1}
(*) BOOL
07FA45FC  B8 00 00 00 00                mov eax, 00H
07FA4601  84 C0                         test al, al
07FA4603  0F 95 45 16                   setne 22[ebp]

#65		
#66				(* o_val_close_R_FB^:=false; *)
#67				MOVE		false,o_val_close_R_FB^	{LNXT:25|26|-1}
(*) BOOL
07FA4607  B8 00 00 00 00                mov eax, 00H
07FA460C  8B 55 20                      mov edx, 32[ebp]
07FA460F  84 C0                         test al, al
07FA4611  0F 95 02                      setne [edx]

#68		
#69				(* o_val_open_fall_FB^:=false; *)
#70				MOVE		false,o_val_open_fall_FB^	{LNXT:26|28|-1}
(*) BOOL
07FA4614  B8 00 00 00 00                mov eax, 00H
07FA4619  8B 55 24                      mov edx, 36[ebp]
07FA461C  84 C0                         test al, al
07FA461E  0F 95 02                      setne [edx]

#71		
#72				(* o_val_open_R_FB^:=true; *)
#73				MOVE		true,o_val_open_R_FB^	{LNXT:28|29|-1}
(*) BOOL
07FA4621  B8 01 00 00 00                mov eax, 01H
07FA4626  8B 55 1C                      mov edx, 28[ebp]
07FA4629  84 C0                         test al, al
07FA462B  0F 95 02                      setne [edx]

#74		
#75				(* o_val_close_fall_FB^:=true; *)
#76				MOVE		true,o_val_close_fall_FB^	{LNXT:29|31|-1}
(*) BOOL
07FA462E  B8 01 00 00 00                mov eax, 01H
07FA4633  8B 55 28                      mov edx, 40[ebp]
07FA4636  84 C0                         test al, al
07FA4638  0F 95 02                      setne [edx]

#77		
#78				(* is_running_wash :=false; *)
#79				MOVE		false,is_running_wash	{LNXT:31|34|-1}
(*) BOOL
07FA463B  B8 00 00 00 00                mov eax, 00H
07FA4640  84 C0                         test al, al
07FA4642  0F 95 45 17                   setne 23[ebp]

#80		
#81		$label3:
#82			(* END_IF *)
#83		
#84			(* washing_timer *)
#85			MOVE		onWash,washing_timer.IN	{LNXT:34|-1|-1}
(*) BOOL
07FA4646  33 C0                         xor eax, eax
07FA4648  8A 45 16                      mov al, 22[ebp]
07FA464B  84 C0                         test al, al
07FA464D  0F 95 45 04                   setne 4[ebp]

#86			MOVE		ep_time_wash_FB^,washing_timer.PT	{LNXT:34|-1|-1}
(*) BOOL
07FA4651  8B 55 30                      mov edx, 48[ebp]
07FA4654  0F BF 02                      movsx eax, word ptr [edx]
07FA4657  89 45 05                      mov 5[ebp], eax

#87			CAL		washing_timer	{LNXT:34|-1|-1}
(*) INT
07FA465A  50                            push eax
07FA465B  8B DD                         mov ebx, ebp
07FA465D  E8 57 FE FF FF                call 07FA44B9H ; $$CODE$$+17593
07FA4662  58                            pop eax

07FA4663  5F                            pop edi
07FA4664  5D                            pop ebp

07FA4665  C3                            ret


Frame allocation (hex):

	0000       : FB washing_timer
	0016 bit  0: VAR onWash
	0017 bit  0: VAR is_running_wash
	0018       : VAR sv_washing_FB
	001C       : VAR o_val_open_R_FB
	0020       : VAR o_val_close_R_FB
	0024       : VAR o_val_open_fall_FB
	0028       : VAR o_val_close_fall_FB
	002C       : VAR q_start_ats_FB
	0030       : VAR ep_time_wash_FB
	0034       : VAR i_val_state_FB

END_FUNCTION_BLOCK
**************************************************
	List program: ATS_mdb
**************************************************

PROGRAM ATS_mdb

        VAR
res_eta_lcr : UINT;
resp_eta_lcr : ARRAY[0..3] OF INT;
res : INT;
xTON : TON;
	END_VAR

END_PROGRAM

07FA4670  55                            push ebp
07FA4671  8B EC                         mov ebp, esp
07FA4673  60                            pushad

#0		{SRC:ATS_mdb}
#1		(*$WAITSWITCH$*)
#2		
#3			(* res := sysMbMRTU_FC03(	addr := 1, 
#4											base := 257, // 256
#5											no := 4, 
#6											object := ADR(resp_eta_lcr), 
#7											timeout := 200); *)
#8			ADR		resp_eta_lcr	{LNXT:2|8|-1}
(*) UDINT
07FA4674  B8 CC CC CC CC                mov eax, CCCCCCCCH ; $$DATA$$+12

#9			ST		$$TMP0	{LNXT:2|8|-1}
(*) @INT
07FA4679  89 05 CC CC CC CC             mov [CCCCCCCCH], eax ; $$DATA$$+20

#10			LDP0		1	{LNXT:2|8|-1}
(*) @INT
#11			sysMbMRTU_FC03		257, 4, $$TMP0, 200	{LNXT:2|8|-1}
(*) @INT
07FA467F  68 C8 00 00 00                push 200
07FA4684  FF 35 CC CC CC CC             push [CCCCCCCCH] ; $$DATA$$+20
07FA468A  68 04 00 00 00                push 4
07FA468F  68 01 01 00 00                push 257
07FA4694  68 01 00 00 00                push 1
07FA4699  B9 CC CC CC CC                mov ecx, CCCCCCCCH ; sysMbMRTU_FC03
07FA469E  FF D1                         call ecx
07FA46A0  81 C4 14 00 00 00             add esp, 20

#12			ST		res	{LNXT:2|8|-1}
(*) UINT
07FA46A6  66 89 05 CC CC CC CC          mov [CCCCCCCCH], ax ; $$DATA$$+24

#13		
#14			(* ATS22_DUT.Ready 	:= to_bool(resp_eta_lcr[0] And 16#01); *)
#15			LD		resp_eta_lcr[0]	{LNXT:8|9|-1}
(*) UNDEF
07FA46AD  0F BF 05 CC CC CC CC          movsx eax, word ptr [CCCCCCCCH] ; $$DATA$$+12

#16			AND		16#01	{LNXT:8|9|-1}
(*) INT
07FA46B4  25 01 00 00 00                and eax, 00000001H

#17			to_bool	{LNXT:8|9|-1}
(*) INT
07FA46B9  66 85 C0                      test ax, ax
07FA46BC  0F 95 C0                      setne al

#18			ST		ATS22_DUT.Ready	{LNXT:8|9|-1}
(*) BOOL
07FA46BF  84 C0                         test al, al
07FA46C1  0F 95 05 CC CC CC CC          setne [CCCCCCCCH] ; $$DATA$$+26

#19		
#20			(* ATS22_DUT.On 		:= to_bool(resp_eta_lcr[0] And 16#02); *)
#21			LD		resp_eta_lcr[0]	{LNXT:9|10|-1}
(*) UNDEF
07FA46C8  0F BF 05 CC CC CC CC          movsx eax, word ptr [CCCCCCCCH] ; $$DATA$$+12

#22			AND		16#02	{LNXT:9|10|-1}
(*) INT
07FA46CF  25 02 00 00 00                and eax, 00000002H

#23			to_bool	{LNXT:9|10|-1}
(*) INT
07FA46D4  66 85 C0                      test ax, ax
07FA46D7  0F 95 C0                      setne al

#24			ST		ATS22_DUT.On	{LNXT:9|10|-1}
(*) BOOL
07FA46DA  84 C0                         test al, al
07FA46DC  0F 95 05 CC CC CC CC          setne [CCCCCCCCH] ; $$DATA$$+27

#25		
#26			(* ATS22_DUT.Trip 		:= to_bool(resp_eta_lcr[0] And 16#04); *)
#27			LD		resp_eta_lcr[0]	{LNXT:10|11|-1}
(*) UNDEF
07FA46E3  0F BF 05 CC CC CC CC          movsx eax, word ptr [CCCCCCCCH] ; $$DATA$$+12

#28			AND		16#04	{LNXT:10|11|-1}
(*) INT
07FA46EA  25 04 00 00 00                and eax, 00000004H

#29			to_bool	{LNXT:10|11|-1}
(*) INT
07FA46EF  66 85 C0                      test ax, ax
07FA46F2  0F 95 C0                      setne al

#30			ST		ATS22_DUT.Trip	{LNXT:10|11|-1}
(*) BOOL
07FA46F5  84 C0                         test al, al
07FA46F7  0F 95 05 CC CC CC CC          setne [CCCCCCCCH] ; $$DATA$$+28

#31		
#32			(* ATS22_DUT.Warning 	:= to_bool(resp_eta_lcr[0] And 16#08); *)
#33			LD		resp_eta_lcr[0]	{LNXT:11|12|-1}
(*) UNDEF
07FA46FE  0F BF 05 CC CC CC CC          movsx eax, word ptr [CCCCCCCCH] ; $$DATA$$+12

#34			AND		16#08	{LNXT:11|12|-1}
(*) INT
07FA4705  25 08 00 00 00                and eax, 00000008H

#35			to_bool	{LNXT:11|12|-1}
(*) INT
07FA470A  66 85 C0                      test ax, ax
07FA470D  0F 95 C0                      setne al

#36			ST		ATS22_DUT.Warning	{LNXT:11|12|-1}
(*) BOOL
07FA4710  84 C0                         test al, al
07FA4712  0F 95 05 CC CC CC CC          setne [CCCCCCCCH] ; $$DATA$$+29

#37		
#38			(* ATS22_DUT.LI3 		:= to_bool(resp_eta_lcr[0] And 16#20); *)
#39			LD		resp_eta_lcr[0]	{LNXT:12|13|-1}
(*) UNDEF
07FA4719  0F BF 05 CC CC CC CC          movsx eax, word ptr [CCCCCCCCH] ; $$DATA$$+12

#40			AND		16#20	{LNXT:12|13|-1}
(*) INT
07FA4720  25 20 00 00 00                and eax, 00000020H

#41			to_bool	{LNXT:12|13|-1}
(*) INT
07FA4725  66 85 C0                      test ax, ax
07FA4728  0F 95 C0                      setne al

#42			ST		ATS22_DUT.LI3	{LNXT:12|13|-1}
(*) BOOL
07FA472B  84 C0                         test al, al
07FA472D  0F 95 05 CC CC CC CC          setne [CCCCCCCCH] ; $$DATA$$+30

#43		
#44			(* ATS22_DUT.LI2 		:= to_bool(resp_eta_lcr[0] And 16#40); *)
#45			LD		resp_eta_lcr[0]	{LNXT:13|14|-1}
(*) UNDEF
07FA4734  0F BF 05 CC CC CC CC          movsx eax, word ptr [CCCCCCCCH] ; $$DATA$$+12

#46			AND		16#40	{LNXT:13|14|-1}
(*) INT
07FA473B  25 40 00 00 00                and eax, 00000040H

#47			to_bool	{LNXT:13|14|-1}
(*) INT
07FA4740  66 85 C0                      test ax, ax
07FA4743  0F 95 C0                      setne al

#48			ST		ATS22_DUT.LI2	{LNXT:13|14|-1}
(*) BOOL
07FA4746  84 C0                         test al, al
07FA4748  0F 95 05 CC CC CC CC          setne [CCCCCCCCH] ; $$DATA$$+31

#49		
#50			(* ATS22_DUT.LI1 		:= to_bool(resp_eta_lcr[0] And 16#80); *)
#51			LD		resp_eta_lcr[0]	{LNXT:14|17|-1}
(*) UNDEF
07FA474F  0F BF 05 CC CC CC CC          movsx eax, word ptr [CCCCCCCCH] ; $$DATA$$+12

#52			AND		16#80	{LNXT:14|17|-1}
(*) INT
07FA4756  25 80 00 00 00                and eax, 00000080H

#53			to_bool	{LNXT:14|17|-1}
(*) INT
07FA475B  66 85 C0                      test ax, ax
07FA475E  0F 95 C0                      setne al

#54			ST		ATS22_DUT.LI1	{LNXT:14|17|-1}
(*) BOOL
07FA4761  84 C0                         test al, al
07FA4763  0F 95 05 CC CC CC CC          setne [CCCCCCCCH] ; $$DATA$$+32

#55		
#56			(* ATS_State_bits.0 := ATS22_DUT.Ready; *)
#57			MOVE		ATS22_DUT.Ready,ATS_State_bits.0	{LNXT:17|18|-1}
(*) BOOL
07FA476A  33 C0                         xor eax, eax
07FA476C  8A 05 CC CC CC CC             mov al, [CCCCCCCCH] ; $$DATA$$+26
07FA4772  84 C0                         test al, al
07FA4774  90 75 11 90 90 90             jne 00000014H@
07FA477A  66 0F BA 35 CC CC CC CC 00    btr word ptr [CCCCCCCCH], 0 ; %M110+16
07FA4783  EB 0C 90 90 90                jmp 0000000EH@
07FA4788  66 0F BA 2D CC CC CC CC 00    bts word ptr [CCCCCCCCH], 0 ; %M110+16

#58		
#59			(* ATS_State_bits.1 := ATS22_DUT.On And i_run_ats; *)
#60			LD		ATS22_DUT.On	{LNXT:18|19|-1}
(*) UNDEF
07FA4791  33 C0                         xor eax, eax
07FA4793  8A 05 CC CC CC CC             mov al, [CCCCCCCCH] ; $$DATA$$+27

#61			AND		i_run_ats	{LNXT:18|19|-1}
(*) BOOL
07FA4799  33 C9                         xor ecx, ecx
07FA479B  8A 0D CC CC CC CC             mov cl, [CCCCCCCCH] ; $$DATA$$+52
07FA47A1  23 C1                         and eax, ecx

#62			ST		ATS_State_bits.1	{LNXT:18|19|-1}
(*) BOOL
07FA47A3  84 C0                         test al, al
07FA47A5  90 75 11 90 90 90             jne 00000014H@
07FA47AB  66 0F BA 35 CC CC CC CC 01    btr word ptr [CCCCCCCCH], 1 ; %M110+16
07FA47B4  EB 0C 90 90 90                jmp 0000000EH@
07FA47B9  66 0F BA 2D CC CC CC CC 01    bts word ptr [CCCCCCCCH], 1 ; %M110+16

#63		
#64			(* ATS_State_bits.2 := ATS22_DUT.Trip Or Not i_no_alm_ats ; *)
#65			LD		i_no_alm_ats	{LNXT:19|20|-1}
(*) UNDEF
07FA47C2  33 C0                         xor eax, eax
07FA47C4  8A 05 CC CC CC CC             mov al, [CCCCCCCCH] ; $$DATA$$+53

#66			NOT	{LNXT:19|20|-1}
(*) BOOL
07FA47CA  84 C0                         test al, al
07FA47CC  0F 94 C0                      sete al

#67			OR		ATS22_DUT.Trip	{LNXT:19|20|-1}
(*) BOOL
07FA47CF  33 C9                         xor ecx, ecx
07FA47D1  8A 0D CC CC CC CC             mov cl, [CCCCCCCCH] ; $$DATA$$+28
07FA47D7  0B C1                         or eax, ecx

#68			ST		ATS_State_bits.2	{LNXT:19|20|-1}
(*) BOOL
07FA47D9  84 C0                         test al, al
07FA47DB  90 75 11 90 90 90             jne 00000014H@
07FA47E1  66 0F BA 35 CC CC CC CC 02    btr word ptr [CCCCCCCCH], 2 ; %M110+16
07FA47EA  EB 0C 90 90 90                jmp 0000000EH@
07FA47EF  66 0F BA 2D CC CC CC CC 02    bts word ptr [CCCCCCCCH], 2 ; %M110+16

#69		
#70			(* ATS_State_bits.3 := ATS22_DUT.Warning; *)
#71			MOVE		ATS22_DUT.Warning,ATS_State_bits.3	{LNXT:20|21|-1}
(*) BOOL
07FA47F8  33 C0                         xor eax, eax
07FA47FA  8A 05 CC CC CC CC             mov al, [CCCCCCCCH] ; $$DATA$$+29
07FA4800  84 C0                         test al, al
07FA4802  90 75 11 90 90 90             jne 00000014H@
07FA4808  66 0F BA 35 CC CC CC CC 03    btr word ptr [CCCCCCCCH], 3 ; %M110+16
07FA4811  EB 0C 90 90 90                jmp 0000000EH@
07FA4816  66 0F BA 2D CC CC CC CC 03    bts word ptr [CCCCCCCCH], 3 ; %M110+16

#72		
#73			(* ATS_State_bits.4 := ATS22_DUT.Local; *)
#74			MOVE		ATS22_DUT.Local,ATS_State_bits.4	{LNXT:21|22|-1}
(*) BOOL
07FA481F  33 C0                         xor eax, eax
07FA4821  8A 05 CC CC CC CC             mov al, [CCCCCCCCH] ; $$DATA$$+34
07FA4827  84 C0                         test al, al
07FA4829  90 75 11 90 90 90             jne 00000014H@
07FA482F  66 0F BA 35 CC CC CC CC 04    btr word ptr [CCCCCCCCH], 4 ; %M110+16
07FA4838  EB 0C 90 90 90                jmp 0000000EH@
07FA483D  66 0F BA 2D CC CC CC CC 04    bts word ptr [CCCCCCCCH], 4 ; %M110+16

#75		
#76			(* ATS_State_bits.5 := ATS22_DUT.Ramping; *)
#77			MOVE		ATS22_DUT.Ramping,ATS_State_bits.5	{LNXT:22|23|-1}
(*) BOOL
07FA4846  33 C0                         xor eax, eax
07FA4848  8A 05 CC CC CC CC             mov al, [CCCCCCCCH] ; $$DATA$$+35
07FA484E  84 C0                         test al, al
07FA4850  90 75 11 90 90 90             jne 00000014H@
07FA4856  66 0F BA 35 CC CC CC CC 05    btr word ptr [CCCCCCCCH], 5 ; %M110+16
07FA485F  EB 0C 90 90 90                jmp 0000000EH@
07FA4864  66 0F BA 2D CC CC CC CC 05    bts word ptr [CCCCCCCCH], 5 ; %M110+16

#78		
#79			(* ATS_State_bits.6 := ATS22_DUT.LI1; *)
#80			MOVE		ATS22_DUT.LI1,ATS_State_bits.6	{LNXT:23|24|-1}
(*) BOOL
07FA486D  33 C0                         xor eax, eax
07FA486F  8A 05 CC CC CC CC             mov al, [CCCCCCCCH] ; $$DATA$$+32
07FA4875  84 C0                         test al, al
07FA4877  90 75 11 90 90 90             jne 00000014H@
07FA487D  66 0F BA 35 CC CC CC CC 06    btr word ptr [CCCCCCCCH], 6 ; %M110+16
07FA4886  EB 0C 90 90 90                jmp 0000000EH@
07FA488B  66 0F BA 2D CC CC CC CC 06    bts word ptr [CCCCCCCCH], 6 ; %M110+16

#81		
#82			(* ATS_State_bits.7 := ATS22_DUT.LI2; *)
#83			MOVE		ATS22_DUT.LI2,ATS_State_bits.7	{LNXT:24|25|-1}
(*) BOOL
07FA4894  33 C0                         xor eax, eax
07FA4896  8A 05 CC CC CC CC             mov al, [CCCCCCCCH] ; $$DATA$$+31
07FA489C  84 C0                         test al, al
07FA489E  90 75 11 90 90 90             jne 00000014H@
07FA48A4  66 0F BA 35 CC CC CC CC 07    btr word ptr [CCCCCCCCH], 7 ; %M110+16
07FA48AD  EB 0C 90 90 90                jmp 0000000EH@
07FA48B2  66 0F BA 2D CC CC CC CC 07    bts word ptr [CCCCCCCCH], 7 ; %M110+16

#84		
#85			(* ATS_State_bits.8 := ATS22_DUT.LI3; *)
#86			MOVE		ATS22_DUT.LI3,ATS_State_bits.8	{LNXT:25|28|-1}
(*) BOOL
07FA48BB  33 C0                         xor eax, eax
07FA48BD  8A 05 CC CC CC CC             mov al, [CCCCCCCCH] ; $$DATA$$+30
07FA48C3  84 C0                         test al, al
07FA48C5  90 75 11 90 90 90             jne 00000014H@
07FA48CB  66 0F BA 35 CC CC CC CC 08    btr word ptr [CCCCCCCCH], 8 ; %M110+16
07FA48D4  EB 0C 90 90 90                jmp 0000000EH@
07FA48D9  66 0F BA 2D CC CC CC CC 08    bts word ptr [CCCCCCCCH], 8 ; %M110+16

#87		
#88			(* ATS_State_bits.9 := i_pb_loc; *)
#89			MOVE		i_pb_loc,ATS_State_bits.9	{LNXT:28|29|-1}
(*) BOOL
07FA48E2  0F BF 05 CC CC CC CC          movsx eax, word ptr [CCCCCCCCH] ; $$DATA$$+54
07FA48E9  66 85 C0                      test ax, ax
07FA48EC  90 75 11 90 90 90             jne 00000014H@
07FA48F2  66 0F BA 35 CC CC CC CC 09    btr word ptr [CCCCCCCCH], 9 ; %M110+16
07FA48FB  EB 0C 90 90 90                jmp 0000000EH@
07FA4900  66 0F BA 2D CC CC CC CC 09    bts word ptr [CCCCCCCCH], 9 ; %M110+16

#90		
#91			(* ATS_State_bits.10 := i_pb_rem; *)
#92			MOVE		i_pb_rem,ATS_State_bits.10	{LNXT:29|31|-1}
(*) INT
07FA4909  0F BF 05 CC CC CC CC          movsx eax, word ptr [CCCCCCCCH] ; $$DATA$$+56
07FA4910  66 85 C0                      test ax, ax
07FA4913  90 75 11 90 90 90             jne 00000014H@
07FA4919  66 0F BA 35 CC CC CC CC 0A    btr word ptr [CCCCCCCCH], 10 ; %M110+16
07FA4922  EB 0C 90 90 90                jmp 0000000EH@
07FA4927  66 0F BA 2D CC CC CC CC 0A    bts word ptr [CCCCCCCCH], 10 ; %M110+16

#93		
#94		
#95			(* IF i_pb_loc AND not i_pb_rem *)
#96			LD		i_pb_rem	{LNXT:31|-1|-1}
(*) UNDEF
07FA4930  0F BF 05 CC CC CC CC          movsx eax, word ptr [CCCCCCCCH] ; $$DATA$$+56

#97			NOT	{LNXT:31|-1|-1}
(*) INT
07FA4937  66 F7 D0                      not ax

#98			AND(		i_pb_loc	{LNXT:31|-1|-1}
(*) INT
07FA493A  50                            push eax
07FA493B  0F BF 05 CC CC CC CC          movsx eax, word ptr [CCCCCCCCH] ; $$DATA$$+54

#99			NOT	{LNXT:31|-1|-1}
(*) INT
07FA4942  66 F7 D0                      not ax

#100			)	{LNXT:31|-1|-1}
(*) INT
07FA4945  8B C8                         mov ecx, eax
07FA4947  58                            pop eax
07FA4948  23 C1                         and eax, ecx

#101			JMPCN	$label0	{LNXT:31|32|34}
(-) INT
07FA494A  66 85 C0                      test ax, ax
07FA494D  90 74 27 90 90 90             je 07FA4977H

#102		
#103			(* THEN *)
#104		
#105				(* ATS_State_bits.11 := TRUE; *)
#106				MOVE		TRUE,ATS_State_bits.11	{LNXT:32|34|-1}
(*) INT
07FA4953  B8 01 00 00 00                mov eax, 01H
07FA4958  84 C0                         test al, al
07FA495A  90 75 11 90 90 90             jne 00000014H@
07FA4960  66 0F BA 35 CC CC CC CC 0B    btr word ptr [CCCCCCCCH], 11 ; %M110+16
07FA4969  EB 0C 90 90 90                jmp 0000000EH@
07FA496E  66 0F BA 2D CC CC CC CC 0B    bts word ptr [CCCCCCCCH], 11 ; %M110+16

#107		
#108		$label0:
#109			(* END_IF *)
#110		
#111		
#112			(* IF i_pb_loc AND i_pb_rem *)
#113			LD		i_pb_loc	{LNXT:34|-1|-1}
(*) UNDEF
07FA4977  0F BF 05 CC CC CC CC          movsx eax, word ptr [CCCCCCCCH] ; $$DATA$$+54

#114			NOT	{LNXT:34|-1|-1}
(*) INT
07FA497E  66 F7 D0                      not ax

#115			AND		i_pb_rem	{LNXT:34|-1|-1}
(*) INT
07FA4981  0F BF 0D CC CC CC CC          movsx ecx, word ptr [CCCCCCCCH] ; $$DATA$$+56
07FA4988  23 C1                         and eax, ecx

#116			JMPCN	$label1	{LNXT:34|35|37}
(-) INT
07FA498A  66 85 C0                      test ax, ax
07FA498D  90 74 27 90 90 90             je 07FA49B7H

#117		
#118			(* THEN *)
#119		
#120				(* ATS_State_bits.11 := FALSE; *)
#121				MOVE		FALSE,ATS_State_bits.11	{LNXT:35|37|-1}
(*) INT
07FA4993  B8 00 00 00 00                mov eax, 00H
07FA4998  84 C0                         test al, al
07FA499A  90 75 11 90 90 90             jne 00000014H@
07FA49A0  66 0F BA 35 CC CC CC CC 0B    btr word ptr [CCCCCCCCH], 11 ; %M110+16
07FA49A9  EB 0C 90 90 90                jmp 0000000EH@
07FA49AE  66 0F BA 2D CC CC CC CC 0B    bts word ptr [CCCCCCCCH], 11 ; %M110+16

#122		
#123		$label1:
#124			(* END_IF *)
#125		
#126		
#127			(* IF i_pb_loc AND not i_pb_rem *)
#128			LD		i_pb_rem	{LNXT:37|-1|-1}
(*) UNDEF
07FA49B7  0F BF 05 CC CC CC CC          movsx eax, word ptr [CCCCCCCCH] ; $$DATA$$+56

#129			NOT	{LNXT:37|-1|-1}
(*) INT
07FA49BE  66 F7 D0                      not ax

#130			AND		i_pb_loc	{LNXT:37|-1|-1}
(*) INT
07FA49C1  0F BF 0D CC CC CC CC          movsx ecx, word ptr [CCCCCCCCH] ; $$DATA$$+54
07FA49C8  23 C1                         and eax, ecx

#131			JMPCN	$label2	{LNXT:37|38|43}
(-) INT
07FA49CA  66 85 C0                      test ax, ax
07FA49CD  90 74 27 90 90 90             je 07FA49F7H

#132		
#133			(* THEN *)
#134		
#135				(* ATS_State_bits.11 := FALSE; *)
#136				MOVE		FALSE,ATS_State_bits.11	{LNXT:38|43|-1}
(*) INT
07FA49D3  B8 00 00 00 00                mov eax, 00H
07FA49D8  84 C0                         test al, al
07FA49DA  90 75 11 90 90 90             jne 00000014H@
07FA49E0  66 0F BA 35 CC CC CC CC 0B    btr word ptr [CCCCCCCCH], 11 ; %M110+16
07FA49E9  EB 0C 90 90 90                jmp 0000000EH@
07FA49EE  66 0F BA 2D CC CC CC CC 0B    bts word ptr [CCCCCCCCH], 11 ; %M110+16

#137		
#138		$label2:
#139			(* END_IF *)
#140		
#141			(* ATS22_DUT.EtaCurrent := to_byte(SHR(resp_eta_lcr[0] AND 16#3F00, 16#08) * 200 / 63); *)
#142			LD		resp_eta_lcr[0]	{LNXT:43|44|-1}
(*) UNDEF
07FA49F7  0F BF 05 CC CC CC CC          movsx eax, word ptr [CCCCCCCCH] ; $$DATA$$+12

#143			AND		16#3F00	{LNXT:43|44|-1}
(*) INT
07FA49FE  25 00 3F 00 00                and eax, 00003F00H

#144			SHR		16#08	{LNXT:43|44|-1}
(*) INT
07FA4A03  C1 E8 08                      shr eax, 8

#145			MUL		200	{LNXT:43|44|-1}
(*) DINT
07FA4A06  B9 C8 00 00 00                mov ecx, 200
07FA4A0B  F7 E9                         imul ecx

#146			DIV		63	{LNXT:43|44|-1}
(*) DINT
07FA4A0D  99                            cdq
07FA4A0E  B9 3F 00 00 00                mov ecx, 63
07FA4A13  F7 F9                         idiv ecx

#147			to_byte	{LNXT:43|44|-1}
(*) DINT
#148			ST		ATS22_DUT.EtaCurrent	{LNXT:43|44|-1}
(*) BYTE
07FA4A15  88 05 CC CC CC CC             mov [CCCCCCCCH], al ; $$DATA$$+33

#149		
#150			(* ATS_Current_prsnt	 := ATS22_DUT.EtaCurrent; *)
#151			MOVE		ATS22_DUT.EtaCurrent,ATS_Current_prsnt	{LNXT:44|46|-1}
(*) BYTE
07FA4A1B  33 C0                         xor eax, eax
07FA4A1D  8A 05 CC CC CC CC             mov al, [CCCCCCCCH] ; $$DATA$$+33
07FA4A23  66 89 05 CC CC CC CC          mov [CCCCCCCCH], ax ; %M110+18

#152		
#153			(* ATS22_DUT.Local 	:= to_bool(resp_eta_lcr[0] And 16#4000); *)
#154			LD		resp_eta_lcr[0]	{LNXT:46|47|-1}
(*) UNDEF
07FA4A2A  0F BF 05 CC CC CC CC          movsx eax, word ptr [CCCCCCCCH] ; $$DATA$$+12

#155			AND		16#4000	{LNXT:46|47|-1}
(*) INT
07FA4A31  25 00 40 00 00                and eax, 00004000H

#156			to_bool	{LNXT:46|47|-1}
(*) INT
07FA4A36  66 85 C0                      test ax, ax
07FA4A39  0F 95 C0                      setne al

#157			ST		ATS22_DUT.Local	{LNXT:46|47|-1}
(*) BOOL
07FA4A3C  84 C0                         test al, al
07FA4A3E  0F 95 05 CC CC CC CC          setne [CCCCCCCCH] ; $$DATA$$+34

#158		
#159			(* ATS22_DUT.Ramping 	:= to_bool(resp_eta_lcr[0] And 16#8000); *)
#160			LD		resp_eta_lcr[0]	{LNXT:47|49|-1}
(*) UNDEF
07FA4A45  0F BF 05 CC CC CC CC          movsx eax, word ptr [CCCCCCCCH] ; $$DATA$$+12

#161			AND		16#8000	{LNXT:47|49|-1}
(*) INT
07FA4A4C  25 00 80 00 00                and eax, 00008000H

#162			to_bool	{LNXT:47|49|-1}
(*) INT
07FA4A51  66 85 C0                      test ax, ax
07FA4A54  0F 95 C0                      setne al

#163			ST		ATS22_DUT.Ramping	{LNXT:47|49|-1}
(*) BOOL
07FA4A57  84 C0                         test al, al
07FA4A59  0F 95 05 CC CC CC CC          setne [CCCCCCCCH] ; $$DATA$$+35

#164		
#165			(* ATS22_DUT.Lcr1 := resp_eta_lcr[1]; *)
#166			MOVE		resp_eta_lcr[1],ATS22_DUT.Lcr1	{LNXT:49|50|-1}
(*) BOOL
07FA4A60  0F BF 05 CC CC CC CC          movsx eax, word ptr [CCCCCCCCH] ; $$DATA$$+14
07FA4A67  66 89 05 CC CC CC CC          mov [CCCCCCCCH], ax ; $$DATA$$+36

#167		
#168			(* ATS22_DUT.Lcr2 := resp_eta_lcr[2]; *)
#169			MOVE		resp_eta_lcr[2],ATS22_DUT.Lcr2	{LNXT:50|51|-1}
(*) INT
07FA4A6E  0F BF 05 CC CC CC CC          movsx eax, word ptr [CCCCCCCCH] ; $$DATA$$+16
07FA4A75  66 89 05 CC CC CC CC          mov [CCCCCCCCH], ax ; $$DATA$$+38

#170		
#171			(* ATS22_DUT.Lcr3 := resp_eta_lcr[3]; *)
#172			MOVE		resp_eta_lcr[3],ATS22_DUT.Lcr3	{LNXT:51|53|-1}
(*) INT
07FA4A7C  0F BF 05 CC CC CC CC          movsx eax, word ptr [CCCCCCCCH] ; $$DATA$$+18
07FA4A83  66 89 05 CC CC CC CC          mov [CCCCCCCCH], ax ; $$DATA$$+40

#173		
#174			(* ATS_Current_L1 := ATS22_DUT.Lcr1; *)
#175			MOVE		ATS22_DUT.Lcr1,ATS_Current_L1	{LNXT:53|54|-1}
(*) INT
07FA4A8A  0F BF 05 CC CC CC CC          movsx eax, word ptr [CCCCCCCCH] ; $$DATA$$+36
07FA4A91  66 89 05 CC CC CC CC          mov [CCCCCCCCH], ax ; %M110+20

#176		
#177			(* ATS_Current_L2 := ATS22_DUT.Lcr2; *)
#178			MOVE		ATS22_DUT.Lcr2,ATS_Current_L2	{LNXT:54|55|-1}
(*) INT
07FA4A98  0F BF 05 CC CC CC CC          movsx eax, word ptr [CCCCCCCCH] ; $$DATA$$+38
07FA4A9F  66 89 05 CC CC CC CC          mov [CCCCCCCCH], ax ; %M110+22

#179		
#180			(* ATS_Current_L3 := ATS22_DUT.Lcr3; *)
#181			MOVE		ATS22_DUT.Lcr3,ATS_Current_L3	{LNXT:55|57|-1}
(*) INT
07FA4AA6  0F BF 05 CC CC CC CC          movsx eax, word ptr [CCCCCCCCH] ; $$DATA$$+40
07FA4AAD  66 89 05 CC CC CC CC          mov [CCCCCCCCH], ax ; %M110+24

#182		
#183			(* res := sysMbMRTU_FC03(	addr := 1, 
#184											base := 261, // 260
#185											no := 1, 
#186											object := ADR(resp_eta_lcr), 
#187											timeout := 200); *)
#188			ADR		resp_eta_lcr	{LNXT:57|63|-1}
(*) INT
07FA4AB4  B8 CC CC CC CC                mov eax, CCCCCCCCH ; $$DATA$$+12

#189			ST		$$TMP0	{LNXT:57|63|-1}
(*) @INT
07FA4AB9  89 05 CC CC CC CC             mov [CCCCCCCCH], eax ; $$DATA$$+20

#190			LDP0		1	{LNXT:57|63|-1}
(*) @INT
#191			sysMbMRTU_FC03		261, 1, $$TMP0, 200	{LNXT:57|63|-1}
(*) @INT
07FA4ABF  68 C8 00 00 00                push 200
07FA4AC4  FF 35 CC CC CC CC             push [CCCCCCCCH] ; $$DATA$$+20
07FA4ACA  68 01 00 00 00                push 1
07FA4ACF  68 05 01 00 00                push 261
07FA4AD4  68 01 00 00 00                push 1
07FA4AD9  B9 CC CC CC CC                mov ecx, CCCCCCCCH ; sysMbMRTU_FC03
07FA4ADE  FF D1                         call ecx
07FA4AE0  81 C4 14 00 00 00             add esp, 20

#192			ST		res	{LNXT:57|63|-1}
(*) UINT
07FA4AE6  66 89 05 CC CC CC CC          mov [CCCCCCCCH], ax ; $$DATA$$+24

#193		
#194			(* ATS22_DUT.LcrVoltage	:= resp_eta_lcr[0]; *)
#195			MOVE		resp_eta_lcr[0],ATS22_DUT.LcrVoltage	{LNXT:63|64|-1}
(*) UINT
07FA4AED  0F BF 05 CC CC CC CC          movsx eax, word ptr [CCCCCCCCH] ; $$DATA$$+12
07FA4AF4  66 89 05 CC CC CC CC          mov [CCCCCCCCH], ax ; $$DATA$$+42

#196		
#197			(* ATS_Voltage := ATS22_DUT.LcrVoltage; *)
#198			MOVE		ATS22_DUT.LcrVoltage,ATS_Voltage	{LNXT:64|68|-1}
(*) INT
07FA4AFB  0F BF 05 CC CC CC CC          movsx eax, word ptr [CCCCCCCCH] ; $$DATA$$+42
07FA4B02  66 89 05 CC CC CC CC          mov [CCCCCCCCH], ax ; %M110+36

#199		
#200			(* res := sysMbMRTU_FC03(	addr := 1, 
#201											base := 280, // 279
#202											no := 1, 
#203											object := ADR(resp_eta_lcr), 
#204											timeout := 200); *)
#205			ADR		resp_eta_lcr	{LNXT:68|74|-1}
(*) INT
07FA4B09  B8 CC CC CC CC                mov eax, CCCCCCCCH ; $$DATA$$+12

#206			ST		$$TMP0	{LNXT:68|74|-1}
(*) @INT
07FA4B0E  89 05 CC CC CC CC             mov [CCCCCCCCH], eax ; $$DATA$$+20

#207			LDP0		1	{LNXT:68|74|-1}
(*) @INT
#208			sysMbMRTU_FC03		280, 1, $$TMP0, 200	{LNXT:68|74|-1}
(*) @INT
07FA4B14  68 C8 00 00 00                push 200
07FA4B19  FF 35 CC CC CC CC             push [CCCCCCCCH] ; $$DATA$$+20
07FA4B1F  68 01 00 00 00                push 1
07FA4B24  68 18 01 00 00                push 280
07FA4B29  68 01 00 00 00                push 1
07FA4B2E  B9 CC CC CC CC                mov ecx, CCCCCCCCH ; sysMbMRTU_FC03
07FA4B33  FF D1                         call ecx
07FA4B35  81 C4 14 00 00 00             add esp, 20

#209			ST		res	{LNXT:68|74|-1}
(*) UINT
07FA4B3B  66 89 05 CC CC CC CC          mov [CCCCCCCCH], ax ; $$DATA$$+24

#210		
#211			(* ATS22_DUT.LastFLT 	:= resp_eta_lcr[0]; *)
#212			MOVE		resp_eta_lcr[0],ATS22_DUT.LastFLT	{LNXT:74|75|-1}
(*) UINT
07FA4B42  0F BF 05 CC CC CC CC          movsx eax, word ptr [CCCCCCCCH] ; $$DATA$$+12
07FA4B49  66 89 05 CC CC CC CC          mov [CCCCCCCCH], ax ; $$DATA$$+44

#213		
#214			(* ATS_Last_FaultCode := ATS22_DUT.LastFLT; *)
#215			MOVE		ATS22_DUT.LastFLT,ATS_Last_FaultCode	{LNXT:75|78|-1}
(*) INT
07FA4B50  0F BF 05 CC CC CC CC          movsx eax, word ptr [CCCCCCCCH] ; $$DATA$$+44
07FA4B57  66 89 05 CC CC CC CC          mov [CCCCCCCCH], ax ; %M110+26

#216		
#217			(* res := sysMbMRTU_FC03(	addr := 1, 
#218											base := 274, // 273
#219											no := 3, 
#220											object := ADR(resp_eta_lcr), 
#221											timeout := 200); *)
#222			ADR		resp_eta_lcr	{LNXT:78|84|-1}
(*) INT
07FA4B5E  B8 CC CC CC CC                mov eax, CCCCCCCCH ; $$DATA$$+12

#223			ST		$$TMP0	{LNXT:78|84|-1}
(*) @INT
07FA4B63  89 05 CC CC CC CC             mov [CCCCCCCCH], eax ; $$DATA$$+20

#224			LDP0		1	{LNXT:78|84|-1}
(*) @INT
#225			sysMbMRTU_FC03		274, 3, $$TMP0, 200	{LNXT:78|84|-1}
(*) @INT
07FA4B69  68 C8 00 00 00                push 200
07FA4B6E  FF 35 CC CC CC CC             push [CCCCCCCCH] ; $$DATA$$+20
07FA4B74  68 03 00 00 00                push 3
07FA4B79  68 12 01 00 00                push 274
07FA4B7E  68 01 00 00 00                push 1
07FA4B83  B9 CC CC CC CC                mov ecx, CCCCCCCCH ; sysMbMRTU_FC03
07FA4B88  FF D1                         call ecx
07FA4B8A  81 C4 14 00 00 00             add esp, 20

#226			ST		res	{LNXT:78|84|-1}
(*) UINT
07FA4B90  66 89 05 CC CC CC CC          mov [CCCCCCCCH], ax ; $$DATA$$+24

#227		
#228		
#229			(* IF res <> 0 *)
#230			LD		res	{LNXT:84|-1|-1}
(*) UNDEF
07FA4B97  0F BF 05 CC CC CC CC          movsx eax, word ptr [CCCCCCCCH] ; $$DATA$$+24

#231			NE		0	{LNXT:84|-1|-1}
(*) INT
07FA4B9E  3D 00 00 00 00                cmp eax, 0
07FA4BA3  0F 95 C0                      setne al
07FA4BA6  25 FF 00 00 00                and eax, 0FFh

#232			JMPCN	$label3	{LNXT:84|84|86}
(-) BOOL
07FA4BAB  84 C0                         test al, al
07FA4BAD  90 74 27 90 90 90             je 07FA4BD7H

#233		
#234			(* THEN *)
#235		
#236				(* Alarms.6 := true; *)
#237				MOVE		true,Alarms.6	{LNXT:84|86|-1}
(*) BOOL
07FA4BB3  B8 01 00 00 00                mov eax, 01H
07FA4BB8  84 C0                         test al, al
07FA4BBA  90 75 11 90 90 90             jne 00000014H@
07FA4BC0  66 0F BA 35 CC CC CC CC 06    btr word ptr [CCCCCCCCH], 6 ; %M110+32
07FA4BC9  EB 0C 90 90 90                jmp 0000000EH@
07FA4BCE  66 0F BA 2D CC CC CC CC 06    bts word ptr [CCCCCCCCH], 6 ; %M110+32

#238		
#239		$label3:
#240			(* END_IF *)
#241		
#242			(* ATS22_DUT.MotRunTime 		:= resp_eta_lcr[0]; *)
#243			MOVE		resp_eta_lcr[0],ATS22_DUT.MotRunTime	{LNXT:86|87|-1}
(*) WORD
07FA4BD7  0F BF 05 CC CC CC CC          movsx eax, word ptr [CCCCCCCCH] ; $$DATA$$+12
07FA4BDE  66 89 05 CC CC CC CC          mov [CCCCCCCCH], ax ; $$DATA$$+46

#244		
#245			(* ATS22_DUT.MotStartCnt 		:= resp_eta_lcr[1]; *)
#246			MOVE		resp_eta_lcr[1],ATS22_DUT.MotStartCnt	{LNXT:87|88|-1}
(*) INT
07FA4BE5  0F BF 05 CC CC CC CC          movsx eax, word ptr [CCCCCCCCH] ; $$DATA$$+14
07FA4BEC  66 89 05 CC CC CC CC          mov [CCCCCCCCH], ax ; $$DATA$$+48

#247		
#248			(* ATS22_DUT.MotLastStartTime 	:= resp_eta_lcr[2]; *)
#249			MOVE		resp_eta_lcr[2],ATS22_DUT.MotLastStartTime	{LNXT:88|90|-1}
(*) INT
07FA4BF3  0F BF 05 CC CC CC CC          movsx eax, word ptr [CCCCCCCCH] ; $$DATA$$+16
07FA4BFA  66 89 05 CC CC CC CC          mov [CCCCCCCCH], ax ; $$DATA$$+50

#250		
#251			(* ATS_RunTime_Hors	:= to_word(ATS22_DUT.MotRunTime); *)
#252			LDP0		ATS22_DUT.MotRunTime	{LNXT:90|91|-1}
(*) INT
#253			to_word	{LNXT:90|91|-1}
(*) INT
07FA4C01  0F BF 05 CC CC CC CC          movsx eax, word ptr [CCCCCCCCH] ; $$DATA$$+46

#254			ST		ATS_RunTime_Hors	{LNXT:90|91|-1}
(*) WORD
07FA4C08  66 89 05 CC CC CC CC          mov [CCCCCCCCH], ax ; %M110+28

#255		
#256			(* ATS_OnTimes_Cnt		:= to_word(ATS22_DUT.MotStartCnt); *)
#257			LDP0		ATS22_DUT.MotStartCnt	{LNXT:91|2|-1}
(*) WORD
#258			to_word	{LNXT:91|2|-1}
(*) WORD
07FA4C0F  0F BF 05 CC CC CC CC          movsx eax, word ptr [CCCCCCCCH] ; $$DATA$$+48

#259			ST		ATS_OnTimes_Cnt	{LNXT:91|2|-1}
(*) WORD
07FA4C16  66 89 05 CC CC CC CC          mov [CCCCCCCCH], ax ; %M110+30

07FA4C1D  61                            popad
07FA4C1E  5D                            pop ebp

07FA4C1F  C3                            ret

END_PROGRAM


**************************************************
	Target variable image generation
**************************************************


*** INPUT:
07FA4C20  55                            push ebp
07FA4C21  8B EC                         mov ebp, esp

07FA4C23  8A 0D CC CC CC CC             mov cl, [CCCCCCCCH] ; %I0+7
07FA4C29  88 0D CC CC CC CC             mov [CCCCCCCCH], cl ; $$DATA$$+52

07FA4C2F  8A 0D CC CC CC CC             mov cl, [CCCCCCCCH] ; %I0+6
07FA4C35  88 0D CC CC CC CC             mov [CCCCCCCCH], cl ; $$DATA$$+53

07FA4C3B  66 8B 0D CC CC CC CC          mov cx, [CCCCCCCCH] ; %I1+12
07FA4C42  66 89 0D CC CC CC CC          mov [CCCCCCCCH], cx ; $$DATA$$+54

07FA4C49  66 8B 0D CC CC CC CC          mov cx, [CCCCCCCCH] ; %I1+14
07FA4C50  66 89 0D CC CC CC CC          mov [CCCCCCCCH], cx ; $$DATA$$+56

07FA4C57  8B E5                         mov esp, ebp
07FA4C59  5D                            pop ebp

07FA4C5A  C3                            ret


*** OUTPUT:
07FA4C5B  55                            push ebp
07FA4C5C  8B EC                         mov ebp, esp

07FA4C5E  8B E5                         mov esp, ebp
07FA4C60  5D                            pop ebp

07FA4C61  C3                            ret



**************************************************
	Task Background init code
**************************************************

07FA4C62  55                            push ebp
07FA4C63  8B EC                         mov ebp, esp

07FA4C65  8B E5                         mov esp, ebp
07FA4C67  5D                            pop ebp

07FA4C68  C3                            ret

**************************************************
	List program: sr_init_counters
**************************************************

PROGRAM sr_init_counters

END_PROGRAM

07FA4C80  55                            push ebp
07FA4C81  8B EC                         mov ebp, esp
07FA4C83  60                            pushad

#0		{SRC:sr_init_counters}
#1		(*$WAITSWITCH$*)
#2		
#3			(* kw_counter 	:= epprom_kw_cnt; *)
#4			MOVE		epprom_kw_cnt,kw_counter	{LNXT:1|2|-1}
(*) UDINT
07FA4C84  8B 05 CC CC CC CC             mov eax, [CCCCCCCCH] ; %M101+8
07FA4C8A  89 05 CC CC CC CC             mov [CCCCCCCCH], eax ; %M110+4

#5		
#6			(* q_counter	:= epprom_q_cnt; *)
#7			MOVE		epprom_q_cnt,q_counter	{LNXT:2|1|-1}
(*) DWORD
07FA4C90  8B 05 CC CC CC CC             mov eax, [CCCCCCCCH] ; %M101+0
07FA4C96  89 05 CC CC CC CC             mov [CCCCCCCCH], eax ; %M110+8

07FA4C9C  61                            popad
07FA4C9D  5D                            pop ebp

07FA4C9E  C3                            ret

END_PROGRAM


**************************************************
	Target variable image generation
**************************************************


*** INPUT:
07FA4C9F  C3                            ret


*** OUTPUT:
07FA4CA0  C3                            ret



**************************************************
	Task Boot init code
**************************************************

07FA4CA1  55                            push ebp
07FA4CA2  8B EC                         mov ebp, esp

07FA4CA4  8B E5                         mov esp, ebp
07FA4CA6  5D                            pop ebp

07FA4CA7  C3                            ret

**************************************************
	List program: init_val
**************************************************

PROGRAM init_val

END_PROGRAM

07FA4CC0  55                            push ebp
07FA4CC1  8B EC                         mov ebp, esp
07FA4CC3  60                            pushad

#0		{SRC:init_val}
#1		(*$WAITSWITCH$*)
#2		
#3		
#4			(* IF di_val_close_state_R *)
#5			LD		di_val_close_state_R	{LNXT:1|-1|-1}
(*) UNDEF
07FA4CC4  33 C0                         xor eax, eax
07FA4CC6  8A 05 CC CC CC CC             mov al, [CCCCCCCCH] ; %I0+0

#6			NOT	{LNXT:1|-1|-1}
(*) BOOL
07FA4CCC  84 C0                         test al, al
07FA4CCE  0F 94 C0                      sete al

#7			JMPCN	$label0	{LNXT:1|2|6}
(-) BOOL
07FA4CD1  84 C0                         test al, al
07FA4CD3  90 74 1F 90 90 90             je 07FA4CF5H

#8		
#9			(* THEN *)
#10		
#11				(* o_val_close_R:=true; *)
#12				MOVE		true,o_val_close_R	{LNXT:2|3|-1}
(*) BOOL
07FA4CD9  B8 01 00 00 00                mov eax, 01H
07FA4CDE  84 C0                         test al, al
07FA4CE0  0F 95 05 CC CC CC CC          setne [CCCCCCCCH] ; %Q1+3

#13		
#14				(* o_val_open_R:=false; *)
#15				MOVE		false,o_val_open_R	{LNXT:3|6|-1}
(*) BOOL
07FA4CE7  B8 00 00 00 00                mov eax, 00H
07FA4CEC  84 C0                         test al, al
07FA4CEE  0F 95 05 CC CC CC CC          setne [CCCCCCCCH] ; %Q1+2

#16		
#17		$label0:
#18			(* END_IF *)
#19		
#20		
#21			(* IF di_val_close_state_fall = 0 *)
#22			LD		di_val_close_state_fall	{LNXT:6|-1|-1}
(*) UNDEF
07FA4CF5  0F BF 05 CC CC CC CC          movsx eax, word ptr [CCCCCCCCH] ; %I1+8

#23			EQ		0	{LNXT:6|-1|-1}
(*) INT
07FA4CFC  3D 00 00 00 00                cmp eax, 0
07FA4D01  0F 94 C0                      sete al
07FA4D04  25 FF 00 00 00                and eax, 0FFh

#24			JMPCN	$label1	{LNXT:6|7|1}
(-) BOOL
07FA4D09  84 C0                         test al, al
07FA4D0B  90 74 1F 90 90 90             je 07FA4D2DH

#25		
#26			(* THEN *)
#27		
#28				(* o_val_close_fall:=true; *)
#29				MOVE		true,o_val_close_fall	{LNXT:7|8|-1}
(*) BOOL
07FA4D11  B8 01 00 00 00                mov eax, 01H
07FA4D16  84 C0                         test al, al
07FA4D18  0F 95 05 CC CC CC CC          setne [CCCCCCCCH] ; %Q1+1

#30		
#31				(* o_val_open_fall:=false; *)
#32				MOVE		false,o_val_open_fall	{LNXT:8|1|-1}
(*) BOOL
07FA4D1F  B8 00 00 00 00                mov eax, 00H
07FA4D24  84 C0                         test al, al
07FA4D26  0F 95 05 CC CC CC CC          setne [CCCCCCCCH] ; %Q1+0

07FA4D2D  61                            popad
07FA4D2E  5D                            pop ebp

07FA4D2F  C3                            ret

END_PROGRAM


**************************************************
	Target variable image generation
**************************************************


*** INPUT:
07FA4D30  C3                            ret


*** OUTPUT:
07FA4D31  C3                            ret



**************************************************
	Task Init init code
**************************************************

07FA4D32  55                            push ebp
07FA4D33  8B EC                         mov ebp, esp

07FA4D35  8B E5                         mov esp, ebp
07FA4D37  5D                            pop ebp

07FA4D38  C3                            ret

**************************************************
	List program: InitParDB
**************************************************

PROGRAM InitParDB

        VAR
warningsKiller : USINT;
dummyCrc32 : UDINT;
	END_VAR

END_PROGRAM

07FA4D50  55                            push ebp
07FA4D51  8B EC                         mov ebp, esp
07FA4D53  60                            pushad

#0		{SRC:InitParDB}
#1		(*$WAITSWITCH$*)
#2		
#3			(* dummyCrc32 := 541599759; *)
#4			MOVE		541599759,dummyCrc32	{LNXT:3|5|-1}
(*) UDINT
07FA4D54  B8 0F 28 48 20                mov eax, 2048280FH
07FA4D59  89 05 CC CC CC CC             mov [CCCCCCCCH], eax ; $$DATA$$+60

#5		
#6			(* warningsKiller := sysDBase_SetExtTable( ADR( $$ParDB ), $$ParDBLength ); *)
#7			ADR		$$ParDB	{LNXT:5|3|-1}
(*) UDINT
07FA4D5F  B8 CC CC CC CC                mov eax, CCCCCCCCH ; $$CODE$$+336

#8			sysDBase_SetExtTable		$$ParDBLength	{LNXT:5|3|-1}
(*) @USINT
07FA4D64  68 16 00 00 00                push 22
07FA4D69  8B C8                         mov ecx, eax
07FA4D6B  51                            push ecx
07FA4D6C  B9 CC CC CC CC                mov ecx, CCCCCCCCH ; sysDBase_SetExtTable
07FA4D71  FF D1                         call ecx
07FA4D73  81 C4 08 00 00 00             add esp, 8

#9			ST		warningsKiller	{LNXT:5|3|-1}
(*) USINT
07FA4D79  88 05 CC CC CC CC             mov [CCCCCCCCH], al ; $$DATA$$+59

07FA4D7F  61                            popad
07FA4D80  5D                            pop ebp

07FA4D81  C3                            ret

END_PROGRAM


**************************************************
	Target variable image generation
**************************************************


*** INPUT:
07FA4D82  C3                            ret


*** OUTPUT:
07FA4D83  C3                            ret



**************************************************
	Task Serv init code
**************************************************

07FA4D84  55                            push ebp
07FA4D85  8B EC                         mov ebp, esp

07FA4D87  8B E5                         mov esp, ebp
07FA4D89  5D                            pop ebp

07FA4D8A  C3                            ret

**************************************************
	List program: sr_pressure
**************************************************

PROGRAM sr_pressure

        VAR
tmp_test : INT;
	END_VAR

END_PROGRAM

07FA4DA0  55                            push ebp
07FA4DA1  8B EC                         mov ebp, esp
07FA4DA3  60                            pushad

#0		{SRC:sr_pressure}
#1		(*$WAITSWITCH$*)
#2		
#3			(* Pressure := to_int(to_real(i_adc_pressure )/10); *)
#4			LDP0		i_adc_pressure	{LNXT:2|2|-1}
(*) UDINT
#5			to_real	{LNXT:2|2|-1}
(*) UDINT
07FA4DA4  0F BF 05 CC CC CC CC          movsx eax, word ptr [CCCCCCCCH] ; $$DATA$$+142
07FA4DAB  50                            push eax
07FA4DAC  DB 04 24                      fild dword ptr [esp]
07FA4DAF  58                            pop eax

#6			DIV		10	{LNXT:2|2|-1}
(*) REAL
07FA4DB0  68 0A 00 00 00                push 10
07FA4DB5  DA 34 24                      fidiv [esp]
07FA4DB8  81 C4 04 00 00 00             add esp, 4

#7			to_int	{LNXT:2|2|-1}
(*) REAL
07FA4DBE  81 EC 08 00 00 00             sub esp, 8
07FA4DC4  DF 3C 24                      fistp qword ptr [esp]
07FA4DC7  58                            pop eax
07FA4DC8  81 C4 04 00 00 00             add esp, 4

#8			ST		Pressure	{LNXT:2|2|-1}
(*) INT
07FA4DCE  66 89 05 CC CC CC CC          mov [CCCCCCCCH], ax ; %M110+0

END_PROGRAM
**************************************************
	List program: sr_counters
**************************************************

PROGRAM sr_counters

        VAR
kw_trig : R_TRIG;
q_trig : R_TRIG;
kw_pulses_per_acs : UINT;
q_pulses_per_acs : UINT;
test_freq : UDINT;
	END_VAR

END_PROGRAM

#0		{SRC:sr_counters}
#1		(*$WAITSWITCH$*)
#2		
#3			(* kw_pulses_per_acs 	:= 8000; *)
#4			MOVE		8000,kw_pulses_per_acs	{LNXT:2|3|-1}
(*) UDINT
07FA4DD5  B8 40 1F 00 00                mov eax, 1F40H
07FA4DDA  66 89 05 CC CC CC CC          mov [CCCCCCCCH], ax ; $$DATA$$+138

#5		
#6			(* q_pulses_per_acs	:= 1; *)
#7			MOVE		1,q_pulses_per_acs	{LNXT:3|15|-1}
(*) UINT
07FA4DE1  B8 01 00 00 00                mov eax, 01H
07FA4DE6  66 89 05 CC CC CC CC          mov [CCCCCCCCH], ax ; $$DATA$$+140

#8		
#9		
#10			(* IF fdi_q_cnt >= q_pulses_per_acs *)
#11			LD		fdi_q_cnt	{LNXT:15|-1|-1}
(*) UNDEF
07FA4DED  8B 05 CC CC CC CC             mov eax, [CCCCCCCCH] ; %M500+0

#12			GE		q_pulses_per_acs	{LNXT:15|-1|-1}
(*) UDINT
07FA4DF3  33 C9                         xor ecx, ecx
07FA4DF5  66 8B 0D CC CC CC CC          mov cx, [CCCCCCCCH] ; $$DATA$$+140
07FA4DFC  3B C1                         cmp eax, ecx
07FA4DFE  0F 93 C0                      setae al
07FA4E01  25 FF 00 00 00                and eax, 0FFh

#13			JMPCN	$label0	{LNXT:15|16|20}
(-) BOOL
07FA4E06  84 C0                         test al, al
07FA4E08  90 74 22 90 90 90             je 07FA4E2DH

#14		
#15			(* THEN *)
#16		
#17				(* q_counter := q_counter + 1; *)
#18				LD		q_counter	{LNXT:16|17|-1}
(*) UNDEF
07FA4E0E  8B 05 CC CC CC CC             mov eax, [CCCCCCCCH] ; %M110+8

#19				ADD		1	{LNXT:16|17|-1}
(*) DWORD
07FA4E14  05 01 00 00 00                add eax, 1

#20				ST		q_counter	{LNXT:16|17|-1}
(*) DWORD
07FA4E19  89 05 CC CC CC CC             mov [CCCCCCCCH], eax ; %M110+8

#21		
#22				(* fdi_q_reset := true; *)
#23				MOVE		true,fdi_q_reset	{LNXT:17|20|-1}
(*) DWORD
07FA4E1F  B8 01 00 00 00                mov eax, 01H
07FA4E24  84 C0                         test al, al
07FA4E26  0F 95 05 CC CC CC CC          setne [CCCCCCCCH] ; %M550+0

#24		
#25		$label0:
#26			(* END_IF *)
#27		
#28			(* q_value := to_int((3600 * to_real(fdi_q_freq)) / (to_real(q_pulses_per_acs) / 1)); *)
#29			LDP0		fdi_q_freq	{LNXT:20|2|-1}
(*) BOOL
#30			to_real	{LNXT:20|2|-1}
(*) BOOL
07FA4E2D  8B 05 CC CC CC CC             mov eax, [CCCCCCCCH] ; %M500+4
07FA4E33  68 00 00 00 00                push 0
07FA4E38  50                            push eax
07FA4E39  DF 2C 24                      fild qword ptr [esp]
07FA4E3C  81 C4 08 00 00 00             add esp, 8

#31			MUL		3600	{LNXT:20|2|-1}
(*) REAL
07FA4E42  68 10 0E 00 00                push 3600
07FA4E47  DA 0C 24                      fimul [esp]
07FA4E4A  81 C4 04 00 00 00             add esp, 4

#32			DIV(		0	{LNXT:20|2|-1}
(*) REAL
07FA4E50  81 EC 04 00 00 00             sub esp, 4
07FA4E56  D9 1C 24                      fstp dword ptr [esp]
07FA4E59  B8 00 00 00 00                mov eax, 00H

#33			LDP0		q_pulses_per_acs	{LNXT:20|2|-1}
(*) USINT
#34			to_real	{LNXT:20|2|-1}
(*) USINT
07FA4E5E  33 C0                         xor eax, eax
07FA4E60  66 8B 05 CC CC CC CC          mov ax, [CCCCCCCCH] ; $$DATA$$+140
07FA4E67  68 00 00 00 00                push 0
07FA4E6C  50                            push eax
07FA4E6D  DF 2C 24                      fild qword ptr [esp]
07FA4E70  81 C4 08 00 00 00             add esp, 8

#35			DIV		1	{LNXT:20|2|-1}
(*) REAL
07FA4E76  68 01 00 00 00                push 1
07FA4E7B  DA 34 24                      fidiv [esp]
07FA4E7E  81 C4 04 00 00 00             add esp, 4

#36			)	{LNXT:20|2|-1}
(*) REAL
07FA4E84  81 EC 04 00 00 00             sub esp, 4
07FA4E8A  D9 1C 24                      fstp dword ptr [esp]
07FA4E8D  D9 44 24 04                   fld dword ptr 4[esp]
07FA4E91  D8 34 24                      fdiv dword ptr [esp]
07FA4E94  81 C4 08 00 00 00             add esp, 8

#37			to_int	{LNXT:20|2|-1}
(*) REAL
07FA4E9A  81 EC 08 00 00 00             sub esp, 8
07FA4EA0  DF 3C 24                      fistp qword ptr [esp]
07FA4EA3  58                            pop eax
07FA4EA4  81 C4 04 00 00 00             add esp, 4

#38			ST		q_value	{LNXT:20|2|-1}
(*) INT
07FA4EAA  66 89 05 CC CC CC CC          mov [CCCCCCCCH], ax ; %M110+14

END_PROGRAM
**************************************************
	List program: sr_save_counters
**************************************************

PROGRAM sr_save_counters

        VAR
power_err : R_TRIG;
ton_start_up : TON;
res_q : BOOL;
res_kw : BOOL;
	END_VAR

END_PROGRAM

#0		{SRC:sr_save_counters}
#1		(*$WAITSWITCH$*)
#2		
#3			(* ton_start_up *)
#4			MOVE		true,ton_start_up.IN	{LNXT:1|-1|-1}
(*) UDINT
07FA4EB1  B8 01 00 00 00                mov eax, 01H
07FA4EB6  84 C0                         test al, al
07FA4EB8  0F 95 05 CC CC CC CC          setne [CCCCCCCCH] ; $$DATA$$+148

#5			MOVE		5000,ton_start_up.PT	{LNXT:1|-1|-1}
(*) BOOL
07FA4EBF  B8 88 13 00 00                mov eax, 1388H
07FA4EC4  89 05 CC CC CC CC             mov [CCCCCCCCH], eax ; $$DATA$$+149

#6			CAL		ton_start_up	{LNXT:1|2|-1}
(*) UDINT
07FA4ECA  50                            push eax
07FA4ECB  BB CC CC CC CC                mov ebx, CCCCCCCCH ; $$DATA$$+144
07FA4ED0  E8 E4 F5 FF FF                call 07FA44B9H ; $$CODE$$+17593
07FA4ED5  58                            pop eax

#7		
#8			(* power_err *)
#9			LD		ton_start_up.Q	{LNXT:2|-1|-1}
(*) UNDEF
07FA4ED6  33 C0                         xor eax, eax
07FA4ED8  8A 05 CC CC CC CC             mov al, [CCCCCCCCH] ; $$DATA$$+153

#10			AND		i_rnpp	{LNXT:2|-1|-1}
(*) BOOL
07FA4EDE  33 C9                         xor ecx, ecx
07FA4EE0  8A 0D CC CC CC CC             mov cl, [CCCCCCCCH] ; $$DATA$$+135
07FA4EE6  23 C1                         and eax, ecx

#11			ST		power_err.clk	{LNXT:2|-1|-1}
(*) BOOL
07FA4EE8  84 C0                         test al, al
07FA4EEA  0F 95 05 CC CC CC CC          setne [CCCCCCCCH] ; $$DATA$$+167

#12			CAL		power_err	{LNXT:2|3|-1}
(*) BOOL
07FA4EF1  50                            push eax
07FA4EF2  BB CC CC CC CC                mov ebx, CCCCCCCCH ; $$DATA$$+166
07FA4EF7  E8 94 F5 FF FF                call 07FA4490H ; $$CODE$$+17552
07FA4EFC  58                            pop eax

#13		
#14		
#15			(* IF power_err.q *)
#16			LD		power_err.q	{LNXT:3|-1|-1}
(*) UNDEF
07FA4EFD  33 C0                         xor eax, eax
07FA4EFF  8A 05 CC CC CC CC             mov al, [CCCCCCCCH] ; $$DATA$$+168

#17			JMPCN	$label0	{LNXT:3|4|1}
(-) BOOL
07FA4F05  84 C0                         test al, al
07FA4F07  0F 84 82 00 00 00             je 07FA4F8FH

#18		
#19			(* THEN *)
#20		
#21		
#22				(* IF epprom_q_cnt <> q_counter *)
#23				LD		epprom_q_cnt	{LNXT:4|-1|-1}
(*) UNDEF
07FA4F0D  8B 05 CC CC CC CC             mov eax, [CCCCCCCCH] ; %M101+0

#24				NE		q_counter	{LNXT:4|-1|-1}
(*) DWORD
07FA4F13  3B 05 CC CC CC CC             cmp eax, [CCCCCCCCH] ; %M110+8
07FA4F19  0F 95 C0                      setne al
07FA4F1C  25 FF 00 00 00                and eax, 0FFh

#25				JMPCN	$label1	{LNXT:4|4|5}
(-) BOOL
07FA4F21  84 C0                         test al, al
07FA4F23  90 74 28 90 90 90             je 07FA4F4EH

#26		
#27				(* THEN *)
#28		
#29					(* res_q := sysWriteParUINT(ADR(epprom_q_cnt), q_counter); *)
#30					ADR		epprom_q_cnt	{LNXT:4|5|-1}
(*) BOOL
07FA4F29  B8 CC CC CC CC                mov eax, CCCCCCCCH ; %M101+0

#31					sysWriteParUINT		q_counter	{LNXT:4|5|-1}
(*) @DWORD
07FA4F2E  8B 0D CC CC CC CC             mov ecx, [CCCCCCCCH] ; %M110+8
07FA4F34  51                            push ecx
07FA4F35  8B C8                         mov ecx, eax
07FA4F37  51                            push ecx
07FA4F38  B9 CC CC CC CC                mov ecx, CCCCCCCCH ; sysWriteParUINT
07FA4F3D  FF D1                         call ecx
07FA4F3F  81 C4 08 00 00 00             add esp, 8

#32					ST		res_q	{LNXT:4|5|-1}
(*) BOOL
07FA4F45  84 C0                         test al, al
07FA4F47  0F 95 05 CC CC CC CC          setne [CCCCCCCCH] ; $$DATA$$+137

#33		
#34		$label1:
#35				(* END_IF *)
#36		
#37		
#38				(* IF epprom_kw_cnt <> kw_counter *)
#39				LD		epprom_kw_cnt	{LNXT:5|-1|-1}
(*) UNDEF
07FA4F4E  8B 05 CC CC CC CC             mov eax, [CCCCCCCCH] ; %M101+8

#40				NE		kw_counter	{LNXT:5|-1|-1}
(*) DWORD
07FA4F54  3B 05 CC CC CC CC             cmp eax, [CCCCCCCCH] ; %M110+4
07FA4F5A  0F 95 C0                      setne al
07FA4F5D  25 FF 00 00 00                and eax, 0FFh

#41				JMPCN	$label2	{LNXT:5|5|1}
(-) BOOL
07FA4F62  84 C0                         test al, al
07FA4F64  90 74 28 90 90 90             je 07FA4F8FH

#42		
#43				(* THEN *)
#44		
#45					(* res_kw := sysWriteParUINT(ADR(epprom_kw_cnt), kw_counter); *)
#46					ADR		epprom_kw_cnt	{LNXT:5|1|-1}
(*) BOOL
07FA4F6A  B8 CC CC CC CC                mov eax, CCCCCCCCH ; %M101+8

#47					sysWriteParUINT		kw_counter	{LNXT:5|1|-1}
(*) @DWORD
07FA4F6F  8B 0D CC CC CC CC             mov ecx, [CCCCCCCCH] ; %M110+4
07FA4F75  51                            push ecx
07FA4F76  8B C8                         mov ecx, eax
07FA4F78  51                            push ecx
07FA4F79  B9 CC CC CC CC                mov ecx, CCCCCCCCH ; sysWriteParUINT
07FA4F7E  FF D1                         call ecx
07FA4F80  81 C4 08 00 00 00             add esp, 8

#48					ST		res_kw	{LNXT:5|1|-1}
(*) BOOL
07FA4F86  84 C0                         test al, al
07FA4F88  0F 95 05 CC CC CC CC          setne [CCCCCCCCH] ; $$DATA$$+177

END_PROGRAM
**************************************************
	List program: sr_ATS_Ctrl
**************************************************

PROGRAM sr_ATS_Ctrl

        VAR
TON_StartUp_1 : TON;
TON_StartUp_2 : TON;
stopping_timer : TON;
downtimeIN : BOOL;
washing_timer : TON;
checkWashAndStart : CheckWashAndStart;
isRunningWash : BOOL;
onWash : BOOL := false;
time_sec : INT := 4000;
	END_VAR

END_PROGRAM

#0		{SRC:sr_ATS_Ctrl}
#1		(*$WAITSWITCH$*)
#2		
#3		
#4			(* IF i_pb_rem = 1 And
#5		Not Alarms.0 And 
#6		Not Alarms.3 And 
#7		Not Alarms.4 And 
#8		Not Alarms.5 And 
#9		Not Alarms.7 *)
#10			LD		Alarms.7	{LNXT:2|-1|-1}
(*) UNDEF
07FA4F8F  33 C0                         xor eax, eax
07FA4F91  66 8B 05 CC CC CC CC          mov ax, [CCCCCCCCH] ; %M110+32
07FA4F98  C1 E8 07                      shr eax, 7
07FA4F9B  25 01 00 00 00                and eax, 1

#11			NOT	{LNXT:2|-1|-1}
(*) BOOL
07FA4FA0  84 C0                         test al, al
07FA4FA2  0F 94 C0                      sete al

#12			AND(		Alarms.5	{LNXT:2|-1|-1}
(*) BOOL
07FA4FA5  50                            push eax
07FA4FA6  33 C0                         xor eax, eax
07FA4FA8  66 8B 05 CC CC CC CC          mov ax, [CCCCCCCCH] ; %M110+32
07FA4FAF  C1 E8 05                      shr eax, 5
07FA4FB2  25 01 00 00 00                and eax, 1

#13			NOT	{LNXT:2|-1|-1}
(*) BOOL
07FA4FB7  84 C0                         test al, al
07FA4FB9  0F 94 C0                      sete al

#14			AND(		Alarms.4	{LNXT:2|-1|-1}
(*) BOOL
07FA4FBC  50                            push eax
07FA4FBD  33 C0                         xor eax, eax
07FA4FBF  66 8B 05 CC CC CC CC          mov ax, [CCCCCCCCH] ; %M110+32
07FA4FC6  C1 E8 04                      shr eax, 4
07FA4FC9  25 01 00 00 00                and eax, 1

#15			NOT	{LNXT:2|-1|-1}
(*) BOOL
07FA4FCE  84 C0                         test al, al
07FA4FD0  0F 94 C0                      sete al

#16			AND(		Alarms.3	{LNXT:2|-1|-1}
(*) BOOL
07FA4FD3  50                            push eax
07FA4FD4  33 C0                         xor eax, eax
07FA4FD6  66 8B 05 CC CC CC CC          mov ax, [CCCCCCCCH] ; %M110+32
07FA4FDD  C1 E8 03                      shr eax, 3
07FA4FE0  25 01 00 00 00                and eax, 1

#17			NOT	{LNXT:2|-1|-1}
(*) BOOL
07FA4FE5  84 C0                         test al, al
07FA4FE7  0F 94 C0                      sete al

#18			AND(		Alarms.0	{LNXT:2|-1|-1}
(*) BOOL
07FA4FEA  50                            push eax
07FA4FEB  33 C0                         xor eax, eax
07FA4FED  66 8B 05 CC CC CC CC          mov ax, [CCCCCCCCH] ; %M110+32
07FA4FF4  25 01 00 00 00                and eax, 1

#19			NOT	{LNXT:2|-1|-1}
(*) BOOL
07FA4FF9  84 C0                         test al, al
07FA4FFB  0F 94 C0                      sete al

#20			AND(		i_pb_rem	{LNXT:2|-1|-1}
(*) BOOL
07FA4FFE  50                            push eax
07FA4FFF  0F BF 05 CC CC CC CC          movsx eax, word ptr [CCCCCCCCH] ; $$DATA$$+64

#21			EQ		1	{LNXT:2|-1|-1}
(*) INT
07FA5006  3D 01 00 00 00                cmp eax, 1
07FA500B  0F 94 C0                      sete al
07FA500E  25 FF 00 00 00                and eax, 0FFh

#22			)	{LNXT:2|-1|-1}
(*) BOOL
07FA5013  8B C8                         mov ecx, eax
07FA5015  58                            pop eax
07FA5016  23 C1                         and eax, ecx

#23			)	{LNXT:2|-1|-1}
(*) BOOL
07FA5018  8B C8                         mov ecx, eax
07FA501A  58                            pop eax
07FA501B  23 C1                         and eax, ecx

#24			)	{LNXT:2|-1|-1}
(*) BOOL
07FA501D  8B C8                         mov ecx, eax
07FA501F  58                            pop eax
07FA5020  23 C1                         and eax, ecx

#25			)	{LNXT:2|-1|-1}
(*) BOOL
07FA5022  8B C8                         mov ecx, eax
07FA5024  58                            pop eax
07FA5025  23 C1                         and eax, ecx

#26			)	{LNXT:2|-1|-1}
(*) BOOL
07FA5027  8B C8                         mov ecx, eax
07FA5029  58                            pop eax
07FA502A  23 C1                         and eax, ecx

#27			JMPCN	$label0	{LNXT:2|9|25}
(-) BOOL
07FA502C  84 C0                         test al, al
07FA502E  0F 84 92 00 00 00             je 07FA50C6H

#28		
#29			(* THEN *)
#30		
#31		
#32				(* IF CMD.0 *)
#33				LD		CMD.0	{LNXT:9|-1|-1}
(*) UNDEF
07FA5034  33 C0                         xor eax, eax
07FA5036  66 8B 05 CC CC CC CC          mov ax, [CCCCCCCCH] ; %M110+34
07FA503D  25 01 00 00 00                and eax, 1

#34				JMPCN	$label2	{LNXT:9|10|21}
(-) BOOL
07FA5042  84 C0                         test al, al
07FA5044  90 74 6C 90 90 90             je 07FA50B3H

#35		
#36				(* THEN *)
#37		
#38					(* checkWashAndStart *)
#39					MOVE		o_val_close_fall,checkWashAndStart.o_val_close_fall_FB	{LNXT:10|-1|-1}
(*) BOOL
07FA504A  B8 CC CC CC CC                mov eax, CCCCCCCCH ; %Q1+1
07FA504F  89 05 CC CC CC CC             mov [CCCCCCCCH], eax ; $$DATA$$+108

#40					MOVE		o_val_close_R,checkWashAndStart.o_val_close_R_FB	{LNXT:11|-1|-1}
(*) BOOL^
07FA5055  B8 CC CC CC CC                mov eax, CCCCCCCCH ; %Q1+3
07FA505A  89 05 CC CC CC CC             mov [CCCCCCCCH], eax ; $$DATA$$+100

#41					MOVE		o_val_open_fall,checkWashAndStart.o_val_open_fall_FB	{LNXT:12|-1|-1}
(*) BOOL^
07FA5060  B8 CC CC CC CC                mov eax, CCCCCCCCH ; %Q1+0
07FA5065  89 05 CC CC CC CC             mov [CCCCCCCCH], eax ; $$DATA$$+104

#42					MOVE		o_val_open_R,checkWashAndStart.o_val_open_R_FB	{LNXT:13|-1|-1}
(*) BOOL^
07FA506B  B8 CC CC CC CC                mov eax, CCCCCCCCH ; %Q1+2
07FA5070  89 05 CC CC CC CC             mov [CCCCCCCCH], eax ; $$DATA$$+96

#43					MOVE		sv_washing,checkWashAndStart.sv_washing_FB	{LNXT:14|-1|-1}
(*) BOOL^
07FA5076  B8 CC CC CC CC                mov eax, CCCCCCCCH ; %M110+38
07FA507B  89 05 CC CC CC CC             mov [CCCCCCCCH], eax ; $$DATA$$+92

#44					MOVE		q_start_ats,checkWashAndStart.q_start_ats_FB	{LNXT:15|-1|-1}
(*) BOOL^
07FA5081  B8 CC CC CC CC                mov eax, CCCCCCCCH ; %Q1+7
07FA5086  89 05 CC CC CC CC             mov [CCCCCCCCH], eax ; $$DATA$$+112

#45					MOVE		time_sec,checkWashAndStart.ep_time_wash_FB	{LNXT:16|-1|-1}
(*) BOOL^
07FA508C  B8 CC CC CC CC                mov eax, CCCCCCCCH ; $$DATA$$+66
07FA5091  89 05 CC CC CC CC             mov [CCCCCCCCH], eax ; $$DATA$$+116

#46					MOVE		i_val_state,checkWashAndStart.i_val_state_FB	{LNXT:17|-1|-1}
(*) INT^
07FA5097  B8 CC CC CC CC                mov eax, CCCCCCCCH ; $$DATA$$+132
07FA509C  89 05 CC CC CC CC             mov [CCCCCCCCH], eax ; $$DATA$$+120

#47					CAL		checkWashAndStart	{LNXT:10|77|-1}
(*) INT^
07FA50A2  50                            push eax
07FA50A3  BB CC CC CC CC                mov ebx, CCCCCCCCH ; $$DATA$$+68
07FA50A8  E8 94 F4 FF FF                call 07FA4541H ; $$CODE$$+17729
07FA50AD  58                            pop eax

#48					JMP		$label3	{LNXT:9|10|21}
(-) INT^
07FA50AE  EB 11 90 90 90                jmp 07FA50C1H

#49		$label2:
#50		
#51				(* ELSE *)
#52		
#53					(* q_start_ats := False; *)
#54					MOVE		False,q_start_ats	{LNXT:21|77|-1}
(*) INT^
07FA50B3  B8 00 00 00 00                mov eax, 00H
07FA50B8  84 C0                         test al, al
07FA50BA  0F 95 05 CC CC CC CC          setne [CCCCCCCCH] ; %Q1+7

#55		
#56		$label3:
#57				(* END_IF *)
#58				JMP		$label1	{LNXT:2|9|25}
(-) BOOL
07FA50C1  EB 35 90 90 90                jmp 07FA50F8H

#59		$label0:
#60		
#61			(* ELSE *)
#62		
#63				(* CMD.0 := False; *)
#64				MOVE		False,CMD.0	{LNXT:25|26|-1}
(*) BOOL
07FA50C6  B8 00 00 00 00                mov eax, 00H
07FA50CB  84 C0                         test al, al
07FA50CD  90 75 11 90 90 90             jne 00000014H@
07FA50D3  66 0F BA 35 CC CC CC CC 00    btr word ptr [CCCCCCCCH], 0 ; %M110+34
07FA50DC  EB 0C 90 90 90                jmp 0000000EH@
07FA50E1  66 0F BA 2D CC CC CC CC 00    bts word ptr [CCCCCCCCH], 0 ; %M110+34

#65		
#66				(* q_start_ats := False; *)
#67				MOVE		False,q_start_ats	{LNXT:26|77|-1}
(*) WORD
07FA50EA  B8 00 00 00 00                mov eax, 00H
07FA50EF  84 C0                         test al, al
07FA50F1  0F 95 05 CC CC CC CC          setne [CCCCCCCCH] ; %Q1+7

#68		
#69		$label1:
#70			(* END_IF *)
#71		
#72		
#73			(* IF q_start_ats *)
#74			LD		q_start_ats	{LNXT:77|-1|-1}
(*) UNDEF
07FA50F8  33 C0                         xor eax, eax
07FA50FA  8A 05 CC CC CC CC             mov al, [CCCCCCCCH] ; %Q1+7

#75			NOT	{LNXT:77|-1|-1}
(*) BOOL
07FA5100  84 C0                         test al, al
07FA5102  0F 94 C0                      sete al

#76			JMPCN	$label4	{LNXT:77|78|80}
(-) BOOL
07FA5105  84 C0                         test al, al
07FA5107  90 74 16 90 90 90             je 07FA5120H

#77		
#78			(* THEN *)
#79		
#80				(* downtimeIN:=true; *)
#81				MOVE		true,downtimeIN	{LNXT:78|90|-1}
(*) BOOL
07FA510D  B8 01 00 00 00                mov eax, 01H
07FA5112  84 C0                         test al, al
07FA5114  0F 95 05 CC CC CC CC          setne [CCCCCCCCH] ; $$DATA$$+58

#82				JMP		$label5	{LNXT:77|78|80}
(-) BOOL
07FA511B  EB 11 90 90 90                jmp 07FA512EH

#83		$label4:
#84		
#85			(* ELSE *)
#86		
#87				(* downtimeIN:=false; *)
#88				MOVE		false,downtimeIN	{LNXT:80|90|-1}
(*) BOOL
07FA5120  B8 00 00 00 00                mov eax, 00H
07FA5125  84 C0                         test al, al
07FA5127  0F 95 05 CC CC CC CC          setne [CCCCCCCCH] ; $$DATA$$+58

#89		
#90		$label5:
#91			(* END_IF *)
#92		
#93			(* Alarms.2 := i_sns_door; *)
#94			MOVE		i_sns_door,Alarms.2	{LNXT:90|93|-1}
(*) BOOL
07FA512E  33 C0                         xor eax, eax
07FA5130  8A 05 CC CC CC CC             mov al, [CCCCCCCCH] ; $$DATA$$+134
07FA5136  84 C0                         test al, al
07FA5138  90 75 11 90 90 90             jne 00000014H@
07FA513E  66 0F BA 35 CC CC CC CC 02    btr word ptr [CCCCCCCCH], 2 ; %M110+32
07FA5147  EB 0C 90 90 90                jmp 0000000EH@
07FA514C  66 0F BA 2D CC CC CC CC 02    bts word ptr [CCCCCCCCH], 2 ; %M110+32

#95		
#96			(* Alarms.3 := i_rnpp; *)
#97			MOVE		i_rnpp,Alarms.3	{LNXT:93|99|-1}
(*) BOOL
07FA5155  33 C0                         xor eax, eax
07FA5157  8A 05 CC CC CC CC             mov al, [CCCCCCCCH] ; $$DATA$$+135
07FA515D  84 C0                         test al, al
07FA515F  90 75 11 90 90 90             jne 00000014H@
07FA5165  66 0F BA 35 CC CC CC CC 03    btr word ptr [CCCCCCCCH], 3 ; %M110+32
07FA516E  EB 0C 90 90 90                jmp 0000000EH@
07FA5173  66 0F BA 2D CC CC CC CC 03    bts word ptr [CCCCCCCCH], 3 ; %M110+32

#98		
#99			(* Alarms.5 := i_no_alm_ats; *)
#100			MOVE		i_no_alm_ats,Alarms.5	{LNXT:99|140|-1}
(*) BOOL
07FA517C  33 C0                         xor eax, eax
07FA517E  8A 05 CC CC CC CC             mov al, [CCCCCCCCH] ; $$DATA$$+136
07FA5184  84 C0                         test al, al
07FA5186  90 75 11 90 90 90             jne 00000014H@
07FA518C  66 0F BA 35 CC CC CC CC 05    btr word ptr [CCCCCCCCH], 5 ; %M110+32
07FA5195  EB 0C 90 90 90                jmp 0000000EH@
07FA519A  66 0F BA 2D CC CC CC CC 05    bts word ptr [CCCCCCCCH], 5 ; %M110+32

#101		
#102		
#103			(* IF CMD.1 *)
#104			LD		CMD.1	{LNXT:140|-1|-1}
(*) UNDEF
07FA51A3  33 C0                         xor eax, eax
07FA51A5  66 8B 05 CC CC CC CC          mov ax, [CCCCCCCCH] ; %M110+34
07FA51AC  C1 E8 01                      shr eax, 1
07FA51AF  25 01 00 00 00                and eax, 1

#105			JMPCN	$label6	{LNXT:140|141|2}
(-) BOOL
07FA51B4  84 C0                         test al, al
07FA51B6  90 74 33 90 90 90             je 07FA51ECH

#106		
#107			(* THEN *)
#108		
#109				(* Alarms := 0; *)
#110				MOVE		0,Alarms	{LNXT:141|142|-1}
(*) BOOL
07FA51BC  B8 00 00 00 00                mov eax, 00H
07FA51C1  66 89 05 CC CC CC CC          mov [CCCCCCCCH], ax ; %M110+32

#111		
#112				(* CMD.1 := False; *)
#113				MOVE		False,CMD.1	{LNXT:142|2|-1}
(*) WORD
07FA51C8  B8 00 00 00 00                mov eax, 00H
07FA51CD  84 C0                         test al, al
07FA51CF  90 75 11 90 90 90             jne 00000014H@
07FA51D5  66 0F BA 35 CC CC CC CC 01    btr word ptr [CCCCCCCCH], 1 ; %M110+34
07FA51DE  EB 0C 90 90 90                jmp 0000000EH@
07FA51E3  66 0F BA 2D CC CC CC CC 01    bts word ptr [CCCCCCCCH], 1 ; %M110+34

07FA51EC  61                            popad
07FA51ED  5D                            pop ebp

07FA51EE  C3                            ret

END_PROGRAM


**************************************************
	Target variable image generation
**************************************************


*** INPUT:
07FA51EF  55                            push ebp
07FA51F0  8B EC                         mov ebp, esp

07FA51F2  66 8B 0D CC CC CC CC          mov cx, [CCCCCCCCH] ; %I1+14
07FA51F9  66 89 0D CC CC CC CC          mov [CCCCCCCCH], cx ; $$DATA$$+64

07FA5200  66 8B 0D CC CC CC CC          mov cx, [CCCCCCCCH] ; %I1+4
07FA5207  66 89 0D CC CC CC CC          mov [CCCCCCCCH], cx ; $$DATA$$+132

07FA520E  8A 0D CC CC CC CC             mov cl, [CCCCCCCCH] ; %I0+3
07FA5214  88 0D CC CC CC CC             mov [CCCCCCCCH], cl ; $$DATA$$+134

07FA521A  8A 0D CC CC CC CC             mov cl, [CCCCCCCCH] ; %I0+4
07FA5220  88 0D CC CC CC CC             mov [CCCCCCCCH], cl ; $$DATA$$+135

07FA5226  8A 0D CC CC CC CC             mov cl, [CCCCCCCCH] ; %I0+6
07FA522C  88 0D CC CC CC CC             mov [CCCCCCCCH], cl ; $$DATA$$+136

07FA5232  66 8B 0D CC CC CC CC          mov cx, [CCCCCCCCH] ; %I1+0
07FA5239  66 89 0D CC CC CC CC          mov [CCCCCCCCH], cx ; $$DATA$$+142

07FA5240  8B E5                         mov esp, ebp
07FA5242  5D                            pop ebp

07FA5243  C3                            ret


*** OUTPUT:
07FA5244  55                            push ebp
07FA5245  8B EC                         mov ebp, esp

07FA5247  8B E5                         mov esp, ebp
07FA5249  5D                            pop ebp

07FA524A  C3                            ret



**************************************************
	Task Timed init code
**************************************************

07FA524B  55                            push ebp
07FA524C  8B EC                         mov ebp, esp

Var init: V::SR_ATS_CTRL.TIME_SEC = 4000
07FA524E  66 C7 05 CC CC CC CC A0 0F    mov word ptr [CCCCCCCCH], 0FA0H ; $$DATA$$+66

07FA5257  8B E5                         mov esp, ebp
07FA5259  5D                            pop ebp

07FA525A  C3                            ret



**************************************************
	Global init code
**************************************************

07FA5270  55                            push ebp
07FA5271  8B EC                         mov ebp, esp

Var init: V:EMBEDDEDELEMENTS:$$POUCBARRAY$$BACKGROUND = [?ATS_mdb.$$POUCB$$, 0]
07FA5273  B9 CC CC CC CC                mov ecx, CCCCCCCCH ; $$DATA$$+232
07FA5278  89 0D CC CC CC CC             mov [CCCCCCCCH], ecx ; $$DATA$$+180

Var init: V:EMBEDDEDELEMENTS:$$POUCBARRAY$$BOOT = [?sr_init_counters.$$POUCB$$, 0]
07FA527E  B9 CC CC CC CC                mov ecx, CCCCCCCCH ; $$DATA$$+238
07FA5283  89 0D CC CC CC CC             mov [CCCCCCCCH], ecx ; $$DATA$$+188

Var init: V:EMBEDDEDELEMENTS:$$POUCBARRAY$$INIT = [?init_val.$$POUCB$$, 0]
07FA5289  B9 CC CC CC CC                mov ecx, CCCCCCCCH ; $$DATA$$+244
07FA528E  89 0D CC CC CC CC             mov [CCCCCCCCH], ecx ; $$DATA$$+196

Var init: V:EMBEDDEDELEMENTS:$$POUCBARRAY$$SERV = [?InitParDB.$$POUCB$$, 0]
07FA5294  B9 CC CC CC CC                mov ecx, CCCCCCCCH ; $$DATA$$+250
07FA5299  89 0D CC CC CC CC             mov [CCCCCCCCH], ecx ; $$DATA$$+204

Var init: V:EMBEDDEDELEMENTS:$$POUCBARRAY$$TIMED = [?sr_pressure.$$POUCB$$, ?sr_counters.$$POUCB$$, ?sr_save_counters.$$POUCB$$, ?sr_ATS_Ctrl.$$POUCB$$, 0]
07FA529F  B9 CC CC CC CC                mov ecx, CCCCCCCCH ; $$DATA$$+256
07FA52A4  89 0D CC CC CC CC             mov [CCCCCCCCH], ecx ; $$DATA$$+212
07FA52AA  B9 CC CC CC CC                mov ecx, CCCCCCCCH ; $$DATA$$+262
07FA52AF  89 0D CC CC CC CC             mov [CCCCCCCCH], ecx ; $$DATA$$+216
07FA52B5  B9 CC CC CC CC                mov ecx, CCCCCCCCH ; $$DATA$$+268
07FA52BA  89 0D CC CC CC CC             mov [CCCCCCCCH], ecx ; $$DATA$$+220
07FA52C0  B9 CC CC CC CC                mov ecx, CCCCCCCCH ; $$DATA$$+274
07FA52C5  89 0D CC CC CC CC             mov [CCCCCCCCH], ecx ; $$DATA$$+224

07FA52CB  8B E5                         mov esp, ebp
07FA52CD  5D                            pop ebp

07FA52CE  C3                            ret



**************************************************
	Global RETAIN init code
**************************************************

07FA52CF  55                            push ebp
07FA52D0  8B EC                         mov ebp, esp

07FA52D2  8B E5                         mov esp, ebp
07FA52D4  5D                            pop ebp

07FA52D5  C3                            ret



**************************************************
	Task $$VirtualTables init code
**************************************************

07FA52D6  55                            push ebp
07FA52D7  8B EC                         mov ebp, esp

07FA52D9  8B E5                         mov esp, ebp
07FA52DB  5D                            pop ebp

07FA52DC  C3                            ret



********************************************
MEMORY MAP
********************************************

Code area type:          		       main code
Start code area:          		0000000007FA0000h
End code area:            		0000000007FA5BD8h
Code size:                		00005BD8h

Start local data area:    		0000000007E20000h
End local data area:      		0000000007E20118h
Local data size:          		00000118h

Start retentive data area:		0000000000000000h
End retentive data area:  		0000000000000000h
Retentive data size:      		00000000h

Start bit data area:      		0000000000000000h
End bit data area:        		0000000000000000h
Bit data size:            		00000000h



********************************************
CODE ID:                                0A3BC167
DEBUG MEMO ID:                          000034F7
FULL MEMO ID:                           0000FB84
RELOCATION ADDR:                        0000000007FA0000
********************************************
