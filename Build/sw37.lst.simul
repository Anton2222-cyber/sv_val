***********************************************************************
*
*	CODE GENERATION LISTING FOR: sw37
*	COMPILER VERSION: 6.0.0.52
*
***********************************************************************

**************************************************
	List function block: R_TRIG
**************************************************

FUNCTION_BLOCK R_TRIG

	{ DE:"<HTML>The output Q will remain FALSE as long as the input variable CLK is FALSE.<br>
As soon as CLK returns TRUE, Q will first return TRUE.<br><br>
This means each time the function is called up, Q will return FALSE until CLK has falling edge followed by an rising edge.<br><br>
<img src= r_trig.png>" }

        VAR_INPUT
clk : BOOL;	{ DE:"Input for edge detection" }
	END_VAR

        VAR_OUTPUT
q : BOOL;	{ DE:"Raising edge output" }
	END_VAR

        VAR
m : BOOL := FALSE;
	END_VAR

END_FUNCTION_BLOCK

08584470  55                            push ebp
08584471  8B EB                         mov ebp, ebx
08584473  57                            push edi

#0		{SRC:R_TRIG}
#1		
#2			LD		clk
(*) UNDEF
08584474  33 C0                         xor eax, eax
08584476  8A 45 01                      mov al, 1[ebp]

#3			ANDN	m
(*) BOOL
08584479  33 C9                         xor ecx, ecx
0858447B  8A 4D 00                      mov cl, [ebp]
0858447E  84 C9                         test cl, cl
08584480  0F 94 C1                      sete cl
08584483  23 C1                         and eax, ecx

#4			ST		q
(*) BOOL
08584485  84 C0                         test al, al
08584487  0F 95 45 02                   setne 2[ebp]

#5		
#6			LD		clk
(*) UNDEF
0858448B  33 C0                         xor eax, eax
0858448D  8A 45 01                      mov al, 1[ebp]

#7			ST		m
(*) BOOL
08584490  84 C0                         test al, al
08584492  0F 95 45 00                   setne [ebp]

08584496  5F                            pop edi
08584497  5D                            pop ebp

08584498  C3                            ret


Frame allocation (hex):

	0000 bit  0: VAR m
	0001 bit  0: VAR clk
	0002 bit  0: VAR q

END_FUNCTION_BLOCK
**************************************************
	List function block: TON
**************************************************

FUNCTION_BLOCK TON

	{ DE:"<HTML>The TON block produces a delayed output Q of the input IN. The delay time is expressed in milliseconds on the PT input.</br></br>
<img src= tonscheme.png>
<ul>
<li>if IN is FALSE Q is false</li>
<li>Q becomes TRUE as IN remains TRUE for PT milliseconds</li>
<li>Q remains TRUE until IN remains TRUE</li>
</ul>" }

        VAR_INPUT
IN : BOOL;	{ DE:"Timer input source" }
PT : UDINT;	{ DE:"Preset time value (ms)" }
	END_VAR

        VAR_OUTPUT
Q : BOOL;	{ DE:"Timer output" }
ET : UDINT;	{ DE:"Timer current value (ms)" }
	END_VAR

        VAR_EXTERNAL
	{G:"System_Timers"}
sysTimer AT %MD0.0 : UDINT;	{ DE:"System timer [ms]" }
	END_VAR

        VAR
timStart : UDINT;	{ DE:"Time value at start of counting" }
	END_VAR

END_FUNCTION_BLOCK

08584499  55                            push ebp
0858449A  8B EB                         mov ebp, ebx
0858449C  57                            push edi

#0		{SRC:TON}
#1		
#2			(*	Check if in counting	*)
#3		
#4			LD		IN
(*) UNDEF
0858449D  33 C0                         xor eax, eax
0858449F  8A 45 04                      mov al, 4[ebp]

#5			JMPCN	lReset
(-) BOOL
085844A2  84 C0                         test al, al
085844A4  90 74 61 90 90 90             je 08584508H

#6		
#7			(*	Check if Q is TRUE *)
#8			LD		Q
(*) UNDEF
085844AA  33 C0                         xor eax, eax
085844AC  8A 45 09                      mov al, 9[ebp]

#9			RETC
#10			
(-) BOOL
085844AF  84 C0                         test al, al
085844B1  90 75 6A 90 90 90             jne 0858451EH

#11			(*	Check if already in counting *)
#12			LD		timStart
(*) UNDEF
085844B7  8B 45 00                      mov eax, [ebp]

#13			EQ		0
(*) UDINT
085844BA  3D 00 00 00 00                cmp eax, 0
085844BF  0F 94 C0                      sete al
085844C2  25 FF 00 00 00                and eax, 0FFh

#14			JMPCN	lUpdate
(-) BOOL
085844C7  84 C0                         test al, al
085844C9  90 74 0C 90 90 90             je 085844D8H

#15		
#16			(*	Start of counting *)
#17			LD		sysTimer
(*) UNDEF
085844CF  8B 05 CC CC CC CC             mov eax, [CCCCCCCCH] ; %M0+0

#18			ST		timStart
(*) UDINT
085844D5  89 45 00                      mov [ebp], eax

#19			
#20		lUpdate:
#21		
#22			(*	Update timer and check if time elapsed *)
#23			LD		sysTimer
(*) UNDEF
085844D8  8B 05 CC CC CC CC             mov eax, [CCCCCCCCH] ; %M0+0

#24			SUB		timStart
(*) UDINT
085844DE  2B 45 00                      sub eax, [ebp]

#25			ST		ET
(*) UDINT
085844E1  89 45 0A                      mov 10[ebp], eax

#26			GE		PT
(*) UDINT
085844E4  3B 45 05                      cmp eax, [ebp+5]
085844E7  0F 93 C0                      setae al
085844EA  25 FF 00 00 00                and eax, 0FFh

#27			ST		Q
(*) BOOL
085844EF  84 C0                         test al, al
085844F1  0F 95 45 09                   setne 9[ebp]

#28			RETCN
#29		
(-) BOOL
085844F5  84 C0                         test al, al
085844F7  90 74 24 90 90 90             je 0858451EH

#30			(*	Limit actual time value *)
#31			LD		PT
(*) UNDEF
085844FD  8B 45 05                      mov eax, 5[ebp]

#32			ST		ET
(*) UDINT
08584500  89 45 0A                      mov 10[ebp], eax

#33			RET
#34		
(-) UDINT
08584503  EB 19 90 90 90                jmp 0858451EH

#35		lReset:
#36		
#37			(*	Reset status *)
#38			LD		0
(*) UNDEF
08584508  B8 00 00 00 00                mov eax, 00H

#39			ST		ET
(*) USINT
0858450D  89 45 0A                      mov 10[ebp], eax

#40			ST		timStart
(*) UDINT
08584510  89 45 00                      mov [ebp], eax

#41			LD		FALSE
(*) UNDEF
08584513  B8 00 00 00 00                mov eax, 00H

#42			ST		Q
(*) BOOL
08584518  84 C0                         test al, al
0858451A  0F 95 45 09                   setne 9[ebp]

0858451E  5F                            pop edi
0858451F  5D                            pop ebp

08584520  C3                            ret


Frame allocation (hex):

	0000       : VAR timStart
	0004 bit  0: VAR IN
	0005       : VAR PT
	0009 bit  0: VAR Q
	000A       : VAR ET

END_FUNCTION_BLOCK
**************************************************
	List function block: CheckWashAndStart
**************************************************

FUNCTION_BLOCK CheckWashAndStart

        VAR_IN_OUT
sv_washing_FB : BOOL^;
o_val_open_R_FB : BOOL^;
o_val_close_R_FB : BOOL^;
o_val_open_fall_FB : BOOL^;
o_val_close_fall_FB : BOOL^;
q_start_ats_FB : BOOL^;
ep_time_wash_FB : INT^;
i_val_state_FB : INT^;
	END_VAR

        VAR_OUTPUT
is_running_wash : BOOL;
	END_VAR

        VAR
washing_timer : TON;	{ DE:"локальний FB таймера" }
onWash : BOOL;
	END_VAR

END_FUNCTION_BLOCK

08584521  55                            push ebp
08584522  8B EB                         mov ebp, ebx
08584524  57                            push edi

#0		{SRC:CheckWashAndStart}
#1		(*$WAITSWITCH$*)
#2		
#3		
#4			(* IF sv_washing_FB^ and i_val_state_FB^=1 *)
#5			LD		i_val_state_FB^	{LNXT:1|-1|-1}
(*) UNDEF
08584525  8B 55 34                      mov edx, 52[ebp]
08584528  0F BF 02                      movsx eax, word ptr [edx]

#6			EQ		1	{LNXT:1|-1|-1}
(*) INT
0858452B  3D 01 00 00 00                cmp eax, 1
08584530  0F 94 C0                      sete al
08584533  25 FF 00 00 00                and eax, 0FFh

#7			AND		sv_washing_FB^	{LNXT:1|-1|-1}
(*) BOOL
08584538  8B 55 18                      mov edx, 24[ebp]
0858453B  8B 55 18                      mov edx, 24[ebp]
0858453E  33 C9                         xor ecx, ecx
08584540  8A 0A                         mov cl, [edx]
08584542  23 C1                         and eax, ecx

#8			JMPCN	$label0	{LNXT:1|2|5}
(-) BOOL
08584544  84 C0                         test al, al
08584546  90 74 0E 90 90 90             je 08584557H

#9		
#10			(* THEN *)
#11		
#12				(* onWash :=true; *)
#13				MOVE		true,onWash	{LNXT:2|5|-1}
(*) BOOL
0858454C  B8 01 00 00 00                mov eax, 01H
08584551  84 C0                         test al, al
08584553  0F 95 45 16                   setne 22[ebp]

#14		
#15		$label0:
#16			(* END_IF *)
#17		
#18		
#19			(* IF onWash *)
#20			LD		onWash	{LNXT:5|-1|-1}
(*) UNDEF
08584557  33 C0                         xor eax, eax
08584559  8A 45 16                      mov al, 22[ebp]

#21			JMPCN	$label1	{LNXT:5|6|16}
(-) BOOL
0858455C  84 C0                         test al, al
0858455E  90 74 54 90 90 90             je 085845B5H

#22		
#23			(* THEN *)
#24		
#25				(* is_running_wash :=true; *)
#26				MOVE		true,is_running_wash	{LNXT:6|7|-1}
(*) BOOL
08584564  B8 01 00 00 00                mov eax, 01H
08584569  84 C0                         test al, al
0858456B  0F 95 45 17                   setne 23[ebp]

#27		
#28				(* o_val_close_R_FB^:=true; *)
#29				MOVE		true,o_val_close_R_FB^	{LNXT:7|8|-1}
(*) BOOL
0858456F  B8 01 00 00 00                mov eax, 01H
08584574  8B 55 20                      mov edx, 32[ebp]
08584577  84 C0                         test al, al
08584579  0F 95 02                      setne [edx]

#30		
#31				(* o_val_open_R_FB^:=false; *)
#32				MOVE		false,o_val_open_R_FB^	{LNXT:8|10|-1}
(*) BOOL
0858457C  B8 00 00 00 00                mov eax, 00H
08584581  8B 55 1C                      mov edx, 28[ebp]
08584584  84 C0                         test al, al
08584586  0F 95 02                      setne [edx]

#33		
#34				(* o_val_open_fall_FB^:=true; *)
#35				MOVE		true,o_val_open_fall_FB^	{LNXT:10|11|-1}
(*) BOOL
08584589  B8 01 00 00 00                mov eax, 01H
0858458E  8B 55 24                      mov edx, 36[ebp]
08584591  84 C0                         test al, al
08584593  0F 95 02                      setne [edx]

#36		
#37				(* o_val_close_fall_FB^:=false; *)
#38				MOVE		false,o_val_close_fall_FB^	{LNXT:11|14|-1}
(*) BOOL
08584596  B8 00 00 00 00                mov eax, 00H
0858459B  8B 55 28                      mov edx, 40[ebp]
0858459E  84 C0                         test al, al
085845A0  0F 95 02                      setne [edx]

#39		
#40				(* q_start_ats_FB^:=true; *)
#41				MOVE		true,q_start_ats_FB^	{LNXT:14|20|-1}
(*) BOOL
085845A3  B8 01 00 00 00                mov eax, 01H
085845A8  8B 55 2C                      mov edx, 44[ebp]
085845AB  84 C0                         test al, al
085845AD  0F 95 02                      setne [edx]

#42				JMP		$label2	{LNXT:5|6|16}
(-) BOOL
085845B0  EB 10 90 90 90                jmp 085845C2H

#43		$label1:
#44		
#45			(* ELSE *)
#46		
#47				(* q_start_ats_FB^:=true; *)
#48				MOVE		true,q_start_ats_FB^	{LNXT:16|20|-1}
(*) BOOL
085845B5  B8 01 00 00 00                mov eax, 01H
085845BA  8B 55 2C                      mov edx, 44[ebp]
085845BD  84 C0                         test al, al
085845BF  0F 95 02                      setne [edx]

#49		
#50		$label2:
#51			(* END_IF *)
#52		
#53		
#54			(* IF washing_timer.Q *)
#55			LD		washing_timer.Q	{LNXT:20|-1|-1}
(*) UNDEF
085845C2  33 C0                         xor eax, eax
085845C4  8A 45 09                      mov al, 9[ebp]

#56			JMPCN	$label3	{LNXT:20|21|34}
(-) BOOL
085845C7  84 C0                         test al, al
085845C9  90 74 5A 90 90 90             je 08584626H

#57		
#58			(* THEN *)
#59		
#60				(* sv_washing_FB^:=false; *)
#61				MOVE		false,sv_washing_FB^	{LNXT:21|22|-1}
(*) BOOL
085845CF  B8 00 00 00 00                mov eax, 00H
085845D4  8B 55 18                      mov edx, 24[ebp]
085845D7  84 C0                         test al, al
085845D9  0F 95 02                      setne [edx]

#62		
#63				(* onWash :=false; *)
#64				MOVE		false,onWash	{LNXT:22|25|-1}
(*) BOOL
085845DC  B8 00 00 00 00                mov eax, 00H
085845E1  84 C0                         test al, al
085845E3  0F 95 45 16                   setne 22[ebp]

#65		
#66				(* o_val_close_R_FB^:=false; *)
#67				MOVE		false,o_val_close_R_FB^	{LNXT:25|26|-1}
(*) BOOL
085845E7  B8 00 00 00 00                mov eax, 00H
085845EC  8B 55 20                      mov edx, 32[ebp]
085845EF  84 C0                         test al, al
085845F1  0F 95 02                      setne [edx]

#68		
#69				(* o_val_open_fall_FB^:=false; *)
#70				MOVE		false,o_val_open_fall_FB^	{LNXT:26|28|-1}
(*) BOOL
085845F4  B8 00 00 00 00                mov eax, 00H
085845F9  8B 55 24                      mov edx, 36[ebp]
085845FC  84 C0                         test al, al
085845FE  0F 95 02                      setne [edx]

#71		
#72				(* o_val_open_R_FB^:=true; *)
#73				MOVE		true,o_val_open_R_FB^	{LNXT:28|29|-1}
(*) BOOL
08584601  B8 01 00 00 00                mov eax, 01H
08584606  8B 55 1C                      mov edx, 28[ebp]
08584609  84 C0                         test al, al
0858460B  0F 95 02                      setne [edx]

#74		
#75				(* o_val_close_fall_FB^:=true; *)
#76				MOVE		true,o_val_close_fall_FB^	{LNXT:29|31|-1}
(*) BOOL
0858460E  B8 01 00 00 00                mov eax, 01H
08584613  8B 55 28                      mov edx, 40[ebp]
08584616  84 C0                         test al, al
08584618  0F 95 02                      setne [edx]

#77		
#78				(* is_running_wash :=false; *)
#79				MOVE		false,is_running_wash	{LNXT:31|34|-1}
(*) BOOL
0858461B  B8 00 00 00 00                mov eax, 00H
08584620  84 C0                         test al, al
08584622  0F 95 45 17                   setne 23[ebp]

#80		
#81		$label3:
#82			(* END_IF *)
#83		
#84			(* washing_timer *)
#85			MOVE		onWash,washing_timer.IN	{LNXT:34|-1|-1}
(*) BOOL
08584626  33 C0                         xor eax, eax
08584628  8A 45 16                      mov al, 22[ebp]
0858462B  84 C0                         test al, al
0858462D  0F 95 45 04                   setne 4[ebp]

#86			MOVE		ep_time_wash_FB^,washing_timer.PT	{LNXT:34|-1|-1}
(*) BOOL
08584631  8B 55 30                      mov edx, 48[ebp]
08584634  0F BF 02                      movsx eax, word ptr [edx]
08584637  89 45 05                      mov 5[ebp], eax

#87			CAL		washing_timer	{LNXT:34|-1|-1}
(*) INT
0858463A  50                            push eax
0858463B  8B DD                         mov ebx, ebp
0858463D  E8 57 FE FF FF                call 08584499H ; $$CODE$$+17561
08584642  58                            pop eax

08584643  5F                            pop edi
08584644  5D                            pop ebp

08584645  C3                            ret


Frame allocation (hex):

	0000       : FB washing_timer
	0016 bit  0: VAR onWash
	0017 bit  0: VAR is_running_wash
	0018       : VAR sv_washing_FB
	001C       : VAR o_val_open_R_FB
	0020       : VAR o_val_close_R_FB
	0024       : VAR o_val_open_fall_FB
	0028       : VAR o_val_close_fall_FB
	002C       : VAR q_start_ats_FB
	0030       : VAR ep_time_wash_FB
	0034       : VAR i_val_state_FB

END_FUNCTION_BLOCK
**************************************************
	List program: ATS_mdb
**************************************************

PROGRAM ATS_mdb

        VAR
res_eta_lcr : UINT;
resp_eta_lcr : ARRAY[0..3] OF INT;
res : INT;
xTON : TON;
	END_VAR

END_PROGRAM

08584650  55                            push ebp
08584651  8B EC                         mov ebp, esp
08584653  60                            pushad

#0		{SRC:ATS_mdb}
#1		(*$WAITSWITCH$*)
#2		
#3			(* res := sysMbMRTU_FC03(	addr := 1, 
#4											base := 257, // 256
#5											no := 4, 
#6											object := ADR(resp_eta_lcr), 
#7											timeout := 200); *)
#8			ADR		resp_eta_lcr	{LNXT:2|8|-1}
(*) UDINT
08584654  B8 CC CC CC CC                mov eax, CCCCCCCCH ; $$DATA$$+12

#9			ST		$$TMP0	{LNXT:2|8|-1}
(*) @INT
08584659  89 05 CC CC CC CC             mov [CCCCCCCCH], eax ; $$DATA$$+280

#10			LDP0		1	{LNXT:2|8|-1}
(*) @INT
#11			sysMbMRTU_FC03		257, 4, $$TMP0, 200	{LNXT:2|8|-1}
(*) @INT
0858465F  68 C8 00 00 00                push 200
08584664  FF 35 CC CC CC CC             push [CCCCCCCCH] ; $$DATA$$+280
0858466A  68 04 00 00 00                push 4
0858466F  68 01 01 00 00                push 257
08584674  68 01 00 00 00                push 1
08584679  B9 CC CC CC CC                mov ecx, CCCCCCCCH ; sysMbMRTU_FC03
0858467E  FF D1                         call ecx
08584680  81 C4 14 00 00 00             add esp, 20

#12			ST		res	{LNXT:2|8|-1}
(*) UINT
08584686  66 89 05 CC CC CC CC          mov [CCCCCCCCH], ax ; $$DATA$$+24

#13		
#14			(* ATS22_DUT.Ready 	:= to_bool(resp_eta_lcr[0] And 16#01); *)
#15			LD		resp_eta_lcr[0]	{LNXT:8|9|-1}
(*) UNDEF
0858468D  0F BF 05 CC CC CC CC          movsx eax, word ptr [CCCCCCCCH] ; $$DATA$$+12

#16			AND		16#01	{LNXT:8|9|-1}
(*) INT
08584694  25 01 00 00 00                and eax, 00000001H

#17			to_bool	{LNXT:8|9|-1}
(*) INT
08584699  66 85 C0                      test ax, ax
0858469C  0F 95 C0                      setne al

#18			ST		ATS22_DUT.Ready	{LNXT:8|9|-1}
(*) BOOL
0858469F  84 C0                         test al, al
085846A1  0F 95 05 CC CC CC CC          setne [CCCCCCCCH] ; $$DATA$$+26

#19		
#20			(* ATS22_DUT.On 		:= to_bool(resp_eta_lcr[0] And 16#02); *)
#21			LD		resp_eta_lcr[0]	{LNXT:9|10|-1}
(*) UNDEF
085846A8  0F BF 05 CC CC CC CC          movsx eax, word ptr [CCCCCCCCH] ; $$DATA$$+12

#22			AND		16#02	{LNXT:9|10|-1}
(*) INT
085846AF  25 02 00 00 00                and eax, 00000002H

#23			to_bool	{LNXT:9|10|-1}
(*) INT
085846B4  66 85 C0                      test ax, ax
085846B7  0F 95 C0                      setne al

#24			ST		ATS22_DUT.On	{LNXT:9|10|-1}
(*) BOOL
085846BA  84 C0                         test al, al
085846BC  0F 95 05 CC CC CC CC          setne [CCCCCCCCH] ; $$DATA$$+27

#25		
#26			(* ATS22_DUT.Trip 		:= to_bool(resp_eta_lcr[0] And 16#04); *)
#27			LD		resp_eta_lcr[0]	{LNXT:10|11|-1}
(*) UNDEF
085846C3  0F BF 05 CC CC CC CC          movsx eax, word ptr [CCCCCCCCH] ; $$DATA$$+12

#28			AND		16#04	{LNXT:10|11|-1}
(*) INT
085846CA  25 04 00 00 00                and eax, 00000004H

#29			to_bool	{LNXT:10|11|-1}
(*) INT
085846CF  66 85 C0                      test ax, ax
085846D2  0F 95 C0                      setne al

#30			ST		ATS22_DUT.Trip	{LNXT:10|11|-1}
(*) BOOL
085846D5  84 C0                         test al, al
085846D7  0F 95 05 CC CC CC CC          setne [CCCCCCCCH] ; $$DATA$$+28

#31		
#32			(* ATS22_DUT.Warning 	:= to_bool(resp_eta_lcr[0] And 16#08); *)
#33			LD		resp_eta_lcr[0]	{LNXT:11|12|-1}
(*) UNDEF
085846DE  0F BF 05 CC CC CC CC          movsx eax, word ptr [CCCCCCCCH] ; $$DATA$$+12

#34			AND		16#08	{LNXT:11|12|-1}
(*) INT
085846E5  25 08 00 00 00                and eax, 00000008H

#35			to_bool	{LNXT:11|12|-1}
(*) INT
085846EA  66 85 C0                      test ax, ax
085846ED  0F 95 C0                      setne al

#36			ST		ATS22_DUT.Warning	{LNXT:11|12|-1}
(*) BOOL
085846F0  84 C0                         test al, al
085846F2  0F 95 05 CC CC CC CC          setne [CCCCCCCCH] ; $$DATA$$+29

#37		
#38			(* ATS22_DUT.LI3 		:= to_bool(resp_eta_lcr[0] And 16#20); *)
#39			LD		resp_eta_lcr[0]	{LNXT:12|13|-1}
(*) UNDEF
085846F9  0F BF 05 CC CC CC CC          movsx eax, word ptr [CCCCCCCCH] ; $$DATA$$+12

#40			AND		16#20	{LNXT:12|13|-1}
(*) INT
08584700  25 20 00 00 00                and eax, 00000020H

#41			to_bool	{LNXT:12|13|-1}
(*) INT
08584705  66 85 C0                      test ax, ax
08584708  0F 95 C0                      setne al

#42			ST		ATS22_DUT.LI3	{LNXT:12|13|-1}
(*) BOOL
0858470B  84 C0                         test al, al
0858470D  0F 95 05 CC CC CC CC          setne [CCCCCCCCH] ; $$DATA$$+30

#43		
#44			(* ATS22_DUT.LI2 		:= to_bool(resp_eta_lcr[0] And 16#40); *)
#45			LD		resp_eta_lcr[0]	{LNXT:13|14|-1}
(*) UNDEF
08584714  0F BF 05 CC CC CC CC          movsx eax, word ptr [CCCCCCCCH] ; $$DATA$$+12

#46			AND		16#40	{LNXT:13|14|-1}
(*) INT
0858471B  25 40 00 00 00                and eax, 00000040H

#47			to_bool	{LNXT:13|14|-1}
(*) INT
08584720  66 85 C0                      test ax, ax
08584723  0F 95 C0                      setne al

#48			ST		ATS22_DUT.LI2	{LNXT:13|14|-1}
(*) BOOL
08584726  84 C0                         test al, al
08584728  0F 95 05 CC CC CC CC          setne [CCCCCCCCH] ; $$DATA$$+31

#49		
#50			(* ATS22_DUT.LI1 		:= to_bool(resp_eta_lcr[0] And 16#80); *)
#51			LD		resp_eta_lcr[0]	{LNXT:14|17|-1}
(*) UNDEF
0858472F  0F BF 05 CC CC CC CC          movsx eax, word ptr [CCCCCCCCH] ; $$DATA$$+12

#52			AND		16#80	{LNXT:14|17|-1}
(*) INT
08584736  25 80 00 00 00                and eax, 00000080H

#53			to_bool	{LNXT:14|17|-1}
(*) INT
0858473B  66 85 C0                      test ax, ax
0858473E  0F 95 C0                      setne al

#54			ST		ATS22_DUT.LI1	{LNXT:14|17|-1}
(*) BOOL
08584741  84 C0                         test al, al
08584743  0F 95 05 CC CC CC CC          setne [CCCCCCCCH] ; $$DATA$$+32

#55		
#56			(* ATS_State_bits.0 := ATS22_DUT.Ready; *)
#57			MOVE		ATS22_DUT.Ready,ATS_State_bits.0	{LNXT:17|18|-1}
(*) BOOL
0858474A  33 C0                         xor eax, eax
0858474C  8A 05 CC CC CC CC             mov al, [CCCCCCCCH] ; $$DATA$$+26
08584752  84 C0                         test al, al
08584754  90 75 11 90 90 90             jne 00000014H@
0858475A  66 0F BA 35 CC CC CC CC 00    btr word ptr [CCCCCCCCH], 0 ; %M110+16
08584763  EB 0C 90 90 90                jmp 0000000EH@
08584768  66 0F BA 2D CC CC CC CC 00    bts word ptr [CCCCCCCCH], 0 ; %M110+16

#58		
#59			(* ATS_State_bits.1 := ATS22_DUT.On And i_run_ats; *)
#60			LD		ATS22_DUT.On	{LNXT:18|19|-1}
(*) UNDEF
08584771  33 C0                         xor eax, eax
08584773  8A 05 CC CC CC CC             mov al, [CCCCCCCCH] ; $$DATA$$+27

#61			AND		i_run_ats	{LNXT:18|19|-1}
(*) BOOL
08584779  33 C9                         xor ecx, ecx
0858477B  8A 0D CC CC CC CC             mov cl, [CCCCCCCCH] ; $$DATA$$+284
08584781  23 C1                         and eax, ecx

#62			ST		ATS_State_bits.1	{LNXT:18|19|-1}
(*) BOOL
08584783  84 C0                         test al, al
08584785  90 75 11 90 90 90             jne 00000014H@
0858478B  66 0F BA 35 CC CC CC CC 01    btr word ptr [CCCCCCCCH], 1 ; %M110+16
08584794  EB 0C 90 90 90                jmp 0000000EH@
08584799  66 0F BA 2D CC CC CC CC 01    bts word ptr [CCCCCCCCH], 1 ; %M110+16

#63		
#64			(* ATS_State_bits.2 := ATS22_DUT.Trip Or Not i_no_alm_ats ; *)
#65			LD		i_no_alm_ats	{LNXT:19|20|-1}
(*) UNDEF
085847A2  33 C0                         xor eax, eax
085847A4  8A 05 CC CC CC CC             mov al, [CCCCCCCCH] ; $$DATA$$+285

#66			NOT	{LNXT:19|20|-1}
(*) BOOL
085847AA  84 C0                         test al, al
085847AC  0F 94 C0                      sete al

#67			OR		ATS22_DUT.Trip	{LNXT:19|20|-1}
(*) BOOL
085847AF  33 C9                         xor ecx, ecx
085847B1  8A 0D CC CC CC CC             mov cl, [CCCCCCCCH] ; $$DATA$$+28
085847B7  0B C1                         or eax, ecx

#68			ST		ATS_State_bits.2	{LNXT:19|20|-1}
(*) BOOL
085847B9  84 C0                         test al, al
085847BB  90 75 11 90 90 90             jne 00000014H@
085847C1  66 0F BA 35 CC CC CC CC 02    btr word ptr [CCCCCCCCH], 2 ; %M110+16
085847CA  EB 0C 90 90 90                jmp 0000000EH@
085847CF  66 0F BA 2D CC CC CC CC 02    bts word ptr [CCCCCCCCH], 2 ; %M110+16

#69		
#70			(* ATS_State_bits.3 := ATS22_DUT.Warning; *)
#71			MOVE		ATS22_DUT.Warning,ATS_State_bits.3	{LNXT:20|21|-1}
(*) BOOL
085847D8  33 C0                         xor eax, eax
085847DA  8A 05 CC CC CC CC             mov al, [CCCCCCCCH] ; $$DATA$$+29
085847E0  84 C0                         test al, al
085847E2  90 75 11 90 90 90             jne 00000014H@
085847E8  66 0F BA 35 CC CC CC CC 03    btr word ptr [CCCCCCCCH], 3 ; %M110+16
085847F1  EB 0C 90 90 90                jmp 0000000EH@
085847F6  66 0F BA 2D CC CC CC CC 03    bts word ptr [CCCCCCCCH], 3 ; %M110+16

#72		
#73			(* ATS_State_bits.4 := ATS22_DUT.Local; *)
#74			MOVE		ATS22_DUT.Local,ATS_State_bits.4	{LNXT:21|22|-1}
(*) BOOL
085847FF  33 C0                         xor eax, eax
08584801  8A 05 CC CC CC CC             mov al, [CCCCCCCCH] ; $$DATA$$+34
08584807  84 C0                         test al, al
08584809  90 75 11 90 90 90             jne 00000014H@
0858480F  66 0F BA 35 CC CC CC CC 04    btr word ptr [CCCCCCCCH], 4 ; %M110+16
08584818  EB 0C 90 90 90                jmp 0000000EH@
0858481D  66 0F BA 2D CC CC CC CC 04    bts word ptr [CCCCCCCCH], 4 ; %M110+16

#75		
#76			(* ATS_State_bits.5 := ATS22_DUT.Ramping; *)
#77			MOVE		ATS22_DUT.Ramping,ATS_State_bits.5	{LNXT:22|23|-1}
(*) BOOL
08584826  33 C0                         xor eax, eax
08584828  8A 05 CC CC CC CC             mov al, [CCCCCCCCH] ; $$DATA$$+35
0858482E  84 C0                         test al, al
08584830  90 75 11 90 90 90             jne 00000014H@
08584836  66 0F BA 35 CC CC CC CC 05    btr word ptr [CCCCCCCCH], 5 ; %M110+16
0858483F  EB 0C 90 90 90                jmp 0000000EH@
08584844  66 0F BA 2D CC CC CC CC 05    bts word ptr [CCCCCCCCH], 5 ; %M110+16

#78		
#79			(* ATS_State_bits.6 := ATS22_DUT.LI1; *)
#80			MOVE		ATS22_DUT.LI1,ATS_State_bits.6	{LNXT:23|24|-1}
(*) BOOL
0858484D  33 C0                         xor eax, eax
0858484F  8A 05 CC CC CC CC             mov al, [CCCCCCCCH] ; $$DATA$$+32
08584855  84 C0                         test al, al
08584857  90 75 11 90 90 90             jne 00000014H@
0858485D  66 0F BA 35 CC CC CC CC 06    btr word ptr [CCCCCCCCH], 6 ; %M110+16
08584866  EB 0C 90 90 90                jmp 0000000EH@
0858486B  66 0F BA 2D CC CC CC CC 06    bts word ptr [CCCCCCCCH], 6 ; %M110+16

#81		
#82			(* ATS_State_bits.7 := ATS22_DUT.LI2; *)
#83			MOVE		ATS22_DUT.LI2,ATS_State_bits.7	{LNXT:24|25|-1}
(*) BOOL
08584874  33 C0                         xor eax, eax
08584876  8A 05 CC CC CC CC             mov al, [CCCCCCCCH] ; $$DATA$$+31
0858487C  84 C0                         test al, al
0858487E  90 75 11 90 90 90             jne 00000014H@
08584884  66 0F BA 35 CC CC CC CC 07    btr word ptr [CCCCCCCCH], 7 ; %M110+16
0858488D  EB 0C 90 90 90                jmp 0000000EH@
08584892  66 0F BA 2D CC CC CC CC 07    bts word ptr [CCCCCCCCH], 7 ; %M110+16

#84		
#85			(* ATS_State_bits.8 := ATS22_DUT.LI3; *)
#86			MOVE		ATS22_DUT.LI3,ATS_State_bits.8	{LNXT:25|28|-1}
(*) BOOL
0858489B  33 C0                         xor eax, eax
0858489D  8A 05 CC CC CC CC             mov al, [CCCCCCCCH] ; $$DATA$$+30
085848A3  84 C0                         test al, al
085848A5  90 75 11 90 90 90             jne 00000014H@
085848AB  66 0F BA 35 CC CC CC CC 08    btr word ptr [CCCCCCCCH], 8 ; %M110+16
085848B4  EB 0C 90 90 90                jmp 0000000EH@
085848B9  66 0F BA 2D CC CC CC CC 08    bts word ptr [CCCCCCCCH], 8 ; %M110+16

#87		
#88			(* ATS_State_bits.9 := i_pb_loc; *)
#89			MOVE		i_pb_loc,ATS_State_bits.9	{LNXT:28|29|-1}
(*) BOOL
085848C2  0F BF 05 CC CC CC CC          movsx eax, word ptr [CCCCCCCCH] ; $$DATA$$+286
085848C9  66 85 C0                      test ax, ax
085848CC  90 75 11 90 90 90             jne 00000014H@
085848D2  66 0F BA 35 CC CC CC CC 09    btr word ptr [CCCCCCCCH], 9 ; %M110+16
085848DB  EB 0C 90 90 90                jmp 0000000EH@
085848E0  66 0F BA 2D CC CC CC CC 09    bts word ptr [CCCCCCCCH], 9 ; %M110+16

#90		
#91			(* ATS_State_bits.10 := i_pb_rem; *)
#92			MOVE		i_pb_rem,ATS_State_bits.10	{LNXT:29|31|-1}
(*) INT
085848E9  0F BF 05 CC CC CC CC          movsx eax, word ptr [CCCCCCCCH] ; $$DATA$$+288
085848F0  66 85 C0                      test ax, ax
085848F3  90 75 11 90 90 90             jne 00000014H@
085848F9  66 0F BA 35 CC CC CC CC 0A    btr word ptr [CCCCCCCCH], 10 ; %M110+16
08584902  EB 0C 90 90 90                jmp 0000000EH@
08584907  66 0F BA 2D CC CC CC CC 0A    bts word ptr [CCCCCCCCH], 10 ; %M110+16

#93		
#94		
#95			(* IF i_pb_loc AND not i_pb_rem *)
#96			LD		i_pb_rem	{LNXT:31|-1|-1}
(*) UNDEF
08584910  0F BF 05 CC CC CC CC          movsx eax, word ptr [CCCCCCCCH] ; $$DATA$$+288

#97			NOT	{LNXT:31|-1|-1}
(*) INT
08584917  66 F7 D0                      not ax

#98			AND(		i_pb_loc	{LNXT:31|-1|-1}
(*) INT
0858491A  50                            push eax
0858491B  0F BF 05 CC CC CC CC          movsx eax, word ptr [CCCCCCCCH] ; $$DATA$$+286

#99			NOT	{LNXT:31|-1|-1}
(*) INT
08584922  66 F7 D0                      not ax

#100			)	{LNXT:31|-1|-1}
(*) INT
08584925  8B C8                         mov ecx, eax
08584927  58                            pop eax
08584928  23 C1                         and eax, ecx

#101			JMPCN	$label0	{LNXT:31|32|34}
(-) INT
0858492A  66 85 C0                      test ax, ax
0858492D  90 74 27 90 90 90             je 08584957H

#102		
#103			(* THEN *)
#104		
#105				(* ATS_State_bits.11 := TRUE; *)
#106				MOVE		TRUE,ATS_State_bits.11	{LNXT:32|34|-1}
(*) INT
08584933  B8 01 00 00 00                mov eax, 01H
08584938  84 C0                         test al, al
0858493A  90 75 11 90 90 90             jne 00000014H@
08584940  66 0F BA 35 CC CC CC CC 0B    btr word ptr [CCCCCCCCH], 11 ; %M110+16
08584949  EB 0C 90 90 90                jmp 0000000EH@
0858494E  66 0F BA 2D CC CC CC CC 0B    bts word ptr [CCCCCCCCH], 11 ; %M110+16

#107		
#108		$label0:
#109			(* END_IF *)
#110		
#111		
#112			(* IF i_pb_loc AND i_pb_rem *)
#113			LD		i_pb_loc	{LNXT:34|-1|-1}
(*) UNDEF
08584957  0F BF 05 CC CC CC CC          movsx eax, word ptr [CCCCCCCCH] ; $$DATA$$+286

#114			NOT	{LNXT:34|-1|-1}
(*) INT
0858495E  66 F7 D0                      not ax

#115			AND		i_pb_rem	{LNXT:34|-1|-1}
(*) INT
08584961  0F BF 0D CC CC CC CC          movsx ecx, word ptr [CCCCCCCCH] ; $$DATA$$+288
08584968  23 C1                         and eax, ecx

#116			JMPCN	$label1	{LNXT:34|35|37}
(-) INT
0858496A  66 85 C0                      test ax, ax
0858496D  90 74 27 90 90 90             je 08584997H

#117		
#118			(* THEN *)
#119		
#120				(* ATS_State_bits.11 := FALSE; *)
#121				MOVE		FALSE,ATS_State_bits.11	{LNXT:35|37|-1}
(*) INT
08584973  B8 00 00 00 00                mov eax, 00H
08584978  84 C0                         test al, al
0858497A  90 75 11 90 90 90             jne 00000014H@
08584980  66 0F BA 35 CC CC CC CC 0B    btr word ptr [CCCCCCCCH], 11 ; %M110+16
08584989  EB 0C 90 90 90                jmp 0000000EH@
0858498E  66 0F BA 2D CC CC CC CC 0B    bts word ptr [CCCCCCCCH], 11 ; %M110+16

#122		
#123		$label1:
#124			(* END_IF *)
#125		
#126		
#127			(* IF i_pb_loc AND not i_pb_rem *)
#128			LD		i_pb_rem	{LNXT:37|-1|-1}
(*) UNDEF
08584997  0F BF 05 CC CC CC CC          movsx eax, word ptr [CCCCCCCCH] ; $$DATA$$+288

#129			NOT	{LNXT:37|-1|-1}
(*) INT
0858499E  66 F7 D0                      not ax

#130			AND		i_pb_loc	{LNXT:37|-1|-1}
(*) INT
085849A1  0F BF 0D CC CC CC CC          movsx ecx, word ptr [CCCCCCCCH] ; $$DATA$$+286
085849A8  23 C1                         and eax, ecx

#131			JMPCN	$label2	{LNXT:37|38|43}
(-) INT
085849AA  66 85 C0                      test ax, ax
085849AD  90 74 27 90 90 90             je 085849D7H

#132		
#133			(* THEN *)
#134		
#135				(* ATS_State_bits.11 := FALSE; *)
#136				MOVE		FALSE,ATS_State_bits.11	{LNXT:38|43|-1}
(*) INT
085849B3  B8 00 00 00 00                mov eax, 00H
085849B8  84 C0                         test al, al
085849BA  90 75 11 90 90 90             jne 00000014H@
085849C0  66 0F BA 35 CC CC CC CC 0B    btr word ptr [CCCCCCCCH], 11 ; %M110+16
085849C9  EB 0C 90 90 90                jmp 0000000EH@
085849CE  66 0F BA 2D CC CC CC CC 0B    bts word ptr [CCCCCCCCH], 11 ; %M110+16

#137		
#138		$label2:
#139			(* END_IF *)
#140		
#141			(* ATS22_DUT.EtaCurrent := to_byte(SHR(resp_eta_lcr[0] AND 16#3F00, 16#08) * 200 / 63); *)
#142			LD		resp_eta_lcr[0]	{LNXT:43|44|-1}
(*) UNDEF
085849D7  0F BF 05 CC CC CC CC          movsx eax, word ptr [CCCCCCCCH] ; $$DATA$$+12

#143			AND		16#3F00	{LNXT:43|44|-1}
(*) INT
085849DE  25 00 3F 00 00                and eax, 00003F00H

#144			SHR		16#08	{LNXT:43|44|-1}
(*) INT
085849E3  C1 E8 08                      shr eax, 8

#145			MUL		200	{LNXT:43|44|-1}
(*) DINT
085849E6  B9 C8 00 00 00                mov ecx, 200
085849EB  F7 E9                         imul ecx

#146			DIV		63	{LNXT:43|44|-1}
(*) DINT
085849ED  99                            cdq
085849EE  B9 3F 00 00 00                mov ecx, 63
085849F3  F7 F9                         idiv ecx

#147			to_byte	{LNXT:43|44|-1}
(*) DINT
#148			ST		ATS22_DUT.EtaCurrent	{LNXT:43|44|-1}
(*) BYTE
085849F5  88 05 CC CC CC CC             mov [CCCCCCCCH], al ; $$DATA$$+33

#149		
#150			(* ATS_Current_prsnt	 := ATS22_DUT.EtaCurrent; *)
#151			MOVE		ATS22_DUT.EtaCurrent,ATS_Current_prsnt	{LNXT:44|46|-1}
(*) BYTE
085849FB  33 C0                         xor eax, eax
085849FD  8A 05 CC CC CC CC             mov al, [CCCCCCCCH] ; $$DATA$$+33
08584A03  66 89 05 CC CC CC CC          mov [CCCCCCCCH], ax ; %M110+18

#152		
#153			(* ATS22_DUT.Local 	:= to_bool(resp_eta_lcr[0] And 16#4000); *)
#154			LD		resp_eta_lcr[0]	{LNXT:46|47|-1}
(*) UNDEF
08584A0A  0F BF 05 CC CC CC CC          movsx eax, word ptr [CCCCCCCCH] ; $$DATA$$+12

#155			AND		16#4000	{LNXT:46|47|-1}
(*) INT
08584A11  25 00 40 00 00                and eax, 00004000H

#156			to_bool	{LNXT:46|47|-1}
(*) INT
08584A16  66 85 C0                      test ax, ax
08584A19  0F 95 C0                      setne al

#157			ST		ATS22_DUT.Local	{LNXT:46|47|-1}
(*) BOOL
08584A1C  84 C0                         test al, al
08584A1E  0F 95 05 CC CC CC CC          setne [CCCCCCCCH] ; $$DATA$$+34

#158		
#159			(* ATS22_DUT.Ramping 	:= to_bool(resp_eta_lcr[0] And 16#8000); *)
#160			LD		resp_eta_lcr[0]	{LNXT:47|49|-1}
(*) UNDEF
08584A25  0F BF 05 CC CC CC CC          movsx eax, word ptr [CCCCCCCCH] ; $$DATA$$+12

#161			AND		16#8000	{LNXT:47|49|-1}
(*) INT
08584A2C  25 00 80 00 00                and eax, 00008000H

#162			to_bool	{LNXT:47|49|-1}
(*) INT
08584A31  66 85 C0                      test ax, ax
08584A34  0F 95 C0                      setne al

#163			ST		ATS22_DUT.Ramping	{LNXT:47|49|-1}
(*) BOOL
08584A37  84 C0                         test al, al
08584A39  0F 95 05 CC CC CC CC          setne [CCCCCCCCH] ; $$DATA$$+35

#164		
#165			(* ATS22_DUT.Lcr1 := resp_eta_lcr[1]; *)
#166			MOVE		resp_eta_lcr[1],ATS22_DUT.Lcr1	{LNXT:49|50|-1}
(*) BOOL
08584A40  0F BF 05 CC CC CC CC          movsx eax, word ptr [CCCCCCCCH] ; $$DATA$$+14
08584A47  66 89 05 CC CC CC CC          mov [CCCCCCCCH], ax ; $$DATA$$+36

#167		
#168			(* ATS22_DUT.Lcr2 := resp_eta_lcr[2]; *)
#169			MOVE		resp_eta_lcr[2],ATS22_DUT.Lcr2	{LNXT:50|51|-1}
(*) INT
08584A4E  0F BF 05 CC CC CC CC          movsx eax, word ptr [CCCCCCCCH] ; $$DATA$$+16
08584A55  66 89 05 CC CC CC CC          mov [CCCCCCCCH], ax ; $$DATA$$+38

#170		
#171			(* ATS22_DUT.Lcr3 := resp_eta_lcr[3]; *)
#172			MOVE		resp_eta_lcr[3],ATS22_DUT.Lcr3	{LNXT:51|53|-1}
(*) INT
08584A5C  0F BF 05 CC CC CC CC          movsx eax, word ptr [CCCCCCCCH] ; $$DATA$$+18
08584A63  66 89 05 CC CC CC CC          mov [CCCCCCCCH], ax ; $$DATA$$+40

#173		
#174			(* ATS_Current_L1 := ATS22_DUT.Lcr1; *)
#175			MOVE		ATS22_DUT.Lcr1,ATS_Current_L1	{LNXT:53|54|-1}
(*) INT
08584A6A  0F BF 05 CC CC CC CC          movsx eax, word ptr [CCCCCCCCH] ; $$DATA$$+36
08584A71  66 89 05 CC CC CC CC          mov [CCCCCCCCH], ax ; %M110+20

#176		
#177			(* ATS_Current_L2 := ATS22_DUT.Lcr2; *)
#178			MOVE		ATS22_DUT.Lcr2,ATS_Current_L2	{LNXT:54|55|-1}
(*) INT
08584A78  0F BF 05 CC CC CC CC          movsx eax, word ptr [CCCCCCCCH] ; $$DATA$$+38
08584A7F  66 89 05 CC CC CC CC          mov [CCCCCCCCH], ax ; %M110+22

#179		
#180			(* ATS_Current_L3 := ATS22_DUT.Lcr3; *)
#181			MOVE		ATS22_DUT.Lcr3,ATS_Current_L3	{LNXT:55|57|-1}
(*) INT
08584A86  0F BF 05 CC CC CC CC          movsx eax, word ptr [CCCCCCCCH] ; $$DATA$$+40
08584A8D  66 89 05 CC CC CC CC          mov [CCCCCCCCH], ax ; %M110+24

#182		
#183			(* res := sysMbMRTU_FC03(	addr := 1, 
#184											base := 261, // 260
#185											no := 1, 
#186											object := ADR(resp_eta_lcr), 
#187											timeout := 200); *)
#188			ADR		resp_eta_lcr	{LNXT:57|63|-1}
(*) INT
08584A94  B8 CC CC CC CC                mov eax, CCCCCCCCH ; $$DATA$$+12

#189			ST		$$TMP0	{LNXT:57|63|-1}
(*) @INT
08584A99  89 05 CC CC CC CC             mov [CCCCCCCCH], eax ; $$DATA$$+280

#190			LDP0		1	{LNXT:57|63|-1}
(*) @INT
#191			sysMbMRTU_FC03		261, 1, $$TMP0, 200	{LNXT:57|63|-1}
(*) @INT
08584A9F  68 C8 00 00 00                push 200
08584AA4  FF 35 CC CC CC CC             push [CCCCCCCCH] ; $$DATA$$+280
08584AAA  68 01 00 00 00                push 1
08584AAF  68 05 01 00 00                push 261
08584AB4  68 01 00 00 00                push 1
08584AB9  B9 CC CC CC CC                mov ecx, CCCCCCCCH ; sysMbMRTU_FC03
08584ABE  FF D1                         call ecx
08584AC0  81 C4 14 00 00 00             add esp, 20

#192			ST		res	{LNXT:57|63|-1}
(*) UINT
08584AC6  66 89 05 CC CC CC CC          mov [CCCCCCCCH], ax ; $$DATA$$+24

#193		
#194			(* ATS22_DUT.LcrVoltage	:= resp_eta_lcr[0]; *)
#195			MOVE		resp_eta_lcr[0],ATS22_DUT.LcrVoltage	{LNXT:63|64|-1}
(*) UINT
08584ACD  0F BF 05 CC CC CC CC          movsx eax, word ptr [CCCCCCCCH] ; $$DATA$$+12
08584AD4  66 89 05 CC CC CC CC          mov [CCCCCCCCH], ax ; $$DATA$$+42

#196		
#197			(* ATS_Voltage := ATS22_DUT.LcrVoltage; *)
#198			MOVE		ATS22_DUT.LcrVoltage,ATS_Voltage	{LNXT:64|68|-1}
(*) INT
08584ADB  0F BF 05 CC CC CC CC          movsx eax, word ptr [CCCCCCCCH] ; $$DATA$$+42
08584AE2  66 89 05 CC CC CC CC          mov [CCCCCCCCH], ax ; %M110+36

#199		
#200			(* res := sysMbMRTU_FC03(	addr := 1, 
#201											base := 280, // 279
#202											no := 1, 
#203											object := ADR(resp_eta_lcr), 
#204											timeout := 200); *)
#205			ADR		resp_eta_lcr	{LNXT:68|74|-1}
(*) INT
08584AE9  B8 CC CC CC CC                mov eax, CCCCCCCCH ; $$DATA$$+12

#206			ST		$$TMP0	{LNXT:68|74|-1}
(*) @INT
08584AEE  89 05 CC CC CC CC             mov [CCCCCCCCH], eax ; $$DATA$$+280

#207			LDP0		1	{LNXT:68|74|-1}
(*) @INT
#208			sysMbMRTU_FC03		280, 1, $$TMP0, 200	{LNXT:68|74|-1}
(*) @INT
08584AF4  68 C8 00 00 00                push 200
08584AF9  FF 35 CC CC CC CC             push [CCCCCCCCH] ; $$DATA$$+280
08584AFF  68 01 00 00 00                push 1
08584B04  68 18 01 00 00                push 280
08584B09  68 01 00 00 00                push 1
08584B0E  B9 CC CC CC CC                mov ecx, CCCCCCCCH ; sysMbMRTU_FC03
08584B13  FF D1                         call ecx
08584B15  81 C4 14 00 00 00             add esp, 20

#209			ST		res	{LNXT:68|74|-1}
(*) UINT
08584B1B  66 89 05 CC CC CC CC          mov [CCCCCCCCH], ax ; $$DATA$$+24

#210		
#211			(* ATS22_DUT.LastFLT 	:= resp_eta_lcr[0]; *)
#212			MOVE		resp_eta_lcr[0],ATS22_DUT.LastFLT	{LNXT:74|75|-1}
(*) UINT
08584B22  0F BF 05 CC CC CC CC          movsx eax, word ptr [CCCCCCCCH] ; $$DATA$$+12
08584B29  66 89 05 CC CC CC CC          mov [CCCCCCCCH], ax ; $$DATA$$+44

#213		
#214			(* ATS_Last_FaultCode := ATS22_DUT.LastFLT; *)
#215			MOVE		ATS22_DUT.LastFLT,ATS_Last_FaultCode	{LNXT:75|78|-1}
(*) INT
08584B30  0F BF 05 CC CC CC CC          movsx eax, word ptr [CCCCCCCCH] ; $$DATA$$+44
08584B37  66 89 05 CC CC CC CC          mov [CCCCCCCCH], ax ; %M110+26

#216		
#217			(* res := sysMbMRTU_FC03(	addr := 1, 
#218											base := 274, // 273
#219											no := 3, 
#220											object := ADR(resp_eta_lcr), 
#221											timeout := 200); *)
#222			ADR		resp_eta_lcr	{LNXT:78|84|-1}
(*) INT
08584B3E  B8 CC CC CC CC                mov eax, CCCCCCCCH ; $$DATA$$+12

#223			ST		$$TMP0	{LNXT:78|84|-1}
(*) @INT
08584B43  89 05 CC CC CC CC             mov [CCCCCCCCH], eax ; $$DATA$$+280

#224			LDP0		1	{LNXT:78|84|-1}
(*) @INT
#225			sysMbMRTU_FC03		274, 3, $$TMP0, 200	{LNXT:78|84|-1}
(*) @INT
08584B49  68 C8 00 00 00                push 200
08584B4E  FF 35 CC CC CC CC             push [CCCCCCCCH] ; $$DATA$$+280
08584B54  68 03 00 00 00                push 3
08584B59  68 12 01 00 00                push 274
08584B5E  68 01 00 00 00                push 1
08584B63  B9 CC CC CC CC                mov ecx, CCCCCCCCH ; sysMbMRTU_FC03
08584B68  FF D1                         call ecx
08584B6A  81 C4 14 00 00 00             add esp, 20

#226			ST		res	{LNXT:78|84|-1}
(*) UINT
08584B70  66 89 05 CC CC CC CC          mov [CCCCCCCCH], ax ; $$DATA$$+24

#227		
#228		
#229			(* IF res <> 0 *)
#230			LD		res	{LNXT:84|-1|-1}
(*) UNDEF
08584B77  0F BF 05 CC CC CC CC          movsx eax, word ptr [CCCCCCCCH] ; $$DATA$$+24

#231			NE		0	{LNXT:84|-1|-1}
(*) INT
08584B7E  3D 00 00 00 00                cmp eax, 0
08584B83  0F 95 C0                      setne al
08584B86  25 FF 00 00 00                and eax, 0FFh

#232			JMPCN	$label3	{LNXT:84|84|86}
(-) BOOL
08584B8B  84 C0                         test al, al
08584B8D  90 74 27 90 90 90             je 08584BB7H

#233		
#234			(* THEN *)
#235		
#236				(* Alarms.6 := true; *)
#237				MOVE		true,Alarms.6	{LNXT:84|86|-1}
(*) BOOL
08584B93  B8 01 00 00 00                mov eax, 01H
08584B98  84 C0                         test al, al
08584B9A  90 75 11 90 90 90             jne 00000014H@
08584BA0  66 0F BA 35 CC CC CC CC 06    btr word ptr [CCCCCCCCH], 6 ; %M110+32
08584BA9  EB 0C 90 90 90                jmp 0000000EH@
08584BAE  66 0F BA 2D CC CC CC CC 06    bts word ptr [CCCCCCCCH], 6 ; %M110+32

#238		
#239		$label3:
#240			(* END_IF *)
#241		
#242			(* ATS22_DUT.MotRunTime 		:= resp_eta_lcr[0]; *)
#243			MOVE		resp_eta_lcr[0],ATS22_DUT.MotRunTime	{LNXT:86|87|-1}
(*) WORD
08584BB7  0F BF 05 CC CC CC CC          movsx eax, word ptr [CCCCCCCCH] ; $$DATA$$+12
08584BBE  66 89 05 CC CC CC CC          mov [CCCCCCCCH], ax ; $$DATA$$+46

#244		
#245			(* ATS22_DUT.MotStartCnt 		:= resp_eta_lcr[1]; *)
#246			MOVE		resp_eta_lcr[1],ATS22_DUT.MotStartCnt	{LNXT:87|88|-1}
(*) INT
08584BC5  0F BF 05 CC CC CC CC          movsx eax, word ptr [CCCCCCCCH] ; $$DATA$$+14
08584BCC  66 89 05 CC CC CC CC          mov [CCCCCCCCH], ax ; $$DATA$$+48

#247		
#248			(* ATS22_DUT.MotLastStartTime 	:= resp_eta_lcr[2]; *)
#249			MOVE		resp_eta_lcr[2],ATS22_DUT.MotLastStartTime	{LNXT:88|90|-1}
(*) INT
08584BD3  0F BF 05 CC CC CC CC          movsx eax, word ptr [CCCCCCCCH] ; $$DATA$$+16
08584BDA  66 89 05 CC CC CC CC          mov [CCCCCCCCH], ax ; $$DATA$$+50

#250		
#251			(* ATS_RunTime_Hors	:= to_word(ATS22_DUT.MotRunTime); *)
#252			LDP0		ATS22_DUT.MotRunTime	{LNXT:90|91|-1}
(*) INT
#253			to_word	{LNXT:90|91|-1}
(*) INT
08584BE1  0F BF 05 CC CC CC CC          movsx eax, word ptr [CCCCCCCCH] ; $$DATA$$+46

#254			ST		ATS_RunTime_Hors	{LNXT:90|91|-1}
(*) WORD
08584BE8  66 89 05 CC CC CC CC          mov [CCCCCCCCH], ax ; %M110+28

#255		
#256			(* ATS_OnTimes_Cnt		:= to_word(ATS22_DUT.MotStartCnt); *)
#257			LDP0		ATS22_DUT.MotStartCnt	{LNXT:91|2|-1}
(*) WORD
#258			to_word	{LNXT:91|2|-1}
(*) WORD
08584BEF  0F BF 05 CC CC CC CC          movsx eax, word ptr [CCCCCCCCH] ; $$DATA$$+48

#259			ST		ATS_OnTimes_Cnt	{LNXT:91|2|-1}
(*) WORD
08584BF6  66 89 05 CC CC CC CC          mov [CCCCCCCCH], ax ; %M110+30

08584BFD  61                            popad
08584BFE  5D                            pop ebp

08584BFF  C3                            ret

END_PROGRAM


**************************************************
	Target variable image generation
**************************************************


*** INPUT:
08584C00  55                            push ebp
08584C01  8B EC                         mov ebp, esp

08584C03  8A 0D CC CC CC CC             mov cl, [CCCCCCCCH] ; %I0+7
08584C09  88 0D CC CC CC CC             mov [CCCCCCCCH], cl ; $$DATA$$+284

08584C0F  8A 0D CC CC CC CC             mov cl, [CCCCCCCCH] ; %I0+6
08584C15  88 0D CC CC CC CC             mov [CCCCCCCCH], cl ; $$DATA$$+285

08584C1B  66 8B 0D CC CC CC CC          mov cx, [CCCCCCCCH] ; %I1+12
08584C22  66 89 0D CC CC CC CC          mov [CCCCCCCCH], cx ; $$DATA$$+286

08584C29  66 8B 0D CC CC CC CC          mov cx, [CCCCCCCCH] ; %I1+14
08584C30  66 89 0D CC CC CC CC          mov [CCCCCCCCH], cx ; $$DATA$$+288

08584C37  8B E5                         mov esp, ebp
08584C39  5D                            pop ebp

08584C3A  C3                            ret


*** OUTPUT:
08584C3B  55                            push ebp
08584C3C  8B EC                         mov ebp, esp

08584C3E  8B E5                         mov esp, ebp
08584C40  5D                            pop ebp

08584C41  C3                            ret



**************************************************
	Task Background init code
**************************************************

08584C42  55                            push ebp
08584C43  8B EC                         mov ebp, esp

08584C45  8B E5                         mov esp, ebp
08584C47  5D                            pop ebp

08584C48  C3                            ret

**************************************************
	List program: sr_init_counters
**************************************************

PROGRAM sr_init_counters

END_PROGRAM

08584C60  55                            push ebp
08584C61  8B EC                         mov ebp, esp
08584C63  60                            pushad

#0		{SRC:sr_init_counters}
#1		(*$WAITSWITCH$*)
#2		
#3			(* kw_counter 	:= epprom_kw_cnt; *)
#4			MOVE		epprom_kw_cnt,kw_counter	{LNXT:1|2|-1}
(*) UDINT
08584C64  8B 05 CC CC CC CC             mov eax, [CCCCCCCCH] ; %M101+8
08584C6A  89 05 CC CC CC CC             mov [CCCCCCCCH], eax ; %M110+4

#5		
#6			(* q_counter	:= epprom_q_cnt; *)
#7			MOVE		epprom_q_cnt,q_counter	{LNXT:2|1|-1}
(*) DWORD
08584C70  8B 05 CC CC CC CC             mov eax, [CCCCCCCCH] ; %M101+0
08584C76  89 05 CC CC CC CC             mov [CCCCCCCCH], eax ; %M110+8

08584C7C  61                            popad
08584C7D  5D                            pop ebp

08584C7E  C3                            ret

END_PROGRAM


**************************************************
	Target variable image generation
**************************************************


*** INPUT:
08584C7F  C3                            ret


*** OUTPUT:
08584C80  C3                            ret



**************************************************
	Task Boot init code
**************************************************

08584C81  55                            push ebp
08584C82  8B EC                         mov ebp, esp

08584C84  8B E5                         mov esp, ebp
08584C86  5D                            pop ebp

08584C87  C3                            ret

**************************************************
	List program: init_val
**************************************************

PROGRAM init_val

END_PROGRAM

08584CA0  55                            push ebp
08584CA1  8B EC                         mov ebp, esp
08584CA3  60                            pushad

#0		{SRC:init_val}
#1		(*$WAITSWITCH$*)
#2		
#3		
#4			(* IF di_val_close_state_R *)
#5			LD		di_val_close_state_R	{LNXT:1|-1|-1}
(*) UNDEF
08584CA4  33 C0                         xor eax, eax
08584CA6  8A 05 CC CC CC CC             mov al, [CCCCCCCCH] ; %I0+0

#6			NOT	{LNXT:1|-1|-1}
(*) BOOL
08584CAC  84 C0                         test al, al
08584CAE  0F 94 C0                      sete al

#7			JMPCN	$label0	{LNXT:1|2|6}
(-) BOOL
08584CB1  84 C0                         test al, al
08584CB3  90 74 1F 90 90 90             je 08584CD5H

#8		
#9			(* THEN *)
#10		
#11				(* o_val_close_R:=true; *)
#12				MOVE		true,o_val_close_R	{LNXT:2|3|-1}
(*) BOOL
08584CB9  B8 01 00 00 00                mov eax, 01H
08584CBE  84 C0                         test al, al
08584CC0  0F 95 05 CC CC CC CC          setne [CCCCCCCCH] ; %Q1+3

#13		
#14				(* o_val_open_R:=false; *)
#15				MOVE		false,o_val_open_R	{LNXT:3|6|-1}
(*) BOOL
08584CC7  B8 00 00 00 00                mov eax, 00H
08584CCC  84 C0                         test al, al
08584CCE  0F 95 05 CC CC CC CC          setne [CCCCCCCCH] ; %Q1+2

#16		
#17		$label0:
#18			(* END_IF *)
#19		
#20		
#21			(* IF di_val_close_state_fall = 0 *)
#22			LD		di_val_close_state_fall	{LNXT:6|-1|-1}
(*) UNDEF
08584CD5  0F BF 05 CC CC CC CC          movsx eax, word ptr [CCCCCCCCH] ; %I1+8

#23			EQ		0	{LNXT:6|-1|-1}
(*) INT
08584CDC  3D 00 00 00 00                cmp eax, 0
08584CE1  0F 94 C0                      sete al
08584CE4  25 FF 00 00 00                and eax, 0FFh

#24			JMPCN	$label1	{LNXT:6|7|1}
(-) BOOL
08584CE9  84 C0                         test al, al
08584CEB  90 74 1F 90 90 90             je 08584D0DH

#25		
#26			(* THEN *)
#27		
#28				(* o_val_close_fall:=true; *)
#29				MOVE		true,o_val_close_fall	{LNXT:7|8|-1}
(*) BOOL
08584CF1  B8 01 00 00 00                mov eax, 01H
08584CF6  84 C0                         test al, al
08584CF8  0F 95 05 CC CC CC CC          setne [CCCCCCCCH] ; %Q1+1

#30		
#31				(* o_val_open_fall:=false; *)
#32				MOVE		false,o_val_open_fall	{LNXT:8|1|-1}
(*) BOOL
08584CFF  B8 00 00 00 00                mov eax, 00H
08584D04  84 C0                         test al, al
08584D06  0F 95 05 CC CC CC CC          setne [CCCCCCCCH] ; %Q1+0

08584D0D  61                            popad
08584D0E  5D                            pop ebp

08584D0F  C3                            ret

END_PROGRAM


**************************************************
	Target variable image generation
**************************************************


*** INPUT:
08584D10  C3                            ret


*** OUTPUT:
08584D11  C3                            ret



**************************************************
	Task Init init code
**************************************************

08584D12  55                            push ebp
08584D13  8B EC                         mov ebp, esp

08584D15  8B E5                         mov esp, ebp
08584D17  5D                            pop ebp

08584D18  C3                            ret

**************************************************
	List program: InitParDB
**************************************************

PROGRAM InitParDB

        VAR
warningsKiller : USINT;
dummyCrc32 : UDINT;
	END_VAR

END_PROGRAM

08584D30  55                            push ebp
08584D31  8B EC                         mov ebp, esp
08584D33  60                            pushad

#0		{SRC:InitParDB}
#1		(*$WAITSWITCH$*)
#2		
#3			(* dummyCrc32 := 3303890192; *)
#4			MOVE		3303890192,dummyCrc32	{LNXT:3|5|-1}
(*) UDINT
08584D34  B8 10 5D ED C4                mov eax, C4ED5D10H
08584D39  89 05 CC CC CC CC             mov [CCCCCCCCH], eax ; $$DATA$$+60

#5		
#6			(* warningsKiller := sysDBase_SetExtTable( ADR( $$ParDB ), $$ParDBLength ); *)
#7			ADR		$$ParDB	{LNXT:5|3|-1}
(*) UDINT
08584D3F  B8 CC CC CC CC                mov eax, CCCCCCCCH ; $$CODE$$+336

#8			sysDBase_SetExtTable		$$ParDBLength	{LNXT:5|3|-1}
(*) @USINT
08584D44  68 15 00 00 00                push 21
08584D49  8B C8                         mov ecx, eax
08584D4B  51                            push ecx
08584D4C  B9 CC CC CC CC                mov ecx, CCCCCCCCH ; sysDBase_SetExtTable
08584D51  FF D1                         call ecx
08584D53  81 C4 08 00 00 00             add esp, 8

#9			ST		warningsKiller	{LNXT:5|3|-1}
(*) USINT
08584D59  88 05 CC CC CC CC             mov [CCCCCCCCH], al ; $$DATA$$+59

08584D5F  61                            popad
08584D60  5D                            pop ebp

08584D61  C3                            ret

END_PROGRAM


**************************************************
	Target variable image generation
**************************************************


*** INPUT:
08584D62  C3                            ret


*** OUTPUT:
08584D63  C3                            ret



**************************************************
	Task Serv init code
**************************************************

08584D64  55                            push ebp
08584D65  8B EC                         mov ebp, esp

08584D67  8B E5                         mov esp, ebp
08584D69  5D                            pop ebp

08584D6A  C3                            ret

**************************************************
	List program: sr_pressure
**************************************************

PROGRAM sr_pressure

        VAR
tmp_test : INT;
	END_VAR

END_PROGRAM

08584D80  55                            push ebp
08584D81  8B EC                         mov ebp, esp
08584D83  60                            pushad

#0		{SRC:sr_pressure}
#1		(*$WAITSWITCH$*)
#2		
#3			(* Pressure := to_int(to_real(i_adc_pressure )/10); *)
#4			LDP0		i_adc_pressure	{LNXT:2|2|-1}
(*) UDINT
#5			to_real	{LNXT:2|2|-1}
(*) UDINT
08584D84  0F BF 05 CC CC CC CC          movsx eax, word ptr [CCCCCCCCH] ; $$DATA$$+298
08584D8B  50                            push eax
08584D8C  DB 04 24                      fild dword ptr [esp]
08584D8F  58                            pop eax

#6			DIV		10	{LNXT:2|2|-1}
(*) REAL
08584D90  68 0A 00 00 00                push 10
08584D95  DA 34 24                      fidiv [esp]
08584D98  81 C4 04 00 00 00             add esp, 4

#7			to_int	{LNXT:2|2|-1}
(*) REAL
08584D9E  81 EC 08 00 00 00             sub esp, 8
08584DA4  DF 3C 24                      fistp qword ptr [esp]
08584DA7  58                            pop eax
08584DA8  81 C4 04 00 00 00             add esp, 4

#8			ST		Pressure	{LNXT:2|2|-1}
(*) INT
08584DAE  66 89 05 CC CC CC CC          mov [CCCCCCCCH], ax ; %M110+0

END_PROGRAM
**************************************************
	List program: sr_counters
**************************************************

PROGRAM sr_counters

        VAR
kw_trig : R_TRIG;
q_trig : R_TRIG;
kw_pulses_per_acs : UINT;
q_pulses_per_acs : UINT;
test_freq : UDINT;
	END_VAR

END_PROGRAM

#0		{SRC:sr_counters}
#1		(*$WAITSWITCH$*)
#2		
#3			(* kw_pulses_per_acs 	:= 8000; *)
#4			MOVE		8000,kw_pulses_per_acs	{LNXT:2|3|-1}
(*) UDINT
08584DB5  B8 40 1F 00 00                mov eax, 1F40H
08584DBA  66 89 05 CC CC CC CC          mov [CCCCCCCCH], ax ; $$DATA$$+138

#5		
#6			(* q_pulses_per_acs	:= 1; *)
#7			MOVE		1,q_pulses_per_acs	{LNXT:3|15|-1}
(*) UINT
08584DC1  B8 01 00 00 00                mov eax, 01H
08584DC6  66 89 05 CC CC CC CC          mov [CCCCCCCCH], ax ; $$DATA$$+140

#8		
#9		
#10			(* IF fdi_q_cnt >= q_pulses_per_acs *)
#11			LD		fdi_q_cnt	{LNXT:15|-1|-1}
(*) UNDEF
08584DCD  8B 05 CC CC CC CC             mov eax, [CCCCCCCCH] ; %M500+0

#12			GE		q_pulses_per_acs	{LNXT:15|-1|-1}
(*) UDINT
08584DD3  33 C9                         xor ecx, ecx
08584DD5  66 8B 0D CC CC CC CC          mov cx, [CCCCCCCCH] ; $$DATA$$+140
08584DDC  3B C1                         cmp eax, ecx
08584DDE  0F 93 C0                      setae al
08584DE1  25 FF 00 00 00                and eax, 0FFh

#13			JMPCN	$label0	{LNXT:15|16|20}
(-) BOOL
08584DE6  84 C0                         test al, al
08584DE8  90 74 22 90 90 90             je 08584E0DH

#14		
#15			(* THEN *)
#16		
#17				(* q_counter := q_counter + 1; *)
#18				LD		q_counter	{LNXT:16|17|-1}
(*) UNDEF
08584DEE  8B 05 CC CC CC CC             mov eax, [CCCCCCCCH] ; %M110+8

#19				ADD		1	{LNXT:16|17|-1}
(*) DWORD
08584DF4  05 01 00 00 00                add eax, 1

#20				ST		q_counter	{LNXT:16|17|-1}
(*) DWORD
08584DF9  89 05 CC CC CC CC             mov [CCCCCCCCH], eax ; %M110+8

#21		
#22				(* fdi_q_reset := true; *)
#23				MOVE		true,fdi_q_reset	{LNXT:17|20|-1}
(*) DWORD
08584DFF  B8 01 00 00 00                mov eax, 01H
08584E04  84 C0                         test al, al
08584E06  0F 95 05 CC CC CC CC          setne [CCCCCCCCH] ; %M550+0

#24		
#25		$label0:
#26			(* END_IF *)
#27		
#28			(* q_value := to_int((3600 * to_real(fdi_q_freq)) / (to_real(q_pulses_per_acs) / 1)); *)
#29			LDP0		fdi_q_freq	{LNXT:20|2|-1}
(*) BOOL
#30			to_real	{LNXT:20|2|-1}
(*) BOOL
08584E0D  8B 05 CC CC CC CC             mov eax, [CCCCCCCCH] ; %M500+4
08584E13  68 00 00 00 00                push 0
08584E18  50                            push eax
08584E19  DF 2C 24                      fild qword ptr [esp]
08584E1C  81 C4 08 00 00 00             add esp, 8

#31			MUL		3600	{LNXT:20|2|-1}
(*) REAL
08584E22  68 10 0E 00 00                push 3600
08584E27  DA 0C 24                      fimul [esp]
08584E2A  81 C4 04 00 00 00             add esp, 4

#32			DIV(		0	{LNXT:20|2|-1}
(*) REAL
08584E30  81 EC 04 00 00 00             sub esp, 4
08584E36  D9 1C 24                      fstp dword ptr [esp]
08584E39  B8 00 00 00 00                mov eax, 00H

#33			LDP0		q_pulses_per_acs	{LNXT:20|2|-1}
(*) USINT
#34			to_real	{LNXT:20|2|-1}
(*) USINT
08584E3E  33 C0                         xor eax, eax
08584E40  66 8B 05 CC CC CC CC          mov ax, [CCCCCCCCH] ; $$DATA$$+140
08584E47  68 00 00 00 00                push 0
08584E4C  50                            push eax
08584E4D  DF 2C 24                      fild qword ptr [esp]
08584E50  81 C4 08 00 00 00             add esp, 8

#35			DIV		1	{LNXT:20|2|-1}
(*) REAL
08584E56  68 01 00 00 00                push 1
08584E5B  DA 34 24                      fidiv [esp]
08584E5E  81 C4 04 00 00 00             add esp, 4

#36			)	{LNXT:20|2|-1}
(*) REAL
08584E64  81 EC 04 00 00 00             sub esp, 4
08584E6A  D9 1C 24                      fstp dword ptr [esp]
08584E6D  D9 44 24 04                   fld dword ptr 4[esp]
08584E71  D8 34 24                      fdiv dword ptr [esp]
08584E74  81 C4 08 00 00 00             add esp, 8

#37			to_int	{LNXT:20|2|-1}
(*) REAL
08584E7A  81 EC 08 00 00 00             sub esp, 8
08584E80  DF 3C 24                      fistp qword ptr [esp]
08584E83  58                            pop eax
08584E84  81 C4 04 00 00 00             add esp, 4

#38			ST		q_value	{LNXT:20|2|-1}
(*) INT
08584E8A  66 89 05 CC CC CC CC          mov [CCCCCCCCH], ax ; %M110+14

END_PROGRAM
**************************************************
	List program: sr_save_counters
**************************************************

PROGRAM sr_save_counters

        VAR
power_err : R_TRIG;
ton_start_up : TON;
res_q : BOOL;
res_kw : BOOL;
	END_VAR

END_PROGRAM

#0		{SRC:sr_save_counters}
#1		(*$WAITSWITCH$*)
#2		
#3			(* ton_start_up *)
#4			MOVE		true,ton_start_up.IN	{LNXT:1|-1|-1}
(*) UDINT
08584E91  B8 01 00 00 00                mov eax, 01H
08584E96  84 C0                         test al, al
08584E98  0F 95 05 CC CC CC CC          setne [CCCCCCCCH] ; $$DATA$$+148

#5			MOVE		5000,ton_start_up.PT	{LNXT:1|-1|-1}
(*) BOOL
08584E9F  B8 88 13 00 00                mov eax, 1388H
08584EA4  89 05 CC CC CC CC             mov [CCCCCCCCH], eax ; $$DATA$$+149

#6			CAL		ton_start_up	{LNXT:1|2|-1}
(*) UDINT
08584EAA  50                            push eax
08584EAB  BB CC CC CC CC                mov ebx, CCCCCCCCH ; $$DATA$$+144
08584EB0  E8 E4 F5 FF FF                call 08584499H ; $$CODE$$+17561
08584EB5  58                            pop eax

#7		
#8			(* power_err *)
#9			LD		ton_start_up.Q	{LNXT:2|-1|-1}
(*) UNDEF
08584EB6  33 C0                         xor eax, eax
08584EB8  8A 05 CC CC CC CC             mov al, [CCCCCCCCH] ; $$DATA$$+153

#10			AND		i_rnpp	{LNXT:2|-1|-1}
(*) BOOL
08584EBE  33 C9                         xor ecx, ecx
08584EC0  8A 0D CC CC CC CC             mov cl, [CCCCCCCCH] ; $$DATA$$+295
08584EC6  23 C1                         and eax, ecx

#11			ST		power_err.clk	{LNXT:2|-1|-1}
(*) BOOL
08584EC8  84 C0                         test al, al
08584ECA  0F 95 05 CC CC CC CC          setne [CCCCCCCCH] ; $$DATA$$+167

#12			CAL		power_err	{LNXT:2|3|-1}
(*) BOOL
08584ED1  50                            push eax
08584ED2  BB CC CC CC CC                mov ebx, CCCCCCCCH ; $$DATA$$+166
08584ED7  E8 94 F5 FF FF                call 08584470H ; $$CODE$$+17520
08584EDC  58                            pop eax

#13		
#14		
#15			(* IF power_err.q *)
#16			LD		power_err.q	{LNXT:3|-1|-1}
(*) UNDEF
08584EDD  33 C0                         xor eax, eax
08584EDF  8A 05 CC CC CC CC             mov al, [CCCCCCCCH] ; $$DATA$$+168

#17			JMPCN	$label0	{LNXT:3|4|1}
(-) BOOL
08584EE5  84 C0                         test al, al
08584EE7  0F 84 82 00 00 00             je 08584F6FH

#18		
#19			(* THEN *)
#20		
#21		
#22				(* IF epprom_q_cnt <> q_counter *)
#23				LD		epprom_q_cnt	{LNXT:4|-1|-1}
(*) UNDEF
08584EED  8B 05 CC CC CC CC             mov eax, [CCCCCCCCH] ; %M101+0

#24				NE		q_counter	{LNXT:4|-1|-1}
(*) DWORD
08584EF3  3B 05 CC CC CC CC             cmp eax, [CCCCCCCCH] ; %M110+8
08584EF9  0F 95 C0                      setne al
08584EFC  25 FF 00 00 00                and eax, 0FFh

#25				JMPCN	$label1	{LNXT:4|4|5}
(-) BOOL
08584F01  84 C0                         test al, al
08584F03  90 74 28 90 90 90             je 08584F2EH

#26		
#27				(* THEN *)
#28		
#29					(* res_q := sysWriteParUINT(ADR(epprom_q_cnt), q_counter); *)
#30					ADR		epprom_q_cnt	{LNXT:4|5|-1}
(*) BOOL
08584F09  B8 CC CC CC CC                mov eax, CCCCCCCCH ; %M101+0

#31					sysWriteParUINT		q_counter	{LNXT:4|5|-1}
(*) @DWORD
08584F0E  8B 0D CC CC CC CC             mov ecx, [CCCCCCCCH] ; %M110+8
08584F14  51                            push ecx
08584F15  8B C8                         mov ecx, eax
08584F17  51                            push ecx
08584F18  B9 CC CC CC CC                mov ecx, CCCCCCCCH ; sysWriteParUINT
08584F1D  FF D1                         call ecx
08584F1F  81 C4 08 00 00 00             add esp, 8

#32					ST		res_q	{LNXT:4|5|-1}
(*) BOOL
08584F25  84 C0                         test al, al
08584F27  0F 95 05 CC CC CC CC          setne [CCCCCCCCH] ; $$DATA$$+137

#33		
#34		$label1:
#35				(* END_IF *)
#36		
#37		
#38				(* IF epprom_kw_cnt <> kw_counter *)
#39				LD		epprom_kw_cnt	{LNXT:5|-1|-1}
(*) UNDEF
08584F2E  8B 05 CC CC CC CC             mov eax, [CCCCCCCCH] ; %M101+8

#40				NE		kw_counter	{LNXT:5|-1|-1}
(*) DWORD
08584F34  3B 05 CC CC CC CC             cmp eax, [CCCCCCCCH] ; %M110+4
08584F3A  0F 95 C0                      setne al
08584F3D  25 FF 00 00 00                and eax, 0FFh

#41				JMPCN	$label2	{LNXT:5|5|1}
(-) BOOL
08584F42  84 C0                         test al, al
08584F44  90 74 28 90 90 90             je 08584F6FH

#42		
#43				(* THEN *)
#44		
#45					(* res_kw := sysWriteParUINT(ADR(epprom_kw_cnt), kw_counter); *)
#46					ADR		epprom_kw_cnt	{LNXT:5|1|-1}
(*) BOOL
08584F4A  B8 CC CC CC CC                mov eax, CCCCCCCCH ; %M101+8

#47					sysWriteParUINT		kw_counter	{LNXT:5|1|-1}
(*) @DWORD
08584F4F  8B 0D CC CC CC CC             mov ecx, [CCCCCCCCH] ; %M110+4
08584F55  51                            push ecx
08584F56  8B C8                         mov ecx, eax
08584F58  51                            push ecx
08584F59  B9 CC CC CC CC                mov ecx, CCCCCCCCH ; sysWriteParUINT
08584F5E  FF D1                         call ecx
08584F60  81 C4 08 00 00 00             add esp, 8

#48					ST		res_kw	{LNXT:5|1|-1}
(*) BOOL
08584F66  84 C0                         test al, al
08584F68  0F 95 05 CC CC CC CC          setne [CCCCCCCCH] ; $$DATA$$+177

END_PROGRAM
**************************************************
	List program: sr_ATS_Ctrl
**************************************************

PROGRAM sr_ATS_Ctrl

        VAR
TON_StartUp_1 : TON;
TON_StartUp_2 : TON;
stopping_timer : TON;
downtimeIN : BOOL;
washing_timer : TON;
checkWashAndStart : CheckWashAndStart;
isRunningWash : BOOL;
onWash : BOOL := false;
time_sec : INT := 4000;
	END_VAR

END_PROGRAM

#0		{SRC:sr_ATS_Ctrl}
#1		(*$WAITSWITCH$*)
#2		
#3		
#4			(* IF i_pb_rem = 1 And
#5		Not Alarms.0 And 
#6		Not Alarms.3 And 
#7		Not Alarms.4 And 
#8		Not Alarms.5 And 
#9		Not Alarms.7 *)
#10			LD		Alarms.7	{LNXT:2|-1|-1}
(*) UNDEF
08584F6F  33 C0                         xor eax, eax
08584F71  66 8B 05 CC CC CC CC          mov ax, [CCCCCCCCH] ; %M110+32
08584F78  C1 E8 07                      shr eax, 7
08584F7B  25 01 00 00 00                and eax, 1

#11			NOT	{LNXT:2|-1|-1}
(*) BOOL
08584F80  84 C0                         test al, al
08584F82  0F 94 C0                      sete al

#12			AND(		Alarms.5	{LNXT:2|-1|-1}
(*) BOOL
08584F85  50                            push eax
08584F86  33 C0                         xor eax, eax
08584F88  66 8B 05 CC CC CC CC          mov ax, [CCCCCCCCH] ; %M110+32
08584F8F  C1 E8 05                      shr eax, 5
08584F92  25 01 00 00 00                and eax, 1

#13			NOT	{LNXT:2|-1|-1}
(*) BOOL
08584F97  84 C0                         test al, al
08584F99  0F 94 C0                      sete al

#14			AND(		Alarms.4	{LNXT:2|-1|-1}
(*) BOOL
08584F9C  50                            push eax
08584F9D  33 C0                         xor eax, eax
08584F9F  66 8B 05 CC CC CC CC          mov ax, [CCCCCCCCH] ; %M110+32
08584FA6  C1 E8 04                      shr eax, 4
08584FA9  25 01 00 00 00                and eax, 1

#15			NOT	{LNXT:2|-1|-1}
(*) BOOL
08584FAE  84 C0                         test al, al
08584FB0  0F 94 C0                      sete al

#16			AND(		Alarms.3	{LNXT:2|-1|-1}
(*) BOOL
08584FB3  50                            push eax
08584FB4  33 C0                         xor eax, eax
08584FB6  66 8B 05 CC CC CC CC          mov ax, [CCCCCCCCH] ; %M110+32
08584FBD  C1 E8 03                      shr eax, 3
08584FC0  25 01 00 00 00                and eax, 1

#17			NOT	{LNXT:2|-1|-1}
(*) BOOL
08584FC5  84 C0                         test al, al
08584FC7  0F 94 C0                      sete al

#18			AND(		Alarms.0	{LNXT:2|-1|-1}
(*) BOOL
08584FCA  50                            push eax
08584FCB  33 C0                         xor eax, eax
08584FCD  66 8B 05 CC CC CC CC          mov ax, [CCCCCCCCH] ; %M110+32
08584FD4  25 01 00 00 00                and eax, 1

#19			NOT	{LNXT:2|-1|-1}
(*) BOOL
08584FD9  84 C0                         test al, al
08584FDB  0F 94 C0                      sete al

#20			AND(		i_pb_rem	{LNXT:2|-1|-1}
(*) BOOL
08584FDE  50                            push eax
08584FDF  0F BF 05 CC CC CC CC          movsx eax, word ptr [CCCCCCCCH] ; $$DATA$$+290

#21			EQ		1	{LNXT:2|-1|-1}
(*) INT
08584FE6  3D 01 00 00 00                cmp eax, 1
08584FEB  0F 94 C0                      sete al
08584FEE  25 FF 00 00 00                and eax, 0FFh

#22			)	{LNXT:2|-1|-1}
(*) BOOL
08584FF3  8B C8                         mov ecx, eax
08584FF5  58                            pop eax
08584FF6  23 C1                         and eax, ecx

#23			)	{LNXT:2|-1|-1}
(*) BOOL
08584FF8  8B C8                         mov ecx, eax
08584FFA  58                            pop eax
08584FFB  23 C1                         and eax, ecx

#24			)	{LNXT:2|-1|-1}
(*) BOOL
08584FFD  8B C8                         mov ecx, eax
08584FFF  58                            pop eax
08585000  23 C1                         and eax, ecx

#25			)	{LNXT:2|-1|-1}
(*) BOOL
08585002  8B C8                         mov ecx, eax
08585004  58                            pop eax
08585005  23 C1                         and eax, ecx

#26			)	{LNXT:2|-1|-1}
(*) BOOL
08585007  8B C8                         mov ecx, eax
08585009  58                            pop eax
0858500A  23 C1                         and eax, ecx

#27			JMPCN	$label0	{LNXT:2|9|69}
(-) BOOL
0858500C  84 C0                         test al, al
0858500E  90 74 67 90 90 90             je 08585078H

#28		
#29			(* THEN *)
#30		
#31				(* checkWashAndStart *)
#32				MOVE		o_val_close_fall,checkWashAndStart.o_val_close_fall_FB	{LNXT:9|-1|-1}
(*) BOOL
08585014  B8 CC CC CC CC                mov eax, CCCCCCCCH ; %Q1+1
08585019  89 05 CC CC CC CC             mov [CCCCCCCCH], eax ; $$DATA$$+108

#33				MOVE		o_val_close_R,checkWashAndStart.o_val_close_R_FB	{LNXT:10|-1|-1}
(*) BOOL^
0858501F  B8 CC CC CC CC                mov eax, CCCCCCCCH ; %Q1+3
08585024  89 05 CC CC CC CC             mov [CCCCCCCCH], eax ; $$DATA$$+100

#34				MOVE		o_val_open_fall,checkWashAndStart.o_val_open_fall_FB	{LNXT:11|-1|-1}
(*) BOOL^
0858502A  B8 CC CC CC CC                mov eax, CCCCCCCCH ; %Q1+0
0858502F  89 05 CC CC CC CC             mov [CCCCCCCCH], eax ; $$DATA$$+104

#35				MOVE		o_val_open_R,checkWashAndStart.o_val_open_R_FB	{LNXT:12|-1|-1}
(*) BOOL^
08585035  B8 CC CC CC CC                mov eax, CCCCCCCCH ; %Q1+2
0858503A  89 05 CC CC CC CC             mov [CCCCCCCCH], eax ; $$DATA$$+96

#36				MOVE		sv_washing,checkWashAndStart.sv_washing_FB	{LNXT:13|-1|-1}
(*) BOOL^
08585040  B8 CC CC CC CC                mov eax, CCCCCCCCH ; %M110+38
08585045  89 05 CC CC CC CC             mov [CCCCCCCCH], eax ; $$DATA$$+92

#37				MOVE		q_start_ats,checkWashAndStart.q_start_ats_FB	{LNXT:14|-1|-1}
(*) BOOL^
0858504B  B8 CC CC CC CC                mov eax, CCCCCCCCH ; %Q1+7
08585050  89 05 CC CC CC CC             mov [CCCCCCCCH], eax ; $$DATA$$+112

#38				MOVE		time_sec,checkWashAndStart.ep_time_wash_FB	{LNXT:15|-1|-1}
(*) BOOL^
08585056  B8 CC CC CC CC                mov eax, CCCCCCCCH ; $$DATA$$+66
0858505B  89 05 CC CC CC CC             mov [CCCCCCCCH], eax ; $$DATA$$+116

#39				MOVE		i_val_state,checkWashAndStart.i_val_state_FB	{LNXT:16|-1|-1}
(*) INT^
08585061  B8 CC CC CC CC                mov eax, CCCCCCCCH ; $$DATA$$+292
08585066  89 05 CC CC CC CC             mov [CCCCCCCCH], eax ; $$DATA$$+120

#40				CAL		checkWashAndStart	{LNXT:9|69|-1}
(*) INT^
0858506C  50                            push eax
0858506D  BB CC CC CC CC                mov ebx, CCCCCCCCH ; $$DATA$$+68
08585072  E8 AA F4 FF FF                call 08584521H ; $$CODE$$+17697
08585077  58                            pop eax

#41		
#42		$label0:
#43			(* END_IF *)
#44		
#45		
#46			(* IF q_start_ats *)
#47			LD		q_start_ats	{LNXT:69|-1|-1}
(*) UNDEF
08585078  33 C0                         xor eax, eax
0858507A  8A 05 CC CC CC CC             mov al, [CCCCCCCCH] ; %Q1+7

#48			NOT	{LNXT:69|-1|-1}
(*) BOOL
08585080  84 C0                         test al, al
08585082  0F 94 C0                      sete al

#49			JMPCN	$label1	{LNXT:69|70|72}
(-) BOOL
08585085  84 C0                         test al, al
08585087  90 74 16 90 90 90             je 085850A0H

#50		
#51			(* THEN *)
#52		
#53				(* downtimeIN:=true; *)
#54				MOVE		true,downtimeIN	{LNXT:70|82|-1}
(*) BOOL
0858508D  B8 01 00 00 00                mov eax, 01H
08585092  84 C0                         test al, al
08585094  0F 95 05 CC CC CC CC          setne [CCCCCCCCH] ; $$DATA$$+58

#55				JMP		$label2	{LNXT:69|70|72}
(-) BOOL
0858509B  EB 11 90 90 90                jmp 085850AEH

#56		$label1:
#57		
#58			(* ELSE *)
#59		
#60				(* downtimeIN:=false; *)
#61				MOVE		false,downtimeIN	{LNXT:72|82|-1}
(*) BOOL
085850A0  B8 00 00 00 00                mov eax, 00H
085850A5  84 C0                         test al, al
085850A7  0F 95 05 CC CC CC CC          setne [CCCCCCCCH] ; $$DATA$$+58

#62		
#63		$label2:
#64			(* END_IF *)
#65		
#66			(* Alarms.2 := i_sns_door; *)
#67			MOVE		i_sns_door,Alarms.2	{LNXT:82|85|-1}
(*) BOOL
085850AE  33 C0                         xor eax, eax
085850B0  8A 05 CC CC CC CC             mov al, [CCCCCCCCH] ; $$DATA$$+294
085850B6  84 C0                         test al, al
085850B8  90 75 11 90 90 90             jne 00000014H@
085850BE  66 0F BA 35 CC CC CC CC 02    btr word ptr [CCCCCCCCH], 2 ; %M110+32
085850C7  EB 0C 90 90 90                jmp 0000000EH@
085850CC  66 0F BA 2D CC CC CC CC 02    bts word ptr [CCCCCCCCH], 2 ; %M110+32

#68		
#69			(* Alarms.3 := i_rnpp; *)
#70			MOVE		i_rnpp,Alarms.3	{LNXT:85|91|-1}
(*) BOOL
085850D5  33 C0                         xor eax, eax
085850D7  8A 05 CC CC CC CC             mov al, [CCCCCCCCH] ; $$DATA$$+295
085850DD  84 C0                         test al, al
085850DF  90 75 11 90 90 90             jne 00000014H@
085850E5  66 0F BA 35 CC CC CC CC 03    btr word ptr [CCCCCCCCH], 3 ; %M110+32
085850EE  EB 0C 90 90 90                jmp 0000000EH@
085850F3  66 0F BA 2D CC CC CC CC 03    bts word ptr [CCCCCCCCH], 3 ; %M110+32

#71		
#72			(* Alarms.5 := i_no_alm_ats; *)
#73			MOVE		i_no_alm_ats,Alarms.5	{LNXT:91|132|-1}
(*) BOOL
085850FC  33 C0                         xor eax, eax
085850FE  8A 05 CC CC CC CC             mov al, [CCCCCCCCH] ; $$DATA$$+296
08585104  84 C0                         test al, al
08585106  90 75 11 90 90 90             jne 00000014H@
0858510C  66 0F BA 35 CC CC CC CC 05    btr word ptr [CCCCCCCCH], 5 ; %M110+32
08585115  EB 0C 90 90 90                jmp 0000000EH@
0858511A  66 0F BA 2D CC CC CC CC 05    bts word ptr [CCCCCCCCH], 5 ; %M110+32

#74		
#75		
#76			(* IF CMD.1 *)
#77			LD		CMD.1	{LNXT:132|-1|-1}
(*) UNDEF
08585123  33 C0                         xor eax, eax
08585125  66 8B 05 CC CC CC CC          mov ax, [CCCCCCCCH] ; %M110+34
0858512C  C1 E8 01                      shr eax, 1
0858512F  25 01 00 00 00                and eax, 1

#78			JMPCN	$label3	{LNXT:132|133|2}
(-) BOOL
08585134  84 C0                         test al, al
08585136  90 74 33 90 90 90             je 0858516CH

#79		
#80			(* THEN *)
#81		
#82				(* Alarms := 0; *)
#83				MOVE		0,Alarms	{LNXT:133|134|-1}
(*) BOOL
0858513C  B8 00 00 00 00                mov eax, 00H
08585141  66 89 05 CC CC CC CC          mov [CCCCCCCCH], ax ; %M110+32

#84		
#85				(* CMD.1 := False; *)
#86				MOVE		False,CMD.1	{LNXT:134|2|-1}
(*) WORD
08585148  B8 00 00 00 00                mov eax, 00H
0858514D  84 C0                         test al, al
0858514F  90 75 11 90 90 90             jne 00000014H@
08585155  66 0F BA 35 CC CC CC CC 01    btr word ptr [CCCCCCCCH], 1 ; %M110+34
0858515E  EB 0C 90 90 90                jmp 0000000EH@
08585163  66 0F BA 2D CC CC CC CC 01    bts word ptr [CCCCCCCCH], 1 ; %M110+34

0858516C  61                            popad
0858516D  5D                            pop ebp

0858516E  C3                            ret

END_PROGRAM


**************************************************
	Target variable image generation
**************************************************


*** INPUT:
0858516F  55                            push ebp
08585170  8B EC                         mov ebp, esp

08585172  66 8B 0D CC CC CC CC          mov cx, [CCCCCCCCH] ; %I1+14
08585179  66 89 0D CC CC CC CC          mov [CCCCCCCCH], cx ; $$DATA$$+290

08585180  66 8B 0D CC CC CC CC          mov cx, [CCCCCCCCH] ; %I1+4
08585187  66 89 0D CC CC CC CC          mov [CCCCCCCCH], cx ; $$DATA$$+292

0858518E  8A 0D CC CC CC CC             mov cl, [CCCCCCCCH] ; %I0+3
08585194  88 0D CC CC CC CC             mov [CCCCCCCCH], cl ; $$DATA$$+294

0858519A  8A 0D CC CC CC CC             mov cl, [CCCCCCCCH] ; %I0+4
085851A0  88 0D CC CC CC CC             mov [CCCCCCCCH], cl ; $$DATA$$+295

085851A6  8A 0D CC CC CC CC             mov cl, [CCCCCCCCH] ; %I0+6
085851AC  88 0D CC CC CC CC             mov [CCCCCCCCH], cl ; $$DATA$$+296

085851B2  66 8B 0D CC CC CC CC          mov cx, [CCCCCCCCH] ; %I1+0
085851B9  66 89 0D CC CC CC CC          mov [CCCCCCCCH], cx ; $$DATA$$+298

085851C0  8B E5                         mov esp, ebp
085851C2  5D                            pop ebp

085851C3  C3                            ret


*** OUTPUT:
085851C4  55                            push ebp
085851C5  8B EC                         mov ebp, esp

085851C7  8B E5                         mov esp, ebp
085851C9  5D                            pop ebp

085851CA  C3                            ret



**************************************************
	Task Timed init code
**************************************************

085851CB  55                            push ebp
085851CC  8B EC                         mov ebp, esp

Var init: V::SR_ATS_CTRL.TIME_SEC = 4000
085851CE  66 C7 05 CC CC CC CC A0 0F    mov word ptr [CCCCCCCCH], 0FA0H ; $$DATA$$+66

085851D7  8B E5                         mov esp, ebp
085851D9  5D                            pop ebp

085851DA  C3                            ret



**************************************************
	Global init code
**************************************************

085851F0  55                            push ebp
085851F1  8B EC                         mov ebp, esp

Var init: V:EMBEDDEDELEMENTS:$$POUCBARRAY$$BACKGROUND = [?ATS_mdb.$$POUCB$$, 0]
085851F3  B9 CC CC CC CC                mov ecx, CCCCCCCCH ; $$DATA$$+300
085851F8  89 0D CC CC CC CC             mov [CCCCCCCCH], ecx ; $$DATA$$+180

Var init: V:EMBEDDEDELEMENTS:$$POUCBARRAY$$BOOT = [?sr_init_counters.$$POUCB$$, 0]
085851FE  B9 CC CC CC CC                mov ecx, CCCCCCCCH ; $$DATA$$+306
08585203  89 0D CC CC CC CC             mov [CCCCCCCCH], ecx ; $$DATA$$+188

Var init: V:EMBEDDEDELEMENTS:$$POUCBARRAY$$INIT = [?init_val.$$POUCB$$, 0]
08585209  B9 CC CC CC CC                mov ecx, CCCCCCCCH ; $$DATA$$+312
0858520E  89 0D CC CC CC CC             mov [CCCCCCCCH], ecx ; $$DATA$$+196

Var init: V:EMBEDDEDELEMENTS:$$POUCBARRAY$$SERV = [?InitParDB.$$POUCB$$, 0]
08585214  B9 CC CC CC CC                mov ecx, CCCCCCCCH ; $$DATA$$+318
08585219  89 0D CC CC CC CC             mov [CCCCCCCCH], ecx ; $$DATA$$+204

Var init: V:EMBEDDEDELEMENTS:$$POUCBARRAY$$TIMED = [?sr_pressure.$$POUCB$$, ?sr_counters.$$POUCB$$, ?sr_save_counters.$$POUCB$$, ?sr_ATS_Ctrl.$$POUCB$$, 0]
0858521F  B9 CC CC CC CC                mov ecx, CCCCCCCCH ; $$DATA$$+324
08585224  89 0D CC CC CC CC             mov [CCCCCCCCH], ecx ; $$DATA$$+212
0858522A  B9 CC CC CC CC                mov ecx, CCCCCCCCH ; $$DATA$$+330
0858522F  89 0D CC CC CC CC             mov [CCCCCCCCH], ecx ; $$DATA$$+216
08585235  B9 CC CC CC CC                mov ecx, CCCCCCCCH ; $$DATA$$+336
0858523A  89 0D CC CC CC CC             mov [CCCCCCCCH], ecx ; $$DATA$$+220
08585240  B9 CC CC CC CC                mov ecx, CCCCCCCCH ; $$DATA$$+342
08585245  89 0D CC CC CC CC             mov [CCCCCCCCH], ecx ; $$DATA$$+224

0858524B  8B E5                         mov esp, ebp
0858524D  5D                            pop ebp

0858524E  C3                            ret



**************************************************
	Global RETAIN init code
**************************************************

0858524F  55                            push ebp
08585250  8B EC                         mov ebp, esp

08585252  8B E5                         mov esp, ebp
08585254  5D                            pop ebp

08585255  C3                            ret



**************************************************
	Task $$VirtualTables init code
**************************************************

08585256  55                            push ebp
08585257  8B EC                         mov ebp, esp

08585259  8B E5                         mov esp, ebp
0858525B  5D                            pop ebp

0858525C  C3                            ret



********************************************
MEMORY MAP
********************************************

Code area type:          		       main code
Start code area:          		0000000008580000h
End code area:            		0000000008585B3Ch
Code size:                		00005B3Ch

Start local data area:    		0000000008400000h
End local data area:      		000000000840015Ch
Local data size:          		0000015Ch

Start retentive data area:		0000000000000000h
End retentive data area:  		0000000000000000h
Retentive data size:      		00000000h

Start bit data area:      		0000000000000000h
End bit data area:        		0000000000000000h
Bit data size:            		00000000h



********************************************
CODE ID:                                207CC759
DEBUG MEMO ID:                          000034F7
FULL MEMO ID:                           000063D9
RELOCATION ADDR:                        0000000008580000
********************************************
