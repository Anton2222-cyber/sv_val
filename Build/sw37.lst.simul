***********************************************************************
*
*	CODE GENERATION LISTING FOR: sw37
*	COMPILER VERSION: 6.0.0.52
*
***********************************************************************

**************************************************
	List function block: R_TRIG
**************************************************

FUNCTION_BLOCK R_TRIG

	{ DE:"<HTML>The output Q will remain FALSE as long as the input variable CLK is FALSE.<br>
As soon as CLK returns TRUE, Q will first return TRUE.<br><br>
This means each time the function is called up, Q will return FALSE until CLK has falling edge followed by an rising edge.<br><br>
<img src= r_trig.png>" }

        VAR_INPUT
clk : BOOL;	{ DE:"Input for edge detection" }
	END_VAR

        VAR_OUTPUT
q : BOOL;	{ DE:"Raising edge output" }
	END_VAR

        VAR
m : BOOL := FALSE;
	END_VAR

END_FUNCTION_BLOCK

086F44B0  55                            push ebp
086F44B1  8B EB                         mov ebp, ebx
086F44B3  57                            push edi

#0		{SRC:R_TRIG}
#1		
#2			LD		clk
(*) UNDEF
086F44B4  33 C0                         xor eax, eax
086F44B6  8A 45 01                      mov al, 1[ebp]

#3			ANDN	m
(*) BOOL
086F44B9  33 C9                         xor ecx, ecx
086F44BB  8A 4D 00                      mov cl, [ebp]
086F44BE  84 C9                         test cl, cl
086F44C0  0F 94 C1                      sete cl
086F44C3  23 C1                         and eax, ecx

#4			ST		q
(*) BOOL
086F44C5  84 C0                         test al, al
086F44C7  0F 95 45 02                   setne 2[ebp]

#5		
#6			LD		clk
(*) UNDEF
086F44CB  33 C0                         xor eax, eax
086F44CD  8A 45 01                      mov al, 1[ebp]

#7			ST		m
(*) BOOL
086F44D0  84 C0                         test al, al
086F44D2  0F 95 45 00                   setne [ebp]

086F44D6  5F                            pop edi
086F44D7  5D                            pop ebp

086F44D8  C3                            ret


Frame allocation (hex):

	0000 bit  0: VAR m
	0001 bit  0: VAR clk
	0002 bit  0: VAR q

END_FUNCTION_BLOCK
**************************************************
	List function block: TON
**************************************************

FUNCTION_BLOCK TON

	{ DE:"<HTML>The TON block produces a delayed output Q of the input IN. The delay time is expressed in milliseconds on the PT input.</br></br>
<img src= tonscheme.png>
<ul>
<li>if IN is FALSE Q is false</li>
<li>Q becomes TRUE as IN remains TRUE for PT milliseconds</li>
<li>Q remains TRUE until IN remains TRUE</li>
</ul>" }

        VAR_INPUT
IN : BOOL;	{ DE:"Timer input source" }
PT : UDINT;	{ DE:"Preset time value (ms)" }
	END_VAR

        VAR_OUTPUT
Q : BOOL;	{ DE:"Timer output" }
ET : UDINT;	{ DE:"Timer current value (ms)" }
	END_VAR

        VAR_EXTERNAL
	{G:"System_Timers"}
sysTimer AT %MD0.0 : UDINT;	{ DE:"System timer [ms]" }
	END_VAR

        VAR
timStart : UDINT;	{ DE:"Time value at start of counting" }
	END_VAR

END_FUNCTION_BLOCK

086F44D9  55                            push ebp
086F44DA  8B EB                         mov ebp, ebx
086F44DC  57                            push edi

#0		{SRC:TON}
#1		
#2			(*	Check if in counting	*)
#3		
#4			LD		IN
(*) UNDEF
086F44DD  33 C0                         xor eax, eax
086F44DF  8A 45 04                      mov al, 4[ebp]

#5			JMPCN	lReset
(-) BOOL
086F44E2  84 C0                         test al, al
086F44E4  90 74 61 90 90 90             je 086F4548H

#6		
#7			(*	Check if Q is TRUE *)
#8			LD		Q
(*) UNDEF
086F44EA  33 C0                         xor eax, eax
086F44EC  8A 45 09                      mov al, 9[ebp]

#9			RETC
#10			
(-) BOOL
086F44EF  84 C0                         test al, al
086F44F1  90 75 6A 90 90 90             jne 086F455EH

#11			(*	Check if already in counting *)
#12			LD		timStart
(*) UNDEF
086F44F7  8B 45 00                      mov eax, [ebp]

#13			EQ		0
(*) UDINT
086F44FA  3D 00 00 00 00                cmp eax, 0
086F44FF  0F 94 C0                      sete al
086F4502  25 FF 00 00 00                and eax, 0FFh

#14			JMPCN	lUpdate
(-) BOOL
086F4507  84 C0                         test al, al
086F4509  90 74 0C 90 90 90             je 086F4518H

#15		
#16			(*	Start of counting *)
#17			LD		sysTimer
(*) UNDEF
086F450F  8B 05 CC CC CC CC             mov eax, [CCCCCCCCH] ; %M0+0

#18			ST		timStart
(*) UDINT
086F4515  89 45 00                      mov [ebp], eax

#19			
#20		lUpdate:
#21		
#22			(*	Update timer and check if time elapsed *)
#23			LD		sysTimer
(*) UNDEF
086F4518  8B 05 CC CC CC CC             mov eax, [CCCCCCCCH] ; %M0+0

#24			SUB		timStart
(*) UDINT
086F451E  2B 45 00                      sub eax, [ebp]

#25			ST		ET
(*) UDINT
086F4521  89 45 0A                      mov 10[ebp], eax

#26			GE		PT
(*) UDINT
086F4524  3B 45 05                      cmp eax, [ebp+5]
086F4527  0F 93 C0                      setae al
086F452A  25 FF 00 00 00                and eax, 0FFh

#27			ST		Q
(*) BOOL
086F452F  84 C0                         test al, al
086F4531  0F 95 45 09                   setne 9[ebp]

#28			RETCN
#29		
(-) BOOL
086F4535  84 C0                         test al, al
086F4537  90 74 24 90 90 90             je 086F455EH

#30			(*	Limit actual time value *)
#31			LD		PT
(*) UNDEF
086F453D  8B 45 05                      mov eax, 5[ebp]

#32			ST		ET
(*) UDINT
086F4540  89 45 0A                      mov 10[ebp], eax

#33			RET
#34		
(-) UDINT
086F4543  EB 19 90 90 90                jmp 086F455EH

#35		lReset:
#36		
#37			(*	Reset status *)
#38			LD		0
(*) UNDEF
086F4548  B8 00 00 00 00                mov eax, 00H

#39			ST		ET
(*) USINT
086F454D  89 45 0A                      mov 10[ebp], eax

#40			ST		timStart
(*) UDINT
086F4550  89 45 00                      mov [ebp], eax

#41			LD		FALSE
(*) UNDEF
086F4553  B8 00 00 00 00                mov eax, 00H

#42			ST		Q
(*) BOOL
086F4558  84 C0                         test al, al
086F455A  0F 95 45 09                   setne 9[ebp]

086F455E  5F                            pop edi
086F455F  5D                            pop ebp

086F4560  C3                            ret


Frame allocation (hex):

	0000       : VAR timStart
	0004 bit  0: VAR IN
	0005       : VAR PT
	0009 bit  0: VAR Q
	000A       : VAR ET

END_FUNCTION_BLOCK
**************************************************
	List function block: CheckAlarmVal
**************************************************

FUNCTION_BLOCK CheckAlarmVal

        VAR_IN_OUT
di_val_open_state_fall_FB : INT^;
di_val_close_state_fall_FB : INT^;
di_val_open_state_R_FB : INT^;
di_val_close_state_R_FB : BOOL^;
Alarm_Val_FB : WORD^;
o_val_open_R_FB : BOOL^;
o_val_close_R_FB : BOOL^;
o_val_open_fall_FB : BOOL^;
o_val_close_fall_FB : BOOL^;
start_check : BOOL^;
	END_VAR

        VAR_OUTPUT
check_timer : TON;	{ DE:"локальний FB таймера" }
is_check_done : BOOL;
isOK : BOOL;
	END_VAR

        VAR
should_run_timer : BOOL;
	END_VAR

END_FUNCTION_BLOCK

086F4561  55                            push ebp
086F4562  8B EB                         mov ebp, ebx
086F4564  57                            push edi

#0		{SRC:CheckAlarmVal}
#1		(*$WAITSWITCH$*)
#2		
#3		
#4			(* IF check_timer.IN *)
#5			LD		check_timer.IN	{LNXT:3|-1|-1}
(*) UNDEF
086F4565  33 C0                         xor eax, eax
086F4567  8A 45 05                      mov al, 5[ebp]

#6			JMPCN	$label0	{LNXT:3|4|8}
(-) BOOL
086F456A  84 C0                         test al, al
086F456C  90 74 19 90 90 90             je 086F4588H

#7		
#8			(* THEN *)
#9		
#10				(* isOK := TRUE; *)
#11				MOVE		TRUE,isOK	{LNXT:4|5|-1}
(*) BOOL
086F4572  B8 01 00 00 00                mov eax, 01H
086F4577  84 C0                         test al, al
086F4579  0F 95 45 18                   setne 24[ebp]

#12		
#13				(* is_check_done := false; *)
#14				MOVE		false,is_check_done	{LNXT:5|8|-1}
(*) BOOL
086F457D  B8 00 00 00 00                mov eax, 00H
086F4582  84 C0                         test al, al
086F4584  0F 95 45 17                   setne 23[ebp]

#15		
#16		$label0:
#17			(* END_IF *)
#18		
#19		
#20			(* IF start_check *)
#21			LD		start_check	{LNXT:8|-1|-1}
(*) UNDEF
086F4588  8B 55 3D                      mov edx, 61[ebp]
086F458B  33 C0                         xor eax, eax
086F458D  8A 02                         mov al, [edx]

#22			JMPCN	$label1	{LNXT:8|9|13}
(-) BOOL
086F458F  84 C0                         test al, al
086F4591  90 74 25 90 90 90             je 086F45B9H

#23		
#24			(* THEN *)
#25		
#26				(* check_timer *)
#27				MOVE		true,check_timer.IN	{LNXT:9|-1|-1}
(*) BOOL
086F4597  B8 01 00 00 00                mov eax, 01H
086F459C  84 C0                         test al, al
086F459E  0F 95 45 05                   setne 5[ebp]

#28				MOVE		10000,check_timer.PT	{LNXT:9|-1|-1}
(*) BOOL
086F45A2  B8 10 27 00 00                mov eax, 2710H
086F45A7  89 45 06                      mov 6[ebp], eax

#29				CAL		check_timer	{LNXT:9|13|-1}
(*) UDINT
086F45AA  50                            push eax
086F45AB  8B DD                         mov ebx, ebp
086F45AD  81 C3 01 00 00 00             add ebx, 1
086F45B3  E8 21 FF FF FF                call 086F44D9H ; $$CODE$$+17625
086F45B8  58                            pop eax

#30		
#31		$label1:
#32			(* END_IF *)
#33		
#34		
#35			(* IF check_timer.Q *)
#36			LD		check_timer.Q	{LNXT:13|-1|-1}
(*) UNDEF
086F45B9  33 C0                         xor eax, eax
086F45BB  8A 45 0A                      mov al, 10[ebp]

#37			JMPCN	$label2	{LNXT:13|15|41}
(-) BOOL
086F45BE  84 C0                         test al, al
086F45C0  0F 84 32 01 00 00             je 086F46F8H

#38		
#39			(* THEN *)
#40		
#41				(* check_timer *)
#42				MOVE		false,check_timer.IN	{LNXT:15|-1|-1}
(*) BOOL
086F45C6  B8 00 00 00 00                mov eax, 00H
086F45CB  84 C0                         test al, al
086F45CD  0F 95 45 05                   setne 5[ebp]

#43				CAL		check_timer	{LNXT:15|17|-1}
(*) BOOL
086F45D1  50                            push eax
086F45D2  8B DD                         mov ebx, ebp
086F45D4  81 C3 01 00 00 00             add ebx, 1
086F45DA  E8 FA FE FF FF                call 086F44D9H ; $$CODE$$+17625
086F45DF  58                            pop eax

#44		
#45		
#46				(* IF o_val_open_R_FB^ AND NOT di_val_open_state_R_FB^ *)
#47				LD		di_val_open_state_R_FB^	{LNXT:17|-1|-1}
(*) UNDEF
086F45E0  8B 55 21                      mov edx, 33[ebp]
086F45E3  0F BF 02                      movsx eax, word ptr [edx]

#48				NOT	{LNXT:17|-1|-1}
(*) INT
086F45E6  66 F7 D0                      not ax

#49				AND		o_val_open_R_FB^	{LNXT:17|-1|-1}
(*) INT
086F45E9  8B 55 2D                      mov edx, 45[ebp]
086F45EC  33 C9                         xor ecx, ecx
086F45EE  8A 0A                         mov cl, [edx]
086F45F0  23 C1                         and eax, ecx

#50				JMPCN	$label3	{LNXT:17|18|21}
(-) INT
086F45F2  66 85 C0                      test ax, ax
086F45F5  90 74 20 90 90 90             je 086F4618H

#51		
#52				(* THEN *)
#53		
#54					(* Alarm_Val_FB^.0 := TRUE; *)
#55					MOVE		TRUE,Alarm_Val_FB^.0	{LNXT:18|21|-1}
(*) INT
086F45FB  B8 01 00 00 00                mov eax, 01H
086F4600  8B 55 29                      mov edx, 41[ebp]
086F4603  84 C0                         test al, al
086F4605  90 75 0C 90 90 90             jne 0000000FH@
086F460B  0F BA 32 00                   btr [edx], 0
086F460F  EB 07 90 90 90                jmp 00000009H@
086F4614  0F BA 2A 00                   bts [edx], 0

#56		
#57		$label3:
#58				(* END_IF *)
#59		
#60		
#61				(* IF o_val_close_R_FB^ AND NOT di_val_close_state_R_FB^ *)
#62				LD		di_val_close_state_R_FB^	{LNXT:21|-1|-1}
(*) UNDEF
086F4618  8B 55 25                      mov edx, 37[ebp]
086F461B  33 C0                         xor eax, eax
086F461D  8A 02                         mov al, [edx]

#63				NOT	{LNXT:21|-1|-1}
(*) BOOL
086F461F  84 C0                         test al, al
086F4621  0F 94 C0                      sete al

#64				AND		o_val_close_R_FB^	{LNXT:21|-1|-1}
(*) BOOL
086F4624  8B 55 31                      mov edx, 49[ebp]
086F4627  8B 55 31                      mov edx, 49[ebp]
086F462A  33 C9                         xor ecx, ecx
086F462C  8A 0A                         mov cl, [edx]
086F462E  23 C1                         and eax, ecx

#65				JMPCN	$label4	{LNXT:21|22|25}
(-) BOOL
086F4630  84 C0                         test al, al
086F4632  90 74 20 90 90 90             je 086F4655H

#66		
#67				(* THEN *)
#68		
#69					(* Alarm_Val_FB^.1 := TRUE; *)
#70					MOVE		TRUE,Alarm_Val_FB^.1	{LNXT:22|25|-1}
(*) BOOL
086F4638  B8 01 00 00 00                mov eax, 01H
086F463D  8B 55 29                      mov edx, 41[ebp]
086F4640  84 C0                         test al, al
086F4642  90 75 0C 90 90 90             jne 0000000FH@
086F4648  0F BA 32 01                   btr [edx], 1
086F464C  EB 07 90 90 90                jmp 00000009H@
086F4651  0F BA 2A 01                   bts [edx], 1

#71		
#72		$label4:
#73				(* END_IF *)
#74		
#75		
#76				(* IF o_val_open_fall_FB^ AND NOT di_val_open_state_fall_FB^ *)
#77				LD		di_val_open_state_fall_FB^	{LNXT:25|-1|-1}
(*) UNDEF
086F4655  8B 55 19                      mov edx, 25[ebp]
086F4658  0F BF 02                      movsx eax, word ptr [edx]

#78				NOT	{LNXT:25|-1|-1}
(*) INT
086F465B  66 F7 D0                      not ax

#79				AND		o_val_open_fall_FB^	{LNXT:25|-1|-1}
(*) INT
086F465E  8B 55 35                      mov edx, 53[ebp]
086F4661  33 C9                         xor ecx, ecx
086F4663  8A 0A                         mov cl, [edx]
086F4665  23 C1                         and eax, ecx

#80				JMPCN	$label5	{LNXT:25|26|29}
(-) INT
086F4667  66 85 C0                      test ax, ax
086F466A  90 74 20 90 90 90             je 086F468DH

#81		
#82				(* THEN *)
#83		
#84					(* Alarm_Val_FB^.2 := TRUE; *)
#85					MOVE		TRUE,Alarm_Val_FB^.2	{LNXT:26|29|-1}
(*) INT
086F4670  B8 01 00 00 00                mov eax, 01H
086F4675  8B 55 29                      mov edx, 41[ebp]
086F4678  84 C0                         test al, al
086F467A  90 75 0C 90 90 90             jne 0000000FH@
086F4680  0F BA 32 02                   btr [edx], 2
086F4684  EB 07 90 90 90                jmp 00000009H@
086F4689  0F BA 2A 02                   bts [edx], 2

#86		
#87		$label5:
#88				(* END_IF *)
#89		
#90		
#91				(* IF o_val_close_fall_FB^ AND NOT di_val_close_state_fall_FB^ *)
#92				LD		di_val_close_state_fall_FB^	{LNXT:29|-1|-1}
(*) UNDEF
086F468D  8B 55 1D                      mov edx, 29[ebp]
086F4690  0F BF 02                      movsx eax, word ptr [edx]

#93				NOT	{LNXT:29|-1|-1}
(*) INT
086F4693  66 F7 D0                      not ax

#94				AND		o_val_close_fall_FB^	{LNXT:29|-1|-1}
(*) INT
086F4696  8B 55 39                      mov edx, 57[ebp]
086F4699  33 C9                         xor ecx, ecx
086F469B  8A 0A                         mov cl, [edx]
086F469D  23 C1                         and eax, ecx

#95				JMPCN	$label6	{LNXT:29|30|34}
(-) INT
086F469F  66 85 C0                      test ax, ax
086F46A2  90 74 20 90 90 90             je 086F46C5H

#96		
#97				(* THEN *)
#98		
#99					(* Alarm_Val_FB^.3 := TRUE; *)
#100					MOVE		TRUE,Alarm_Val_FB^.3	{LNXT:30|34|-1}
(*) INT
086F46A8  B8 01 00 00 00                mov eax, 01H
086F46AD  8B 55 29                      mov edx, 41[ebp]
086F46B0  84 C0                         test al, al
086F46B2  90 75 0C 90 90 90             jne 0000000FH@
086F46B8  0F BA 32 03                   btr [edx], 3
086F46BC  EB 07 90 90 90                jmp 00000009H@
086F46C1  0F BA 2A 03                   bts [edx], 3

#101		
#102		$label6:
#103				(* END_IF *)
#104		
#105		
#106				(* IF Alarm_Val_FB^ > 0 *)
#107				LD		Alarm_Val_FB^	{LNXT:34|-1|-1}
(*) UNDEF
086F46C5  8B 55 29                      mov edx, 41[ebp]
086F46C8  33 C0                         xor eax, eax
086F46CA  66 8B 02                      mov ax, [edx]

#108				GT		0	{LNXT:34|-1|-1}
(*) WORD
086F46CD  3D 00 00 00 00                cmp eax, 0
086F46D2  0F 9F C0                      setg al
086F46D5  25 FF 00 00 00                and eax, 0FFh

#109				JMPCN	$label7	{LNXT:34|35|38}
(-) BOOL
086F46DA  84 C0                         test al, al
086F46DC  90 74 0E 90 90 90             je 086F46EDH

#110		
#111				(* THEN *)
#112		
#113					(* isOK := FALSE; *)
#114					MOVE		FALSE,isOK	{LNXT:35|38|-1}
(*) BOOL
086F46E2  B8 00 00 00 00                mov eax, 00H
086F46E7  84 C0                         test al, al
086F46E9  0F 95 45 18                   setne 24[ebp]

#115		
#116		$label7:
#117				(* END_IF *)
#118		
#119				(* is_check_done := TRUE; *)
#120				MOVE		TRUE,is_check_done	{LNXT:38|41|-1}
(*) BOOL
086F46ED  B8 01 00 00 00                mov eax, 01H
086F46F2  84 C0                         test al, al
086F46F4  0F 95 45 17                   setne 23[ebp]

#121		
#122		$label2:
#123			(* END_IF *)
#124		
#125			(* check_timer *)
#126			CAL		check_timer	{LNXT:41|-1|-1}
(*) BOOL
086F46F8  50                            push eax
086F46F9  8B DD                         mov ebx, ebp
086F46FB  81 C3 01 00 00 00             add ebx, 1
086F4701  E8 D3 FD FF FF                call 086F44D9H ; $$CODE$$+17625
086F4706  58                            pop eax

086F4707  5F                            pop edi
086F4708  5D                            pop ebp

086F4709  C3                            ret


Frame allocation (hex):

	0000 bit  0: VAR should_run_timer
	0001       : FB check_timer
	0017 bit  0: VAR is_check_done
	0018 bit  0: VAR isOK
	0019       : VAR di_val_open_state_fall_FB
	001D       : VAR di_val_close_state_fall_FB
	0021       : VAR di_val_open_state_R_FB
	0025       : VAR di_val_close_state_R_FB
	0029       : VAR Alarm_Val_FB
	002D       : VAR o_val_open_R_FB
	0031       : VAR o_val_close_R_FB
	0035       : VAR o_val_open_fall_FB
	0039       : VAR o_val_close_fall_FB
	003D       : VAR start_check

END_FUNCTION_BLOCK
**************************************************
	List function block: CheckWashAndStart
**************************************************

FUNCTION_BLOCK CheckWashAndStart

        VAR_IN_OUT
sv_washing_FB : BOOL^;
o_val_open_R_FB : BOOL^;
o_val_close_R_FB : BOOL^;
o_val_open_fall_FB : BOOL^;
o_val_close_fall_FB : BOOL^;
q_start_ats_FB : BOOL^;
ep_time_wash_FB : INT^;
i_val_state_FB : INT^;
di_val_open_state_fall_FB : INT^;
di_val_close_state_fall_FB : INT^;
di_val_open_state_R_FB : INT^;
di_val_close_state_R_FB : BOOL^;
Alarm_Val_FB : WORD^;
	END_VAR

        VAR_OUTPUT
is_running_wash : BOOL;
	END_VAR

        VAR
washing_timer : TON;	{ DE:"локальний FB таймера" }
onWash : BOOL;
checkAlarmVal : CheckAlarmVal;
valve_rising : BOOL;
prev_val_open_fall : BOOL;
prev_val_close_fall : BOOL;
prev_val_open_R : BOOL;
prev_val_close_R : BOOL;
finish_val_rising : BOOL;
	END_VAR

END_FUNCTION_BLOCK

086F470A  55                            push ebp
086F470B  8B EB                         mov ebp, ebx
086F470D  57                            push edi

#0		{SRC:CheckWashAndStart}
#1		(*$WAITSWITCH$*)
#2		
#3		
#4			(* IF sv_washing_FB^ and i_val_state_FB^=1 *)
#5			LD		i_val_state_FB^	{LNXT:1|-1|-1}
(*) UNDEF
086F470E  8B 95 83 00 00 00             mov edx, 131[ebp]
086F4714  0F BF 02                      movsx eax, word ptr [edx]

#6			EQ		1	{LNXT:1|-1|-1}
(*) INT
086F4717  3D 01 00 00 00                cmp eax, 1
086F471C  0F 94 C0                      sete al
086F471F  25 FF 00 00 00                and eax, 0FFh

#7			AND		sv_washing_FB^	{LNXT:1|-1|-1}
(*) BOOL
086F4724  8B 55 67                      mov edx, 103[ebp]
086F4727  8B 55 67                      mov edx, 103[ebp]
086F472A  33 C9                         xor ecx, ecx
086F472C  8A 0A                         mov cl, [edx]
086F472E  23 C1                         and eax, ecx

#8			JMPCN	$label0	{LNXT:1|2|4}
(-) BOOL
086F4730  84 C0                         test al, al
086F4732  90 74 13 90 90 90             je 086F4748H

#9		
#10			(* THEN *)
#11		
#12				(* onWash :=true; *)
#13				MOVE		true,onWash	{LNXT:2|7|-1}
(*) BOOL
086F4738  B8 01 00 00 00                mov eax, 01H
086F473D  84 C0                         test al, al
086F473F  0F 95 45 16                   setne 22[ebp]

#14				JMP		$label1	{LNXT:1|2|4}
(-) BOOL
086F4743  EB 0E 90 90 90                jmp 086F4753H

#15		$label0:
#16		
#17			(* ELSE *)
#18		
#19				(* onWash :=false; *)
#20				MOVE		false,onWash	{LNXT:4|7|-1}
(*) BOOL
086F4748  B8 00 00 00 00                mov eax, 00H
086F474D  84 C0                         test al, al
086F474F  0F 95 45 16                   setne 22[ebp]

#21		
#22		$label1:
#23			(* END_IF *)
#24		
#25		
#26			(* IF onWash *)
#27			LD		onWash	{LNXT:7|-1|-1}
(*) UNDEF
086F4753  33 C0                         xor eax, eax
086F4755  8A 45 16                      mov al, 22[ebp]

#28			JMPCN	$label2	{LNXT:7|10|53}
(-) BOOL
086F4758  84 C0                         test al, al
086F475A  0F 84 87 01 00 00             je 086F48E7H

#29		
#30			(* THEN *)
#31		
#32				(* is_running_wash :=true; *)
#33				MOVE		true,is_running_wash	{LNXT:10|12|-1}
(*) BOOL
086F4760  B8 01 00 00 00                mov eax, 01H
086F4765  84 C0                         test al, al
086F4767  0F 95 45 66                   setne 102[ebp]

#34		
#35				(* prev_val_open_fall:=o_val_open_fall_FB^; *)
#36				MOVE		o_val_open_fall_FB^,prev_val_open_fall	{LNXT:12|13|-1}
(*) BOOL
086F476B  8B 55 73                      mov edx, 115[ebp]
086F476E  33 C0                         xor eax, eax
086F4770  8A 02                         mov al, [edx]
086F4772  84 C0                         test al, al
086F4774  0F 95 45 61                   setne 97[ebp]

#37		
#38				(* prev_val_close_fall:=o_val_close_fall_FB^; *)
#39				MOVE		o_val_close_fall_FB^,prev_val_close_fall	{LNXT:13|14|-1}
(*) BOOL
086F4778  8B 55 77                      mov edx, 119[ebp]
086F477B  33 C0                         xor eax, eax
086F477D  8A 02                         mov al, [edx]
086F477F  84 C0                         test al, al
086F4781  0F 95 45 62                   setne 98[ebp]

#40		
#41				(* prev_val_open_R:=o_val_open_R_FB^; *)
#42				MOVE		o_val_open_R_FB^,prev_val_open_R	{LNXT:14|15|-1}
(*) BOOL
086F4785  8B 55 6B                      mov edx, 107[ebp]
086F4788  33 C0                         xor eax, eax
086F478A  8A 02                         mov al, [edx]
086F478C  84 C0                         test al, al
086F478E  0F 95 45 63                   setne 99[ebp]

#43		
#44				(* prev_val_close_R:=o_val_close_R_FB^; *)
#45				MOVE		o_val_close_R_FB^,prev_val_close_R	{LNXT:15|17|-1}
(*) BOOL
086F4792  8B 55 6F                      mov edx, 111[ebp]
086F4795  33 C0                         xor eax, eax
086F4797  8A 02                         mov al, [edx]
086F4799  84 C0                         test al, al
086F479B  0F 95 45 64                   setne 100[ebp]

#46		
#47				(* o_val_close_R_FB^:=true; *)
#48				MOVE		true,o_val_close_R_FB^	{LNXT:17|18|-1}
(*) BOOL
086F479F  B8 01 00 00 00                mov eax, 01H
086F47A4  8B 55 6F                      mov edx, 111[ebp]
086F47A7  84 C0                         test al, al
086F47A9  0F 95 02                      setne [edx]

#49		
#50				(* o_val_open_R_FB^:=false; *)
#51				MOVE		false,o_val_open_R_FB^	{LNXT:18|19|-1}
(*) BOOL
086F47AC  B8 00 00 00 00                mov eax, 00H
086F47B1  8B 55 6B                      mov edx, 107[ebp]
086F47B4  84 C0                         test al, al
086F47B6  0F 95 02                      setne [edx]

#52		
#53				(* o_val_open_fall_FB^:=true; *)
#54				MOVE		true,o_val_open_fall_FB^	{LNXT:19|20|-1}
(*) BOOL
086F47B9  B8 01 00 00 00                mov eax, 01H
086F47BE  8B 55 73                      mov edx, 115[ebp]
086F47C1  84 C0                         test al, al
086F47C3  0F 95 02                      setne [edx]

#55		
#56				(* o_val_close_fall_FB^:=false; *)
#57				MOVE		false,o_val_close_fall_FB^	{LNXT:20|22|-1}
(*) BOOL
086F47C6  B8 00 00 00 00                mov eax, 00H
086F47CB  8B 55 77                      mov edx, 119[ebp]
086F47CE  84 C0                         test al, al
086F47D0  0F 95 02                      setne [edx]

#58		
#59				(* valve_rising :=
#60		    (o_val_open_fall_FB^ AND NOT prev_val_open_fall) OR
#61			(o_val_close_fall_FB^ AND NOT prev_val_close_fall) OR
#62			(o_val_open_R_FB^ AND NOT prev_val_open_R) OR
#63			(o_val_close_R_FB^ AND NOT prev_val_close_R); *)
#64				LD		prev_val_close_R	{LNXT:22|30|-1}
(*) UNDEF
086F47D3  33 C0                         xor eax, eax
086F47D5  8A 45 64                      mov al, 100[ebp]

#65				NOT	{LNXT:22|30|-1}
(*) BOOL
086F47D8  84 C0                         test al, al
086F47DA  0F 94 C0                      sete al

#66				AND		o_val_close_R_FB^	{LNXT:22|30|-1}
(*) BOOL
086F47DD  8B 55 6F                      mov edx, 111[ebp]
086F47E0  8B 55 6F                      mov edx, 111[ebp]
086F47E3  33 C9                         xor ecx, ecx
086F47E5  8A 0A                         mov cl, [edx]
086F47E7  23 C1                         and eax, ecx

#67				OR(		prev_val_open_R	{LNXT:22|30|-1}
(*) BOOL
086F47E9  50                            push eax
086F47EA  33 C0                         xor eax, eax
086F47EC  8A 45 63                      mov al, 99[ebp]

#68				NOT	{LNXT:22|30|-1}
(*) BOOL
086F47EF  84 C0                         test al, al
086F47F1  0F 94 C0                      sete al

#69				AND		o_val_open_R_FB^	{LNXT:22|30|-1}
(*) BOOL
086F47F4  8B 55 6B                      mov edx, 107[ebp]
086F47F7  8B 55 6B                      mov edx, 107[ebp]
086F47FA  33 C9                         xor ecx, ecx
086F47FC  8A 0A                         mov cl, [edx]
086F47FE  23 C1                         and eax, ecx

#70				OR(		prev_val_close_fall	{LNXT:22|30|-1}
(*) BOOL
086F4800  50                            push eax
086F4801  33 C0                         xor eax, eax
086F4803  8A 45 62                      mov al, 98[ebp]

#71				NOT	{LNXT:22|30|-1}
(*) BOOL
086F4806  84 C0                         test al, al
086F4808  0F 94 C0                      sete al

#72				AND		o_val_close_fall_FB^	{LNXT:22|30|-1}
(*) BOOL
086F480B  8B 55 77                      mov edx, 119[ebp]
086F480E  8B 55 77                      mov edx, 119[ebp]
086F4811  33 C9                         xor ecx, ecx
086F4813  8A 0A                         mov cl, [edx]
086F4815  23 C1                         and eax, ecx

#73				OR(		prev_val_open_fall	{LNXT:22|30|-1}
(*) BOOL
086F4817  50                            push eax
086F4818  33 C0                         xor eax, eax
086F481A  8A 45 61                      mov al, 97[ebp]

#74				NOT	{LNXT:22|30|-1}
(*) BOOL
086F481D  84 C0                         test al, al
086F481F  0F 94 C0                      sete al

#75				AND		o_val_open_fall_FB^	{LNXT:22|30|-1}
(*) BOOL
086F4822  8B 55 73                      mov edx, 115[ebp]
086F4825  8B 55 73                      mov edx, 115[ebp]
086F4828  33 C9                         xor ecx, ecx
086F482A  8A 0A                         mov cl, [edx]
086F482C  23 C1                         and eax, ecx

#76				)	{LNXT:22|30|-1}
(*) BOOL
086F482E  8B C8                         mov ecx, eax
086F4830  58                            pop eax
086F4831  0B C1                         or eax, ecx

#77				)	{LNXT:22|30|-1}
(*) BOOL
086F4833  8B C8                         mov ecx, eax
086F4835  58                            pop eax
086F4836  0B C1                         or eax, ecx

#78				)	{LNXT:22|30|-1}
(*) BOOL
086F4838  8B C8                         mov ecx, eax
086F483A  58                            pop eax
086F483B  0B C1                         or eax, ecx

#79				ST		valve_rising	{LNXT:22|30|-1}
(*) BOOL
086F483D  84 C0                         test al, al
086F483F  0F 95 45 60                   setne 96[ebp]

#80		
#81				(* checkAlarmVal *)
#82				MOVE		di_val_open_state_fall_FB,checkAlarmVal.di_val_open_state_fall_FB	{LNXT:30|-1|-1}
(*) BOOL
086F4843  8B 95 87 00 00 00             mov edx, 135[ebp]
086F4849  8D 02                         lea eax, [edx]
086F484B  89 45 30                      mov 48[ebp], eax

#83				MOVE		di_val_close_state_fall_FB,checkAlarmVal.di_val_close_state_fall_FB	{LNXT:30|-1|-1}
(*) INT^
086F484E  8B 95 8B 00 00 00             mov edx, 139[ebp]
086F4854  8D 02                         lea eax, [edx]
086F4856  89 45 34                      mov 52[ebp], eax

#84				MOVE		di_val_open_state_R_FB,checkAlarmVal.di_val_open_state_R_FB	{LNXT:31|-1|-1}
(*) INT^
086F4859  8B 95 8F 00 00 00             mov edx, 143[ebp]
086F485F  8D 02                         lea eax, [edx]
086F4861  89 45 38                      mov 56[ebp], eax

#85				MOVE		di_val_close_state_R_FB,checkAlarmVal.di_val_close_state_R_FB	{LNXT:32|-1|-1}
(*) INT^
086F4864  8B 95 93 00 00 00             mov edx, 147[ebp]
086F486A  8D 02                         lea eax, [edx]
086F486C  89 45 3C                      mov 60[ebp], eax

#86				MOVE		Alarm_Val_FB,checkAlarmVal.Alarm_Val_FB	{LNXT:33|-1|-1}
(*) BOOL^
086F486F  8B 95 97 00 00 00             mov edx, 151[ebp]
086F4875  8D 02                         lea eax, [edx]
086F4877  89 45 40                      mov 64[ebp], eax

#87				MOVE		o_val_open_R_FB,checkAlarmVal.o_val_open_R_FB	{LNXT:34|-1|-1}
(*) WORD^
086F487A  8B 55 6B                      mov edx, 107[ebp]
086F487D  8D 02                         lea eax, [edx]
086F487F  89 45 44                      mov 68[ebp], eax

#88				MOVE		o_val_close_R_FB,checkAlarmVal.o_val_close_R_FB	{LNXT:35|-1|-1}
(*) BOOL^
086F4882  8B 55 6F                      mov edx, 111[ebp]
086F4885  8D 02                         lea eax, [edx]
086F4887  89 45 48                      mov 72[ebp], eax

#89				MOVE		o_val_open_fall_FB,checkAlarmVal.o_val_open_fall_FB	{LNXT:36|-1|-1}
(*) BOOL^
086F488A  8B 55 73                      mov edx, 115[ebp]
086F488D  8D 02                         lea eax, [edx]
086F488F  89 45 4C                      mov 76[ebp], eax

#90				MOVE		o_val_close_fall_FB,checkAlarmVal.o_val_close_fall_FB	{LNXT:37|-1|-1}
(*) BOOL^
086F4892  8B 55 77                      mov edx, 119[ebp]
086F4895  8D 02                         lea eax, [edx]
086F4897  89 45 50                      mov 80[ebp], eax

#91				MOVE		valve_rising,checkAlarmVal.start_check	{LNXT:38|-1|-1}
(*) BOOL^
086F489A  8D 45 60                      lea eax, 96[ebp]
086F489D  89 45 54                      mov 84[ebp], eax

#92				CAL		checkAlarmVal	{LNXT:30|43|-1}
(*) BOOL^
086F48A0  50                            push eax
086F48A1  8B DD                         mov ebx, ebp
086F48A3  81 C3 17 00 00 00             add ebx, 23
086F48A9  E8 B3 FC FF FF                call 086F4561H ; $$CODE$$+17761
086F48AE  58                            pop eax

#93		
#94		
#95				(* IF checkAlarmVal.is_check_done and checkAlarmVal.isOK *)
#96				LD		checkAlarmVal.is_check_done	{LNXT:43|-1|-1}
(*) UNDEF
086F48AF  33 C0                         xor eax, eax
086F48B1  8A 45 2E                      mov al, 46[ebp]

#97				AND		checkAlarmVal.isOK	{LNXT:43|-1|-1}
(*) BOOL
086F48B4  33 C9                         xor ecx, ecx
086F48B6  8A 4D 2F                      mov cl, 47[ebp]
086F48B9  23 C1                         and eax, ecx

#98				JMPCN	$label4	{LNXT:43|44|47}
(-) BOOL
086F48BB  84 C0                         test al, al
086F48BD  90 74 15 90 90 90             je 086F48D5H

#99		
#100				(* THEN *)
#101		
#102					(* q_start_ats_FB^:=true; *)
#103					MOVE		true,q_start_ats_FB^	{LNXT:44|57|-1}
(*) BOOL
086F48C3  B8 01 00 00 00                mov eax, 01H
086F48C8  8B 55 7B                      mov edx, 123[ebp]
086F48CB  84 C0                         test al, al
086F48CD  0F 95 02                      setne [edx]

#104					JMP		$label5	{LNXT:43|44|47}
(-) BOOL
086F48D0  EB 10 90 90 90                jmp 086F48E2H

#105		$label4:
#106		
#107				(* ELSE *)
#108		
#109					(* q_start_ats_FB^:=false; *)
#110					MOVE		false,q_start_ats_FB^	{LNXT:47|57|-1}
(*) BOOL
086F48D5  B8 00 00 00 00                mov eax, 00H
086F48DA  8B 55 7B                      mov edx, 123[ebp]
086F48DD  84 C0                         test al, al
086F48DF  0F 95 02                      setne [edx]

#111		
#112		$label5:
#113				(* END_IF *)
#114				JMP		$label3	{LNXT:7|10|53}
(-) BOOL
086F48E2  EB 10 90 90 90                jmp 086F48F4H

#115		$label2:
#116		
#117			(* ELSE *)
#118		
#119				(* q_start_ats_FB^:=true; *)
#120				MOVE		true,q_start_ats_FB^	{LNXT:53|57|-1}
(*) BOOL
086F48E7  B8 01 00 00 00                mov eax, 01H
086F48EC  8B 55 7B                      mov edx, 123[ebp]
086F48EF  84 C0                         test al, al
086F48F1  0F 95 02                      setne [edx]

#121		
#122		$label3:
#123			(* END_IF *)
#124		
#125		
#126			(* IF washing_timer.Q *)
#127			LD		washing_timer.Q	{LNXT:57|-1|-1}
(*) UNDEF
086F48F4  33 C0                         xor eax, eax
086F48F6  8A 45 09                      mov al, 9[ebp]

#128			JMPCN	$label6	{LNXT:57|60|93}
(-) BOOL
086F48F9  84 C0                         test al, al
086F48FB  0F 84 F0 00 00 00             je 086F49F1H

#129		
#130			(* THEN *)
#131		
#132				(* prev_val_open_fall:=o_val_open_fall_FB^; *)
#133				MOVE		o_val_open_fall_FB^,prev_val_open_fall	{LNXT:60|61|-1}
(*) BOOL
086F4901  8B 55 73                      mov edx, 115[ebp]
086F4904  33 C0                         xor eax, eax
086F4906  8A 02                         mov al, [edx]
086F4908  84 C0                         test al, al
086F490A  0F 95 45 61                   setne 97[ebp]

#134		
#135				(* prev_val_close_fall:=o_val_close_fall_FB^; *)
#136				MOVE		o_val_close_fall_FB^,prev_val_close_fall	{LNXT:61|62|-1}
(*) BOOL
086F490E  8B 55 77                      mov edx, 119[ebp]
086F4911  33 C0                         xor eax, eax
086F4913  8A 02                         mov al, [edx]
086F4915  84 C0                         test al, al
086F4917  0F 95 45 62                   setne 98[ebp]

#137		
#138				(* prev_val_open_R:=o_val_open_R_FB^; *)
#139				MOVE		o_val_open_R_FB^,prev_val_open_R	{LNXT:62|63|-1}
(*) BOOL
086F491B  8B 55 6B                      mov edx, 107[ebp]
086F491E  33 C0                         xor eax, eax
086F4920  8A 02                         mov al, [edx]
086F4922  84 C0                         test al, al
086F4924  0F 95 45 63                   setne 99[ebp]

#140		
#141				(* prev_val_close_R:=o_val_close_R_FB^; *)
#142				MOVE		o_val_close_R_FB^,prev_val_close_R	{LNXT:63|66|-1}
(*) BOOL
086F4928  8B 55 6F                      mov edx, 111[ebp]
086F492B  33 C0                         xor eax, eax
086F492D  8A 02                         mov al, [edx]
086F492F  84 C0                         test al, al
086F4931  0F 95 45 64                   setne 100[ebp]

#143		
#144				(* o_val_close_R_FB^:=false; *)
#145				MOVE		false,o_val_close_R_FB^	{LNXT:66|67|-1}
(*) BOOL
086F4935  B8 00 00 00 00                mov eax, 00H
086F493A  8B 55 6F                      mov edx, 111[ebp]
086F493D  84 C0                         test al, al
086F493F  0F 95 02                      setne [edx]

#146		
#147				(* o_val_open_fall_FB^:=false; *)
#148				MOVE		false,o_val_open_fall_FB^	{LNXT:67|69|-1}
(*) BOOL
086F4942  B8 00 00 00 00                mov eax, 00H
086F4947  8B 55 73                      mov edx, 115[ebp]
086F494A  84 C0                         test al, al
086F494C  0F 95 02                      setne [edx]

#149		
#150				(* o_val_open_R_FB^:=true; *)
#151				MOVE		true,o_val_open_R_FB^	{LNXT:69|70|-1}
(*) BOOL
086F494F  B8 01 00 00 00                mov eax, 01H
086F4954  8B 55 6B                      mov edx, 107[ebp]
086F4957  84 C0                         test al, al
086F4959  0F 95 02                      setne [edx]

#152		
#153				(* o_val_close_fall_FB^:=true; *)
#154				MOVE		true,o_val_close_fall_FB^	{LNXT:70|72|-1}
(*) BOOL
086F495C  B8 01 00 00 00                mov eax, 01H
086F4961  8B 55 77                      mov edx, 119[ebp]
086F4964  84 C0                         test al, al
086F4966  0F 95 02                      setne [edx]

#155		
#156				(* valve_rising :=
#157		    (o_val_open_fall_FB^ AND NOT prev_val_open_fall) OR
#158			(o_val_close_fall_FB^ AND NOT prev_val_close_fall) OR
#159			(o_val_open_R_FB^ AND NOT prev_val_open_R) OR
#160			(o_val_close_R_FB^ AND NOT prev_val_close_R); *)
#161				LD		prev_val_close_R	{LNXT:72|78|-1}
(*) UNDEF
086F4969  33 C0                         xor eax, eax
086F496B  8A 45 64                      mov al, 100[ebp]

#162				NOT	{LNXT:72|78|-1}
(*) BOOL
086F496E  84 C0                         test al, al
086F4970  0F 94 C0                      sete al

#163				AND		o_val_close_R_FB^	{LNXT:72|78|-1}
(*) BOOL
086F4973  8B 55 6F                      mov edx, 111[ebp]
086F4976  8B 55 6F                      mov edx, 111[ebp]
086F4979  33 C9                         xor ecx, ecx
086F497B  8A 0A                         mov cl, [edx]
086F497D  23 C1                         and eax, ecx

#164				OR(		prev_val_open_R	{LNXT:72|78|-1}
(*) BOOL
086F497F  50                            push eax
086F4980  33 C0                         xor eax, eax
086F4982  8A 45 63                      mov al, 99[ebp]

#165				NOT	{LNXT:72|78|-1}
(*) BOOL
086F4985  84 C0                         test al, al
086F4987  0F 94 C0                      sete al

#166				AND		o_val_open_R_FB^	{LNXT:72|78|-1}
(*) BOOL
086F498A  8B 55 6B                      mov edx, 107[ebp]
086F498D  8B 55 6B                      mov edx, 107[ebp]
086F4990  33 C9                         xor ecx, ecx
086F4992  8A 0A                         mov cl, [edx]
086F4994  23 C1                         and eax, ecx

#167				OR(		prev_val_close_fall	{LNXT:72|78|-1}
(*) BOOL
086F4996  50                            push eax
086F4997  33 C0                         xor eax, eax
086F4999  8A 45 62                      mov al, 98[ebp]

#168				NOT	{LNXT:72|78|-1}
(*) BOOL
086F499C  84 C0                         test al, al
086F499E  0F 94 C0                      sete al

#169				AND		o_val_close_fall_FB^	{LNXT:72|78|-1}
(*) BOOL
086F49A1  8B 55 77                      mov edx, 119[ebp]
086F49A4  8B 55 77                      mov edx, 119[ebp]
086F49A7  33 C9                         xor ecx, ecx
086F49A9  8A 0A                         mov cl, [edx]
086F49AB  23 C1                         and eax, ecx

#170				OR(		prev_val_open_fall	{LNXT:72|78|-1}
(*) BOOL
086F49AD  50                            push eax
086F49AE  33 C0                         xor eax, eax
086F49B0  8A 45 61                      mov al, 97[ebp]

#171				NOT	{LNXT:72|78|-1}
(*) BOOL
086F49B3  84 C0                         test al, al
086F49B5  0F 94 C0                      sete al

#172				AND		o_val_open_fall_FB^	{LNXT:72|78|-1}
(*) BOOL
086F49B8  8B 55 73                      mov edx, 115[ebp]
086F49BB  8B 55 73                      mov edx, 115[ebp]
086F49BE  33 C9                         xor ecx, ecx
086F49C0  8A 0A                         mov cl, [edx]
086F49C2  23 C1                         and eax, ecx

#173				)	{LNXT:72|78|-1}
(*) BOOL
086F49C4  8B C8                         mov ecx, eax
086F49C6  58                            pop eax
086F49C7  0B C1                         or eax, ecx

#174				)	{LNXT:72|78|-1}
(*) BOOL
086F49C9  8B C8                         mov ecx, eax
086F49CB  58                            pop eax
086F49CC  0B C1                         or eax, ecx

#175				)	{LNXT:72|78|-1}
(*) BOOL
086F49CE  8B C8                         mov ecx, eax
086F49D0  58                            pop eax
086F49D1  0B C1                         or eax, ecx

#176				ST		valve_rising	{LNXT:72|78|-1}
(*) BOOL
086F49D3  84 C0                         test al, al
086F49D5  0F 95 45 60                   setne 96[ebp]

#177		
#178		
#179				(* IF valve_rising *)
#180				LD		valve_rising	{LNXT:78|-1|-1}
(*) UNDEF
086F49D9  33 C0                         xor eax, eax
086F49DB  8A 45 60                      mov al, 96[ebp]

#181				JMPCN	$label7	{LNXT:78|79|93}
(-) BOOL
086F49DE  84 C0                         test al, al
086F49E0  90 74 0E 90 90 90             je 086F49F1H

#182		
#183				(* THEN *)
#184		
#185					(* finish_val_rising :=true; *)
#186					MOVE		true,finish_val_rising	{LNXT:79|93|-1}
(*) BOOL
086F49E6  B8 01 00 00 00                mov eax, 01H
086F49EB  84 C0                         test al, al
086F49ED  0F 95 45 65                   setne 101[ebp]

#187		
#188		$label7:
#189				(* END_IF *)
#190		
#191		$label6:
#192			(* END_IF *)
#193		
#194		
#195			(* IF finish_val_rising *)
#196			LD		finish_val_rising	{LNXT:93|-1|-1}
(*) UNDEF
086F49F1  33 C0                         xor eax, eax
086F49F3  8A 45 65                      mov al, 101[ebp]

#197			JMPCN	$label8	{LNXT:93|94|98}
(-) BOOL
086F49F6  84 C0                         test al, al
086F49F8  90 74 1B 90 90 90             je 086F4A16H

#198		
#199			(* THEN *)
#200		
#201				(* sv_washing_FB^:=false; *)
#202				MOVE		false,sv_washing_FB^	{LNXT:94|95|-1}
(*) BOOL
086F49FE  B8 00 00 00 00                mov eax, 00H
086F4A03  8B 55 67                      mov edx, 103[ebp]
086F4A06  84 C0                         test al, al
086F4A08  0F 95 02                      setne [edx]

#203		
#204				(* onWash :=false; *)
#205				MOVE		false,onWash	{LNXT:95|98|-1}
(*) BOOL
086F4A0B  B8 00 00 00 00                mov eax, 00H
086F4A10  84 C0                         test al, al
086F4A12  0F 95 45 16                   setne 22[ebp]

#206		
#207		$label8:
#208			(* END_IF *)
#209		
#210		
#211			(* IF checkAlarmVal.check_timer.Q *)
#212			LD		checkAlarmVal.check_timer.Q	{LNXT:98|-1|-1}
(*) UNDEF
086F4A16  33 C0                         xor eax, eax
086F4A18  8A 45 21                      mov al, 33[ebp]

#213			JMPCN	$label9	{LNXT:98|100|106}
(-) BOOL
086F4A1B  84 C0                         test al, al
086F4A1D  90 74 0E 90 90 90             je 086F4A2EH

#214		
#215			(* THEN *)
#216		
#217				(* is_running_wash :=false; *)
#218				MOVE		false,is_running_wash	{LNXT:100|106|-1}
(*) BOOL
086F4A23  B8 00 00 00 00                mov eax, 00H
086F4A28  84 C0                         test al, al
086F4A2A  0F 95 45 66                   setne 102[ebp]

#219		
#220		$label9:
#221			(* END_IF *)
#222		
#223			(* checkAlarmVal *)
#224			MOVE		di_val_open_state_fall_FB,checkAlarmVal.di_val_open_state_fall_FB	{LNXT:106|-1|-1}
(*) BOOL
086F4A2E  8B 95 87 00 00 00             mov edx, 135[ebp]
086F4A34  8D 02                         lea eax, [edx]
086F4A36  89 45 30                      mov 48[ebp], eax

#225			MOVE		di_val_close_state_fall_FB,checkAlarmVal.di_val_close_state_fall_FB	{LNXT:106|-1|-1}
(*) INT^
086F4A39  8B 95 8B 00 00 00             mov edx, 139[ebp]
086F4A3F  8D 02                         lea eax, [edx]
086F4A41  89 45 34                      mov 52[ebp], eax

#226			MOVE		di_val_open_state_R_FB,checkAlarmVal.di_val_open_state_R_FB	{LNXT:107|-1|-1}
(*) INT^
086F4A44  8B 95 8F 00 00 00             mov edx, 143[ebp]
086F4A4A  8D 02                         lea eax, [edx]
086F4A4C  89 45 38                      mov 56[ebp], eax

#227			MOVE		di_val_close_state_R_FB,checkAlarmVal.di_val_close_state_R_FB	{LNXT:108|-1|-1}
(*) INT^
086F4A4F  8B 95 93 00 00 00             mov edx, 147[ebp]
086F4A55  8D 02                         lea eax, [edx]
086F4A57  89 45 3C                      mov 60[ebp], eax

#228			MOVE		Alarm_Val_FB,checkAlarmVal.Alarm_Val_FB	{LNXT:109|-1|-1}
(*) BOOL^
086F4A5A  8B 95 97 00 00 00             mov edx, 151[ebp]
086F4A60  8D 02                         lea eax, [edx]
086F4A62  89 45 40                      mov 64[ebp], eax

#229			MOVE		o_val_open_R_FB,checkAlarmVal.o_val_open_R_FB	{LNXT:110|-1|-1}
(*) WORD^
086F4A65  8B 55 6B                      mov edx, 107[ebp]
086F4A68  8D 02                         lea eax, [edx]
086F4A6A  89 45 44                      mov 68[ebp], eax

#230			MOVE		o_val_close_R_FB,checkAlarmVal.o_val_close_R_FB	{LNXT:111|-1|-1}
(*) BOOL^
086F4A6D  8B 55 6F                      mov edx, 111[ebp]
086F4A70  8D 02                         lea eax, [edx]
086F4A72  89 45 48                      mov 72[ebp], eax

#231			MOVE		o_val_open_fall_FB,checkAlarmVal.o_val_open_fall_FB	{LNXT:112|-1|-1}
(*) BOOL^
086F4A75  8B 55 73                      mov edx, 115[ebp]
086F4A78  8D 02                         lea eax, [edx]
086F4A7A  89 45 4C                      mov 76[ebp], eax

#232			MOVE		o_val_close_fall_FB,checkAlarmVal.o_val_close_fall_FB	{LNXT:113|-1|-1}
(*) BOOL^
086F4A7D  8B 55 77                      mov edx, 119[ebp]
086F4A80  8D 02                         lea eax, [edx]
086F4A82  89 45 50                      mov 80[ebp], eax

#233			MOVE		finish_val_rising,checkAlarmVal.start_check	{LNXT:114|-1|-1}
(*) BOOL^
086F4A85  8D 45 65                      lea eax, 101[ebp]
086F4A88  89 45 54                      mov 84[ebp], eax

#234			CAL		checkAlarmVal	{LNXT:106|117|-1}
(*) BOOL^
086F4A8B  50                            push eax
086F4A8C  8B DD                         mov ebx, ebp
086F4A8E  81 C3 17 00 00 00             add ebx, 23
086F4A94  E8 C8 FA FF FF                call 086F4561H ; $$CODE$$+17761
086F4A99  58                            pop eax

#235		
#236		
#237			(* IF finish_val_rising *)
#238			LD		finish_val_rising	{LNXT:117|-1|-1}
(*) UNDEF
086F4A9A  33 C0                         xor eax, eax
086F4A9C  8A 45 65                      mov al, 101[ebp]

#239			JMPCN	$label10	{LNXT:117|118|121}
(-) BOOL
086F4A9F  84 C0                         test al, al
086F4AA1  90 74 0E 90 90 90             je 086F4AB2H

#240		
#241			(* THEN *)
#242		
#243				(* finish_val_rising:=false; *)
#244				MOVE		false,finish_val_rising	{LNXT:118|121|-1}
(*) BOOL
086F4AA7  B8 00 00 00 00                mov eax, 00H
086F4AAC  84 C0                         test al, al
086F4AAE  0F 95 45 65                   setne 101[ebp]

#245		
#246		$label10:
#247			(* END_IF *)
#248		
#249			(* washing_timer *)
#250			LD		onWash	{LNXT:121|-1|-1}
(*) UNDEF
086F4AB2  33 C0                         xor eax, eax
086F4AB4  8A 45 16                      mov al, 22[ebp]

#251			AND		q_start_ats_FB^	{LNXT:121|-1|-1}
(*) BOOL
086F4AB7  8B 55 7B                      mov edx, 123[ebp]
086F4ABA  8B 55 7B                      mov edx, 123[ebp]
086F4ABD  33 C9                         xor ecx, ecx
086F4ABF  8A 0A                         mov cl, [edx]
086F4AC1  23 C1                         and eax, ecx

#252			ST		washing_timer.IN	{LNXT:121|-1|-1}
(*) BOOL
086F4AC3  84 C0                         test al, al
086F4AC5  0F 95 45 04                   setne 4[ebp]

#253			MOVE		ep_time_wash_FB^,washing_timer.PT	{LNXT:121|-1|-1}
(*) BOOL
086F4AC9  8B 55 7F                      mov edx, 127[ebp]
086F4ACC  0F BF 02                      movsx eax, word ptr [edx]
086F4ACF  89 45 05                      mov 5[ebp], eax

#254			CAL		washing_timer	{LNXT:121|-1|-1}
(*) INT
086F4AD2  50                            push eax
086F4AD3  8B DD                         mov ebx, ebp
086F4AD5  E8 FF F9 FF FF                call 086F44D9H ; $$CODE$$+17625
086F4ADA  58                            pop eax

086F4ADB  5F                            pop edi
086F4ADC  5D                            pop ebp

086F4ADD  C3                            ret


Frame allocation (hex):

	0000       : FB washing_timer
	0016 bit  0: VAR onWash
	0017       : FB checkAlarmVal
	0060 bit  0: VAR valve_rising
	0061 bit  0: VAR prev_val_open_fall
	0062 bit  0: VAR prev_val_close_fall
	0063 bit  0: VAR prev_val_open_R
	0064 bit  0: VAR prev_val_close_R
	0065 bit  0: VAR finish_val_rising
	0066 bit  0: VAR is_running_wash
	0067       : VAR sv_washing_FB
	006B       : VAR o_val_open_R_FB
	006F       : VAR o_val_close_R_FB
	0073       : VAR o_val_open_fall_FB
	0077       : VAR o_val_close_fall_FB
	007B       : VAR q_start_ats_FB
	007F       : VAR ep_time_wash_FB
	0083       : VAR i_val_state_FB
	0087       : VAR di_val_open_state_fall_FB
	008B       : VAR di_val_close_state_fall_FB
	008F       : VAR di_val_open_state_R_FB
	0093       : VAR di_val_close_state_R_FB
	0097       : VAR Alarm_Val_FB

END_FUNCTION_BLOCK
**************************************************
	List program: ATS_mdb
**************************************************

PROGRAM ATS_mdb

        VAR
res_eta_lcr : UINT;
resp_eta_lcr : ARRAY[0..3] OF INT;
res : INT;
xTON : TON;
	END_VAR

END_PROGRAM

086F4AE0  55                            push ebp
086F4AE1  8B EC                         mov ebp, esp
086F4AE3  60                            pushad

#0		{SRC:ATS_mdb}
#1		(*$WAITSWITCH$*)
#2		
#3			(* res := sysMbMRTU_FC03(	addr := 1, 
#4											base := 257, // 256
#5											no := 4, 
#6											object := ADR(resp_eta_lcr), 
#7											timeout := 200); *)
#8			ADR		resp_eta_lcr	{LNXT:2|8|-1}
(*) UDINT
086F4AE4  B8 CC CC CC CC                mov eax, CCCCCCCCH ; $$DATA$$+12

#9			ST		$$TMP0	{LNXT:2|8|-1}
(*) @INT
086F4AE9  89 05 CC CC CC CC             mov [CCCCCCCCH], eax ; $$DATA$$+408

#10			LDP0		1	{LNXT:2|8|-1}
(*) @INT
#11			sysMbMRTU_FC03		257, 4, $$TMP0, 200	{LNXT:2|8|-1}
(*) @INT
086F4AEF  68 C8 00 00 00                push 200
086F4AF4  FF 35 CC CC CC CC             push [CCCCCCCCH] ; $$DATA$$+408
086F4AFA  68 04 00 00 00                push 4
086F4AFF  68 01 01 00 00                push 257
086F4B04  68 01 00 00 00                push 1
086F4B09  B9 CC CC CC CC                mov ecx, CCCCCCCCH ; sysMbMRTU_FC03
086F4B0E  FF D1                         call ecx
086F4B10  81 C4 14 00 00 00             add esp, 20

#12			ST		res	{LNXT:2|8|-1}
(*) UINT
086F4B16  66 89 05 CC CC CC CC          mov [CCCCCCCCH], ax ; $$DATA$$+24

#13		
#14			(* ATS22_DUT.Ready 	:= to_bool(resp_eta_lcr[0] And 16#01); *)
#15			LD		resp_eta_lcr[0]	{LNXT:8|9|-1}
(*) UNDEF
086F4B1D  0F BF 05 CC CC CC CC          movsx eax, word ptr [CCCCCCCCH] ; $$DATA$$+12

#16			AND		16#01	{LNXT:8|9|-1}
(*) INT
086F4B24  25 01 00 00 00                and eax, 00000001H

#17			to_bool	{LNXT:8|9|-1}
(*) INT
086F4B29  66 85 C0                      test ax, ax
086F4B2C  0F 95 C0                      setne al

#18			ST		ATS22_DUT.Ready	{LNXT:8|9|-1}
(*) BOOL
086F4B2F  84 C0                         test al, al
086F4B31  0F 95 05 CC CC CC CC          setne [CCCCCCCCH] ; $$DATA$$+26

#19		
#20			(* ATS22_DUT.On 		:= to_bool(resp_eta_lcr[0] And 16#02); *)
#21			LD		resp_eta_lcr[0]	{LNXT:9|10|-1}
(*) UNDEF
086F4B38  0F BF 05 CC CC CC CC          movsx eax, word ptr [CCCCCCCCH] ; $$DATA$$+12

#22			AND		16#02	{LNXT:9|10|-1}
(*) INT
086F4B3F  25 02 00 00 00                and eax, 00000002H

#23			to_bool	{LNXT:9|10|-1}
(*) INT
086F4B44  66 85 C0                      test ax, ax
086F4B47  0F 95 C0                      setne al

#24			ST		ATS22_DUT.On	{LNXT:9|10|-1}
(*) BOOL
086F4B4A  84 C0                         test al, al
086F4B4C  0F 95 05 CC CC CC CC          setne [CCCCCCCCH] ; $$DATA$$+27

#25		
#26			(* ATS22_DUT.Trip 		:= to_bool(resp_eta_lcr[0] And 16#04); *)
#27			LD		resp_eta_lcr[0]	{LNXT:10|11|-1}
(*) UNDEF
086F4B53  0F BF 05 CC CC CC CC          movsx eax, word ptr [CCCCCCCCH] ; $$DATA$$+12

#28			AND		16#04	{LNXT:10|11|-1}
(*) INT
086F4B5A  25 04 00 00 00                and eax, 00000004H

#29			to_bool	{LNXT:10|11|-1}
(*) INT
086F4B5F  66 85 C0                      test ax, ax
086F4B62  0F 95 C0                      setne al

#30			ST		ATS22_DUT.Trip	{LNXT:10|11|-1}
(*) BOOL
086F4B65  84 C0                         test al, al
086F4B67  0F 95 05 CC CC CC CC          setne [CCCCCCCCH] ; $$DATA$$+28

#31		
#32			(* ATS22_DUT.Warning 	:= to_bool(resp_eta_lcr[0] And 16#08); *)
#33			LD		resp_eta_lcr[0]	{LNXT:11|12|-1}
(*) UNDEF
086F4B6E  0F BF 05 CC CC CC CC          movsx eax, word ptr [CCCCCCCCH] ; $$DATA$$+12

#34			AND		16#08	{LNXT:11|12|-1}
(*) INT
086F4B75  25 08 00 00 00                and eax, 00000008H

#35			to_bool	{LNXT:11|12|-1}
(*) INT
086F4B7A  66 85 C0                      test ax, ax
086F4B7D  0F 95 C0                      setne al

#36			ST		ATS22_DUT.Warning	{LNXT:11|12|-1}
(*) BOOL
086F4B80  84 C0                         test al, al
086F4B82  0F 95 05 CC CC CC CC          setne [CCCCCCCCH] ; $$DATA$$+29

#37		
#38			(* ATS22_DUT.LI3 		:= to_bool(resp_eta_lcr[0] And 16#20); *)
#39			LD		resp_eta_lcr[0]	{LNXT:12|13|-1}
(*) UNDEF
086F4B89  0F BF 05 CC CC CC CC          movsx eax, word ptr [CCCCCCCCH] ; $$DATA$$+12

#40			AND		16#20	{LNXT:12|13|-1}
(*) INT
086F4B90  25 20 00 00 00                and eax, 00000020H

#41			to_bool	{LNXT:12|13|-1}
(*) INT
086F4B95  66 85 C0                      test ax, ax
086F4B98  0F 95 C0                      setne al

#42			ST		ATS22_DUT.LI3	{LNXT:12|13|-1}
(*) BOOL
086F4B9B  84 C0                         test al, al
086F4B9D  0F 95 05 CC CC CC CC          setne [CCCCCCCCH] ; $$DATA$$+30

#43		
#44			(* ATS22_DUT.LI2 		:= to_bool(resp_eta_lcr[0] And 16#40); *)
#45			LD		resp_eta_lcr[0]	{LNXT:13|14|-1}
(*) UNDEF
086F4BA4  0F BF 05 CC CC CC CC          movsx eax, word ptr [CCCCCCCCH] ; $$DATA$$+12

#46			AND		16#40	{LNXT:13|14|-1}
(*) INT
086F4BAB  25 40 00 00 00                and eax, 00000040H

#47			to_bool	{LNXT:13|14|-1}
(*) INT
086F4BB0  66 85 C0                      test ax, ax
086F4BB3  0F 95 C0                      setne al

#48			ST		ATS22_DUT.LI2	{LNXT:13|14|-1}
(*) BOOL
086F4BB6  84 C0                         test al, al
086F4BB8  0F 95 05 CC CC CC CC          setne [CCCCCCCCH] ; $$DATA$$+31

#49		
#50			(* ATS22_DUT.LI1 		:= to_bool(resp_eta_lcr[0] And 16#80); *)
#51			LD		resp_eta_lcr[0]	{LNXT:14|17|-1}
(*) UNDEF
086F4BBF  0F BF 05 CC CC CC CC          movsx eax, word ptr [CCCCCCCCH] ; $$DATA$$+12

#52			AND		16#80	{LNXT:14|17|-1}
(*) INT
086F4BC6  25 80 00 00 00                and eax, 00000080H

#53			to_bool	{LNXT:14|17|-1}
(*) INT
086F4BCB  66 85 C0                      test ax, ax
086F4BCE  0F 95 C0                      setne al

#54			ST		ATS22_DUT.LI1	{LNXT:14|17|-1}
(*) BOOL
086F4BD1  84 C0                         test al, al
086F4BD3  0F 95 05 CC CC CC CC          setne [CCCCCCCCH] ; $$DATA$$+32

#55		
#56			(* ATS_State_bits.0 := ATS22_DUT.Ready; *)
#57			MOVE		ATS22_DUT.Ready,ATS_State_bits.0	{LNXT:17|18|-1}
(*) BOOL
086F4BDA  33 C0                         xor eax, eax
086F4BDC  8A 05 CC CC CC CC             mov al, [CCCCCCCCH] ; $$DATA$$+26
086F4BE2  84 C0                         test al, al
086F4BE4  90 75 11 90 90 90             jne 00000014H@
086F4BEA  66 0F BA 35 CC CC CC CC 00    btr word ptr [CCCCCCCCH], 0 ; %M110+16
086F4BF3  EB 0C 90 90 90                jmp 0000000EH@
086F4BF8  66 0F BA 2D CC CC CC CC 00    bts word ptr [CCCCCCCCH], 0 ; %M110+16

#58		
#59			(* ATS_State_bits.1 := ATS22_DUT.On And i_run_ats; *)
#60			LD		ATS22_DUT.On	{LNXT:18|19|-1}
(*) UNDEF
086F4C01  33 C0                         xor eax, eax
086F4C03  8A 05 CC CC CC CC             mov al, [CCCCCCCCH] ; $$DATA$$+27

#61			AND		i_run_ats	{LNXT:18|19|-1}
(*) BOOL
086F4C09  33 C9                         xor ecx, ecx
086F4C0B  8A 0D CC CC CC CC             mov cl, [CCCCCCCCH] ; $$DATA$$+412
086F4C11  23 C1                         and eax, ecx

#62			ST		ATS_State_bits.1	{LNXT:18|19|-1}
(*) BOOL
086F4C13  84 C0                         test al, al
086F4C15  90 75 11 90 90 90             jne 00000014H@
086F4C1B  66 0F BA 35 CC CC CC CC 01    btr word ptr [CCCCCCCCH], 1 ; %M110+16
086F4C24  EB 0C 90 90 90                jmp 0000000EH@
086F4C29  66 0F BA 2D CC CC CC CC 01    bts word ptr [CCCCCCCCH], 1 ; %M110+16

#63		
#64			(* ATS_State_bits.2 := ATS22_DUT.Trip Or Not i_no_alm_ats ; *)
#65			LD		i_no_alm_ats	{LNXT:19|20|-1}
(*) UNDEF
086F4C32  33 C0                         xor eax, eax
086F4C34  8A 05 CC CC CC CC             mov al, [CCCCCCCCH] ; $$DATA$$+413

#66			NOT	{LNXT:19|20|-1}
(*) BOOL
086F4C3A  84 C0                         test al, al
086F4C3C  0F 94 C0                      sete al

#67			OR		ATS22_DUT.Trip	{LNXT:19|20|-1}
(*) BOOL
086F4C3F  33 C9                         xor ecx, ecx
086F4C41  8A 0D CC CC CC CC             mov cl, [CCCCCCCCH] ; $$DATA$$+28
086F4C47  0B C1                         or eax, ecx

#68			ST		ATS_State_bits.2	{LNXT:19|20|-1}
(*) BOOL
086F4C49  84 C0                         test al, al
086F4C4B  90 75 11 90 90 90             jne 00000014H@
086F4C51  66 0F BA 35 CC CC CC CC 02    btr word ptr [CCCCCCCCH], 2 ; %M110+16
086F4C5A  EB 0C 90 90 90                jmp 0000000EH@
086F4C5F  66 0F BA 2D CC CC CC CC 02    bts word ptr [CCCCCCCCH], 2 ; %M110+16

#69		
#70			(* ATS_State_bits.3 := ATS22_DUT.Warning; *)
#71			MOVE		ATS22_DUT.Warning,ATS_State_bits.3	{LNXT:20|21|-1}
(*) BOOL
086F4C68  33 C0                         xor eax, eax
086F4C6A  8A 05 CC CC CC CC             mov al, [CCCCCCCCH] ; $$DATA$$+29
086F4C70  84 C0                         test al, al
086F4C72  90 75 11 90 90 90             jne 00000014H@
086F4C78  66 0F BA 35 CC CC CC CC 03    btr word ptr [CCCCCCCCH], 3 ; %M110+16
086F4C81  EB 0C 90 90 90                jmp 0000000EH@
086F4C86  66 0F BA 2D CC CC CC CC 03    bts word ptr [CCCCCCCCH], 3 ; %M110+16

#72		
#73			(* ATS_State_bits.4 := ATS22_DUT.Local; *)
#74			MOVE		ATS22_DUT.Local,ATS_State_bits.4	{LNXT:21|22|-1}
(*) BOOL
086F4C8F  33 C0                         xor eax, eax
086F4C91  8A 05 CC CC CC CC             mov al, [CCCCCCCCH] ; $$DATA$$+34
086F4C97  84 C0                         test al, al
086F4C99  90 75 11 90 90 90             jne 00000014H@
086F4C9F  66 0F BA 35 CC CC CC CC 04    btr word ptr [CCCCCCCCH], 4 ; %M110+16
086F4CA8  EB 0C 90 90 90                jmp 0000000EH@
086F4CAD  66 0F BA 2D CC CC CC CC 04    bts word ptr [CCCCCCCCH], 4 ; %M110+16

#75		
#76			(* ATS_State_bits.5 := ATS22_DUT.Ramping; *)
#77			MOVE		ATS22_DUT.Ramping,ATS_State_bits.5	{LNXT:22|23|-1}
(*) BOOL
086F4CB6  33 C0                         xor eax, eax
086F4CB8  8A 05 CC CC CC CC             mov al, [CCCCCCCCH] ; $$DATA$$+35
086F4CBE  84 C0                         test al, al
086F4CC0  90 75 11 90 90 90             jne 00000014H@
086F4CC6  66 0F BA 35 CC CC CC CC 05    btr word ptr [CCCCCCCCH], 5 ; %M110+16
086F4CCF  EB 0C 90 90 90                jmp 0000000EH@
086F4CD4  66 0F BA 2D CC CC CC CC 05    bts word ptr [CCCCCCCCH], 5 ; %M110+16

#78		
#79			(* ATS_State_bits.6 := ATS22_DUT.LI1; *)
#80			MOVE		ATS22_DUT.LI1,ATS_State_bits.6	{LNXT:23|24|-1}
(*) BOOL
086F4CDD  33 C0                         xor eax, eax
086F4CDF  8A 05 CC CC CC CC             mov al, [CCCCCCCCH] ; $$DATA$$+32
086F4CE5  84 C0                         test al, al
086F4CE7  90 75 11 90 90 90             jne 00000014H@
086F4CED  66 0F BA 35 CC CC CC CC 06    btr word ptr [CCCCCCCCH], 6 ; %M110+16
086F4CF6  EB 0C 90 90 90                jmp 0000000EH@
086F4CFB  66 0F BA 2D CC CC CC CC 06    bts word ptr [CCCCCCCCH], 6 ; %M110+16

#81		
#82			(* ATS_State_bits.7 := ATS22_DUT.LI2; *)
#83			MOVE		ATS22_DUT.LI2,ATS_State_bits.7	{LNXT:24|25|-1}
(*) BOOL
086F4D04  33 C0                         xor eax, eax
086F4D06  8A 05 CC CC CC CC             mov al, [CCCCCCCCH] ; $$DATA$$+31
086F4D0C  84 C0                         test al, al
086F4D0E  90 75 11 90 90 90             jne 00000014H@
086F4D14  66 0F BA 35 CC CC CC CC 07    btr word ptr [CCCCCCCCH], 7 ; %M110+16
086F4D1D  EB 0C 90 90 90                jmp 0000000EH@
086F4D22  66 0F BA 2D CC CC CC CC 07    bts word ptr [CCCCCCCCH], 7 ; %M110+16

#84		
#85			(* ATS_State_bits.8 := ATS22_DUT.LI3; *)
#86			MOVE		ATS22_DUT.LI3,ATS_State_bits.8	{LNXT:25|28|-1}
(*) BOOL
086F4D2B  33 C0                         xor eax, eax
086F4D2D  8A 05 CC CC CC CC             mov al, [CCCCCCCCH] ; $$DATA$$+30
086F4D33  84 C0                         test al, al
086F4D35  90 75 11 90 90 90             jne 00000014H@
086F4D3B  66 0F BA 35 CC CC CC CC 08    btr word ptr [CCCCCCCCH], 8 ; %M110+16
086F4D44  EB 0C 90 90 90                jmp 0000000EH@
086F4D49  66 0F BA 2D CC CC CC CC 08    bts word ptr [CCCCCCCCH], 8 ; %M110+16

#87		
#88			(* ATS_State_bits.9 := i_pb_loc; *)
#89			MOVE		i_pb_loc,ATS_State_bits.9	{LNXT:28|29|-1}
(*) BOOL
086F4D52  0F BF 05 CC CC CC CC          movsx eax, word ptr [CCCCCCCCH] ; $$DATA$$+414
086F4D59  66 85 C0                      test ax, ax
086F4D5C  90 75 11 90 90 90             jne 00000014H@
086F4D62  66 0F BA 35 CC CC CC CC 09    btr word ptr [CCCCCCCCH], 9 ; %M110+16
086F4D6B  EB 0C 90 90 90                jmp 0000000EH@
086F4D70  66 0F BA 2D CC CC CC CC 09    bts word ptr [CCCCCCCCH], 9 ; %M110+16

#90		
#91			(* ATS_State_bits.10 := i_pb_rem; *)
#92			MOVE		i_pb_rem,ATS_State_bits.10	{LNXT:29|31|-1}
(*) INT
086F4D79  0F BF 05 CC CC CC CC          movsx eax, word ptr [CCCCCCCCH] ; $$DATA$$+416
086F4D80  66 85 C0                      test ax, ax
086F4D83  90 75 11 90 90 90             jne 00000014H@
086F4D89  66 0F BA 35 CC CC CC CC 0A    btr word ptr [CCCCCCCCH], 10 ; %M110+16
086F4D92  EB 0C 90 90 90                jmp 0000000EH@
086F4D97  66 0F BA 2D CC CC CC CC 0A    bts word ptr [CCCCCCCCH], 10 ; %M110+16

#93		
#94		
#95			(* IF i_pb_loc AND not i_pb_rem *)
#96			LD		i_pb_rem	{LNXT:31|-1|-1}
(*) UNDEF
086F4DA0  0F BF 05 CC CC CC CC          movsx eax, word ptr [CCCCCCCCH] ; $$DATA$$+416

#97			NOT	{LNXT:31|-1|-1}
(*) INT
086F4DA7  66 F7 D0                      not ax

#98			AND(		i_pb_loc	{LNXT:31|-1|-1}
(*) INT
086F4DAA  50                            push eax
086F4DAB  0F BF 05 CC CC CC CC          movsx eax, word ptr [CCCCCCCCH] ; $$DATA$$+414

#99			NOT	{LNXT:31|-1|-1}
(*) INT
086F4DB2  66 F7 D0                      not ax

#100			)	{LNXT:31|-1|-1}
(*) INT
086F4DB5  8B C8                         mov ecx, eax
086F4DB7  58                            pop eax
086F4DB8  23 C1                         and eax, ecx

#101			JMPCN	$label0	{LNXT:31|32|34}
(-) INT
086F4DBA  66 85 C0                      test ax, ax
086F4DBD  90 74 27 90 90 90             je 086F4DE7H

#102		
#103			(* THEN *)
#104		
#105				(* ATS_State_bits.11 := TRUE; *)
#106				MOVE		TRUE,ATS_State_bits.11	{LNXT:32|34|-1}
(*) INT
086F4DC3  B8 01 00 00 00                mov eax, 01H
086F4DC8  84 C0                         test al, al
086F4DCA  90 75 11 90 90 90             jne 00000014H@
086F4DD0  66 0F BA 35 CC CC CC CC 0B    btr word ptr [CCCCCCCCH], 11 ; %M110+16
086F4DD9  EB 0C 90 90 90                jmp 0000000EH@
086F4DDE  66 0F BA 2D CC CC CC CC 0B    bts word ptr [CCCCCCCCH], 11 ; %M110+16

#107		
#108		$label0:
#109			(* END_IF *)
#110		
#111		
#112			(* IF i_pb_loc AND i_pb_rem *)
#113			LD		i_pb_loc	{LNXT:34|-1|-1}
(*) UNDEF
086F4DE7  0F BF 05 CC CC CC CC          movsx eax, word ptr [CCCCCCCCH] ; $$DATA$$+414

#114			NOT	{LNXT:34|-1|-1}
(*) INT
086F4DEE  66 F7 D0                      not ax

#115			AND		i_pb_rem	{LNXT:34|-1|-1}
(*) INT
086F4DF1  0F BF 0D CC CC CC CC          movsx ecx, word ptr [CCCCCCCCH] ; $$DATA$$+416
086F4DF8  23 C1                         and eax, ecx

#116			JMPCN	$label1	{LNXT:34|35|37}
(-) INT
086F4DFA  66 85 C0                      test ax, ax
086F4DFD  90 74 27 90 90 90             je 086F4E27H

#117		
#118			(* THEN *)
#119		
#120				(* ATS_State_bits.11 := FALSE; *)
#121				MOVE		FALSE,ATS_State_bits.11	{LNXT:35|37|-1}
(*) INT
086F4E03  B8 00 00 00 00                mov eax, 00H
086F4E08  84 C0                         test al, al
086F4E0A  90 75 11 90 90 90             jne 00000014H@
086F4E10  66 0F BA 35 CC CC CC CC 0B    btr word ptr [CCCCCCCCH], 11 ; %M110+16
086F4E19  EB 0C 90 90 90                jmp 0000000EH@
086F4E1E  66 0F BA 2D CC CC CC CC 0B    bts word ptr [CCCCCCCCH], 11 ; %M110+16

#122		
#123		$label1:
#124			(* END_IF *)
#125		
#126		
#127			(* IF i_pb_loc AND not i_pb_rem *)
#128			LD		i_pb_rem	{LNXT:37|-1|-1}
(*) UNDEF
086F4E27  0F BF 05 CC CC CC CC          movsx eax, word ptr [CCCCCCCCH] ; $$DATA$$+416

#129			NOT	{LNXT:37|-1|-1}
(*) INT
086F4E2E  66 F7 D0                      not ax

#130			AND		i_pb_loc	{LNXT:37|-1|-1}
(*) INT
086F4E31  0F BF 0D CC CC CC CC          movsx ecx, word ptr [CCCCCCCCH] ; $$DATA$$+414
086F4E38  23 C1                         and eax, ecx

#131			JMPCN	$label2	{LNXT:37|38|43}
(-) INT
086F4E3A  66 85 C0                      test ax, ax
086F4E3D  90 74 27 90 90 90             je 086F4E67H

#132		
#133			(* THEN *)
#134		
#135				(* ATS_State_bits.11 := FALSE; *)
#136				MOVE		FALSE,ATS_State_bits.11	{LNXT:38|43|-1}
(*) INT
086F4E43  B8 00 00 00 00                mov eax, 00H
086F4E48  84 C0                         test al, al
086F4E4A  90 75 11 90 90 90             jne 00000014H@
086F4E50  66 0F BA 35 CC CC CC CC 0B    btr word ptr [CCCCCCCCH], 11 ; %M110+16
086F4E59  EB 0C 90 90 90                jmp 0000000EH@
086F4E5E  66 0F BA 2D CC CC CC CC 0B    bts word ptr [CCCCCCCCH], 11 ; %M110+16

#137		
#138		$label2:
#139			(* END_IF *)
#140		
#141			(* ATS22_DUT.EtaCurrent := to_byte(SHR(resp_eta_lcr[0] AND 16#3F00, 16#08) * 200 / 63); *)
#142			LD		resp_eta_lcr[0]	{LNXT:43|44|-1}
(*) UNDEF
086F4E67  0F BF 05 CC CC CC CC          movsx eax, word ptr [CCCCCCCCH] ; $$DATA$$+12

#143			AND		16#3F00	{LNXT:43|44|-1}
(*) INT
086F4E6E  25 00 3F 00 00                and eax, 00003F00H

#144			SHR		16#08	{LNXT:43|44|-1}
(*) INT
086F4E73  C1 E8 08                      shr eax, 8

#145			MUL		200	{LNXT:43|44|-1}
(*) DINT
086F4E76  B9 C8 00 00 00                mov ecx, 200
086F4E7B  F7 E9                         imul ecx

#146			DIV		63	{LNXT:43|44|-1}
(*) DINT
086F4E7D  99                            cdq
086F4E7E  B9 3F 00 00 00                mov ecx, 63
086F4E83  F7 F9                         idiv ecx

#147			to_byte	{LNXT:43|44|-1}
(*) DINT
#148			ST		ATS22_DUT.EtaCurrent	{LNXT:43|44|-1}
(*) BYTE
086F4E85  88 05 CC CC CC CC             mov [CCCCCCCCH], al ; $$DATA$$+33

#149		
#150			(* ATS_Current_prsnt	 := ATS22_DUT.EtaCurrent; *)
#151			MOVE		ATS22_DUT.EtaCurrent,ATS_Current_prsnt	{LNXT:44|46|-1}
(*) BYTE
086F4E8B  33 C0                         xor eax, eax
086F4E8D  8A 05 CC CC CC CC             mov al, [CCCCCCCCH] ; $$DATA$$+33
086F4E93  66 89 05 CC CC CC CC          mov [CCCCCCCCH], ax ; %M110+18

#152		
#153			(* ATS22_DUT.Local 	:= to_bool(resp_eta_lcr[0] And 16#4000); *)
#154			LD		resp_eta_lcr[0]	{LNXT:46|47|-1}
(*) UNDEF
086F4E9A  0F BF 05 CC CC CC CC          movsx eax, word ptr [CCCCCCCCH] ; $$DATA$$+12

#155			AND		16#4000	{LNXT:46|47|-1}
(*) INT
086F4EA1  25 00 40 00 00                and eax, 00004000H

#156			to_bool	{LNXT:46|47|-1}
(*) INT
086F4EA6  66 85 C0                      test ax, ax
086F4EA9  0F 95 C0                      setne al

#157			ST		ATS22_DUT.Local	{LNXT:46|47|-1}
(*) BOOL
086F4EAC  84 C0                         test al, al
086F4EAE  0F 95 05 CC CC CC CC          setne [CCCCCCCCH] ; $$DATA$$+34

#158		
#159			(* ATS22_DUT.Ramping 	:= to_bool(resp_eta_lcr[0] And 16#8000); *)
#160			LD		resp_eta_lcr[0]	{LNXT:47|49|-1}
(*) UNDEF
086F4EB5  0F BF 05 CC CC CC CC          movsx eax, word ptr [CCCCCCCCH] ; $$DATA$$+12

#161			AND		16#8000	{LNXT:47|49|-1}
(*) INT
086F4EBC  25 00 80 00 00                and eax, 00008000H

#162			to_bool	{LNXT:47|49|-1}
(*) INT
086F4EC1  66 85 C0                      test ax, ax
086F4EC4  0F 95 C0                      setne al

#163			ST		ATS22_DUT.Ramping	{LNXT:47|49|-1}
(*) BOOL
086F4EC7  84 C0                         test al, al
086F4EC9  0F 95 05 CC CC CC CC          setne [CCCCCCCCH] ; $$DATA$$+35

#164		
#165			(* ATS22_DUT.Lcr1 := resp_eta_lcr[1]; *)
#166			MOVE		resp_eta_lcr[1],ATS22_DUT.Lcr1	{LNXT:49|50|-1}
(*) BOOL
086F4ED0  0F BF 05 CC CC CC CC          movsx eax, word ptr [CCCCCCCCH] ; $$DATA$$+14
086F4ED7  66 89 05 CC CC CC CC          mov [CCCCCCCCH], ax ; $$DATA$$+36

#167		
#168			(* ATS22_DUT.Lcr2 := resp_eta_lcr[2]; *)
#169			MOVE		resp_eta_lcr[2],ATS22_DUT.Lcr2	{LNXT:50|51|-1}
(*) INT
086F4EDE  0F BF 05 CC CC CC CC          movsx eax, word ptr [CCCCCCCCH] ; $$DATA$$+16
086F4EE5  66 89 05 CC CC CC CC          mov [CCCCCCCCH], ax ; $$DATA$$+38

#170		
#171			(* ATS22_DUT.Lcr3 := resp_eta_lcr[3]; *)
#172			MOVE		resp_eta_lcr[3],ATS22_DUT.Lcr3	{LNXT:51|53|-1}
(*) INT
086F4EEC  0F BF 05 CC CC CC CC          movsx eax, word ptr [CCCCCCCCH] ; $$DATA$$+18
086F4EF3  66 89 05 CC CC CC CC          mov [CCCCCCCCH], ax ; $$DATA$$+40

#173		
#174			(* ATS_Current_L1 := ATS22_DUT.Lcr1; *)
#175			MOVE		ATS22_DUT.Lcr1,ATS_Current_L1	{LNXT:53|54|-1}
(*) INT
086F4EFA  0F BF 05 CC CC CC CC          movsx eax, word ptr [CCCCCCCCH] ; $$DATA$$+36
086F4F01  66 89 05 CC CC CC CC          mov [CCCCCCCCH], ax ; %M110+20

#176		
#177			(* ATS_Current_L2 := ATS22_DUT.Lcr2; *)
#178			MOVE		ATS22_DUT.Lcr2,ATS_Current_L2	{LNXT:54|55|-1}
(*) INT
086F4F08  0F BF 05 CC CC CC CC          movsx eax, word ptr [CCCCCCCCH] ; $$DATA$$+38
086F4F0F  66 89 05 CC CC CC CC          mov [CCCCCCCCH], ax ; %M110+22

#179		
#180			(* ATS_Current_L3 := ATS22_DUT.Lcr3; *)
#181			MOVE		ATS22_DUT.Lcr3,ATS_Current_L3	{LNXT:55|57|-1}
(*) INT
086F4F16  0F BF 05 CC CC CC CC          movsx eax, word ptr [CCCCCCCCH] ; $$DATA$$+40
086F4F1D  66 89 05 CC CC CC CC          mov [CCCCCCCCH], ax ; %M110+24

#182		
#183			(* res := sysMbMRTU_FC03(	addr := 1, 
#184											base := 261, // 260
#185											no := 1, 
#186											object := ADR(resp_eta_lcr), 
#187											timeout := 200); *)
#188			ADR		resp_eta_lcr	{LNXT:57|63|-1}
(*) INT
086F4F24  B8 CC CC CC CC                mov eax, CCCCCCCCH ; $$DATA$$+12

#189			ST		$$TMP0	{LNXT:57|63|-1}
(*) @INT
086F4F29  89 05 CC CC CC CC             mov [CCCCCCCCH], eax ; $$DATA$$+408

#190			LDP0		1	{LNXT:57|63|-1}
(*) @INT
#191			sysMbMRTU_FC03		261, 1, $$TMP0, 200	{LNXT:57|63|-1}
(*) @INT
086F4F2F  68 C8 00 00 00                push 200
086F4F34  FF 35 CC CC CC CC             push [CCCCCCCCH] ; $$DATA$$+408
086F4F3A  68 01 00 00 00                push 1
086F4F3F  68 05 01 00 00                push 261
086F4F44  68 01 00 00 00                push 1
086F4F49  B9 CC CC CC CC                mov ecx, CCCCCCCCH ; sysMbMRTU_FC03
086F4F4E  FF D1                         call ecx
086F4F50  81 C4 14 00 00 00             add esp, 20

#192			ST		res	{LNXT:57|63|-1}
(*) UINT
086F4F56  66 89 05 CC CC CC CC          mov [CCCCCCCCH], ax ; $$DATA$$+24

#193		
#194			(* ATS22_DUT.LcrVoltage	:= resp_eta_lcr[0]; *)
#195			MOVE		resp_eta_lcr[0],ATS22_DUT.LcrVoltage	{LNXT:63|64|-1}
(*) UINT
086F4F5D  0F BF 05 CC CC CC CC          movsx eax, word ptr [CCCCCCCCH] ; $$DATA$$+12
086F4F64  66 89 05 CC CC CC CC          mov [CCCCCCCCH], ax ; $$DATA$$+42

#196		
#197			(* ATS_Voltage := ATS22_DUT.LcrVoltage; *)
#198			MOVE		ATS22_DUT.LcrVoltage,ATS_Voltage	{LNXT:64|68|-1}
(*) INT
086F4F6B  0F BF 05 CC CC CC CC          movsx eax, word ptr [CCCCCCCCH] ; $$DATA$$+42
086F4F72  66 89 05 CC CC CC CC          mov [CCCCCCCCH], ax ; %M110+36

#199		
#200			(* res := sysMbMRTU_FC03(	addr := 1, 
#201											base := 280, // 279
#202											no := 1, 
#203											object := ADR(resp_eta_lcr), 
#204											timeout := 200); *)
#205			ADR		resp_eta_lcr	{LNXT:68|74|-1}
(*) INT
086F4F79  B8 CC CC CC CC                mov eax, CCCCCCCCH ; $$DATA$$+12

#206			ST		$$TMP0	{LNXT:68|74|-1}
(*) @INT
086F4F7E  89 05 CC CC CC CC             mov [CCCCCCCCH], eax ; $$DATA$$+408

#207			LDP0		1	{LNXT:68|74|-1}
(*) @INT
#208			sysMbMRTU_FC03		280, 1, $$TMP0, 200	{LNXT:68|74|-1}
(*) @INT
086F4F84  68 C8 00 00 00                push 200
086F4F89  FF 35 CC CC CC CC             push [CCCCCCCCH] ; $$DATA$$+408
086F4F8F  68 01 00 00 00                push 1
086F4F94  68 18 01 00 00                push 280
086F4F99  68 01 00 00 00                push 1
086F4F9E  B9 CC CC CC CC                mov ecx, CCCCCCCCH ; sysMbMRTU_FC03
086F4FA3  FF D1                         call ecx
086F4FA5  81 C4 14 00 00 00             add esp, 20

#209			ST		res	{LNXT:68|74|-1}
(*) UINT
086F4FAB  66 89 05 CC CC CC CC          mov [CCCCCCCCH], ax ; $$DATA$$+24

#210		
#211			(* ATS22_DUT.LastFLT 	:= resp_eta_lcr[0]; *)
#212			MOVE		resp_eta_lcr[0],ATS22_DUT.LastFLT	{LNXT:74|75|-1}
(*) UINT
086F4FB2  0F BF 05 CC CC CC CC          movsx eax, word ptr [CCCCCCCCH] ; $$DATA$$+12
086F4FB9  66 89 05 CC CC CC CC          mov [CCCCCCCCH], ax ; $$DATA$$+44

#213		
#214			(* ATS_Last_FaultCode := ATS22_DUT.LastFLT; *)
#215			MOVE		ATS22_DUT.LastFLT,ATS_Last_FaultCode	{LNXT:75|78|-1}
(*) INT
086F4FC0  0F BF 05 CC CC CC CC          movsx eax, word ptr [CCCCCCCCH] ; $$DATA$$+44
086F4FC7  66 89 05 CC CC CC CC          mov [CCCCCCCCH], ax ; %M110+26

#216		
#217			(* res := sysMbMRTU_FC03(	addr := 1, 
#218											base := 274, // 273
#219											no := 3, 
#220											object := ADR(resp_eta_lcr), 
#221											timeout := 200); *)
#222			ADR		resp_eta_lcr	{LNXT:78|84|-1}
(*) INT
086F4FCE  B8 CC CC CC CC                mov eax, CCCCCCCCH ; $$DATA$$+12

#223			ST		$$TMP0	{LNXT:78|84|-1}
(*) @INT
086F4FD3  89 05 CC CC CC CC             mov [CCCCCCCCH], eax ; $$DATA$$+408

#224			LDP0		1	{LNXT:78|84|-1}
(*) @INT
#225			sysMbMRTU_FC03		274, 3, $$TMP0, 200	{LNXT:78|84|-1}
(*) @INT
086F4FD9  68 C8 00 00 00                push 200
086F4FDE  FF 35 CC CC CC CC             push [CCCCCCCCH] ; $$DATA$$+408
086F4FE4  68 03 00 00 00                push 3
086F4FE9  68 12 01 00 00                push 274
086F4FEE  68 01 00 00 00                push 1
086F4FF3  B9 CC CC CC CC                mov ecx, CCCCCCCCH ; sysMbMRTU_FC03
086F4FF8  FF D1                         call ecx
086F4FFA  81 C4 14 00 00 00             add esp, 20

#226			ST		res	{LNXT:78|84|-1}
(*) UINT
086F5000  66 89 05 CC CC CC CC          mov [CCCCCCCCH], ax ; $$DATA$$+24

#227		
#228		
#229			(* IF res <> 0 *)
#230			LD		res	{LNXT:84|-1|-1}
(*) UNDEF
086F5007  0F BF 05 CC CC CC CC          movsx eax, word ptr [CCCCCCCCH] ; $$DATA$$+24

#231			NE		0	{LNXT:84|-1|-1}
(*) INT
086F500E  3D 00 00 00 00                cmp eax, 0
086F5013  0F 95 C0                      setne al
086F5016  25 FF 00 00 00                and eax, 0FFh

#232			JMPCN	$label3	{LNXT:84|84|86}
(-) BOOL
086F501B  84 C0                         test al, al
086F501D  90 74 27 90 90 90             je 086F5047H

#233		
#234			(* THEN *)
#235		
#236				(* Alarms.6 := true; *)
#237				MOVE		true,Alarms.6	{LNXT:84|86|-1}
(*) BOOL
086F5023  B8 01 00 00 00                mov eax, 01H
086F5028  84 C0                         test al, al
086F502A  90 75 11 90 90 90             jne 00000014H@
086F5030  66 0F BA 35 CC CC CC CC 06    btr word ptr [CCCCCCCCH], 6 ; %M110+32
086F5039  EB 0C 90 90 90                jmp 0000000EH@
086F503E  66 0F BA 2D CC CC CC CC 06    bts word ptr [CCCCCCCCH], 6 ; %M110+32

#238		
#239		$label3:
#240			(* END_IF *)
#241		
#242			(* ATS22_DUT.MotRunTime 		:= resp_eta_lcr[0]; *)
#243			MOVE		resp_eta_lcr[0],ATS22_DUT.MotRunTime	{LNXT:86|87|-1}
(*) WORD
086F5047  0F BF 05 CC CC CC CC          movsx eax, word ptr [CCCCCCCCH] ; $$DATA$$+12
086F504E  66 89 05 CC CC CC CC          mov [CCCCCCCCH], ax ; $$DATA$$+46

#244		
#245			(* ATS22_DUT.MotStartCnt 		:= resp_eta_lcr[1]; *)
#246			MOVE		resp_eta_lcr[1],ATS22_DUT.MotStartCnt	{LNXT:87|88|-1}
(*) INT
086F5055  0F BF 05 CC CC CC CC          movsx eax, word ptr [CCCCCCCCH] ; $$DATA$$+14
086F505C  66 89 05 CC CC CC CC          mov [CCCCCCCCH], ax ; $$DATA$$+48

#247		
#248			(* ATS22_DUT.MotLastStartTime 	:= resp_eta_lcr[2]; *)
#249			MOVE		resp_eta_lcr[2],ATS22_DUT.MotLastStartTime	{LNXT:88|90|-1}
(*) INT
086F5063  0F BF 05 CC CC CC CC          movsx eax, word ptr [CCCCCCCCH] ; $$DATA$$+16
086F506A  66 89 05 CC CC CC CC          mov [CCCCCCCCH], ax ; $$DATA$$+50

#250		
#251			(* ATS_RunTime_Hors	:= to_word(ATS22_DUT.MotRunTime); *)
#252			LDP0		ATS22_DUT.MotRunTime	{LNXT:90|91|-1}
(*) INT
#253			to_word	{LNXT:90|91|-1}
(*) INT
086F5071  0F BF 05 CC CC CC CC          movsx eax, word ptr [CCCCCCCCH] ; $$DATA$$+46

#254			ST		ATS_RunTime_Hors	{LNXT:90|91|-1}
(*) WORD
086F5078  66 89 05 CC CC CC CC          mov [CCCCCCCCH], ax ; %M110+28

#255		
#256			(* ATS_OnTimes_Cnt		:= to_word(ATS22_DUT.MotStartCnt); *)
#257			LDP0		ATS22_DUT.MotStartCnt	{LNXT:91|2|-1}
(*) WORD
#258			to_word	{LNXT:91|2|-1}
(*) WORD
086F507F  0F BF 05 CC CC CC CC          movsx eax, word ptr [CCCCCCCCH] ; $$DATA$$+48

#259			ST		ATS_OnTimes_Cnt	{LNXT:91|2|-1}
(*) WORD
086F5086  66 89 05 CC CC CC CC          mov [CCCCCCCCH], ax ; %M110+30

086F508D  61                            popad
086F508E  5D                            pop ebp

086F508F  C3                            ret

END_PROGRAM


**************************************************
	Target variable image generation
**************************************************


*** INPUT:
086F5090  55                            push ebp
086F5091  8B EC                         mov ebp, esp

086F5093  8A 0D CC CC CC CC             mov cl, [CCCCCCCCH] ; %I0+7
086F5099  88 0D CC CC CC CC             mov [CCCCCCCCH], cl ; $$DATA$$+412

086F509F  8A 0D CC CC CC CC             mov cl, [CCCCCCCCH] ; %I0+6
086F50A5  88 0D CC CC CC CC             mov [CCCCCCCCH], cl ; $$DATA$$+413

086F50AB  66 8B 0D CC CC CC CC          mov cx, [CCCCCCCCH] ; %I1+12
086F50B2  66 89 0D CC CC CC CC          mov [CCCCCCCCH], cx ; $$DATA$$+414

086F50B9  66 8B 0D CC CC CC CC          mov cx, [CCCCCCCCH] ; %I1+14
086F50C0  66 89 0D CC CC CC CC          mov [CCCCCCCCH], cx ; $$DATA$$+416

086F50C7  8B E5                         mov esp, ebp
086F50C9  5D                            pop ebp

086F50CA  C3                            ret


*** OUTPUT:
086F50CB  55                            push ebp
086F50CC  8B EC                         mov ebp, esp

086F50CE  8B E5                         mov esp, ebp
086F50D0  5D                            pop ebp

086F50D1  C3                            ret



**************************************************
	Task Background init code
**************************************************

086F50D2  55                            push ebp
086F50D3  8B EC                         mov ebp, esp

086F50D5  8B E5                         mov esp, ebp
086F50D7  5D                            pop ebp

086F50D8  C3                            ret

**************************************************
	List program: sr_init_counters
**************************************************

PROGRAM sr_init_counters

END_PROGRAM

086F50F0  55                            push ebp
086F50F1  8B EC                         mov ebp, esp
086F50F3  60                            pushad

#0		{SRC:sr_init_counters}
#1		(*$WAITSWITCH$*)
#2		
#3			(* kw_counter 	:= epprom_kw_cnt; *)
#4			MOVE		epprom_kw_cnt,kw_counter	{LNXT:1|2|-1}
(*) UDINT
086F50F4  8B 05 CC CC CC CC             mov eax, [CCCCCCCCH] ; %M101+8
086F50FA  89 05 CC CC CC CC             mov [CCCCCCCCH], eax ; %M110+4

#5		
#6			(* q_counter	:= epprom_q_cnt; *)
#7			MOVE		epprom_q_cnt,q_counter	{LNXT:2|1|-1}
(*) DWORD
086F5100  8B 05 CC CC CC CC             mov eax, [CCCCCCCCH] ; %M101+0
086F5106  89 05 CC CC CC CC             mov [CCCCCCCCH], eax ; %M110+8

086F510C  61                            popad
086F510D  5D                            pop ebp

086F510E  C3                            ret

END_PROGRAM


**************************************************
	Target variable image generation
**************************************************


*** INPUT:
086F510F  C3                            ret


*** OUTPUT:
086F5110  C3                            ret



**************************************************
	Task Boot init code
**************************************************

086F5111  55                            push ebp
086F5112  8B EC                         mov ebp, esp

086F5114  8B E5                         mov esp, ebp
086F5116  5D                            pop ebp

086F5117  C3                            ret

**************************************************
	List program: init_val
**************************************************

PROGRAM init_val

END_PROGRAM

086F5130  55                            push ebp
086F5131  8B EC                         mov ebp, esp
086F5133  60                            pushad

#0		{SRC:init_val}
#1		(*$WAITSWITCH$*)
#2		
#3		
#4			(* IF di_val_close_state_R *)
#5			LD		di_val_close_state_R	{LNXT:1|-1|-1}
(*) UNDEF
086F5134  33 C0                         xor eax, eax
086F5136  8A 05 CC CC CC CC             mov al, [CCCCCCCCH] ; %I0+0

#6			NOT	{LNXT:1|-1|-1}
(*) BOOL
086F513C  84 C0                         test al, al
086F513E  0F 94 C0                      sete al

#7			JMPCN	$label0	{LNXT:1|2|6}
(-) BOOL
086F5141  84 C0                         test al, al
086F5143  90 74 1F 90 90 90             je 086F5165H

#8		
#9			(* THEN *)
#10		
#11				(* o_val_close_R:=true; *)
#12				MOVE		true,o_val_close_R	{LNXT:2|3|-1}
(*) BOOL
086F5149  B8 01 00 00 00                mov eax, 01H
086F514E  84 C0                         test al, al
086F5150  0F 95 05 CC CC CC CC          setne [CCCCCCCCH] ; %Q1+3

#13		
#14				(* o_val_open_R:=false; *)
#15				MOVE		false,o_val_open_R	{LNXT:3|6|-1}
(*) BOOL
086F5157  B8 00 00 00 00                mov eax, 00H
086F515C  84 C0                         test al, al
086F515E  0F 95 05 CC CC CC CC          setne [CCCCCCCCH] ; %Q1+2

#16		
#17		$label0:
#18			(* END_IF *)
#19		
#20		
#21			(* IF di_val_close_state_fall = 0 *)
#22			LD		di_val_close_state_fall	{LNXT:6|-1|-1}
(*) UNDEF
086F5165  0F BF 05 CC CC CC CC          movsx eax, word ptr [CCCCCCCCH] ; %I1+8

#23			EQ		0	{LNXT:6|-1|-1}
(*) INT
086F516C  3D 00 00 00 00                cmp eax, 0
086F5171  0F 94 C0                      sete al
086F5174  25 FF 00 00 00                and eax, 0FFh

#24			JMPCN	$label1	{LNXT:6|7|1}
(-) BOOL
086F5179  84 C0                         test al, al
086F517B  90 74 1F 90 90 90             je 086F519DH

#25		
#26			(* THEN *)
#27		
#28				(* o_val_close_fall:=true; *)
#29				MOVE		true,o_val_close_fall	{LNXT:7|8|-1}
(*) BOOL
086F5181  B8 01 00 00 00                mov eax, 01H
086F5186  84 C0                         test al, al
086F5188  0F 95 05 CC CC CC CC          setne [CCCCCCCCH] ; %Q1+1

#30		
#31				(* o_val_open_fall:=false; *)
#32				MOVE		false,o_val_open_fall	{LNXT:8|1|-1}
(*) BOOL
086F518F  B8 00 00 00 00                mov eax, 00H
086F5194  84 C0                         test al, al
086F5196  0F 95 05 CC CC CC CC          setne [CCCCCCCCH] ; %Q1+0

086F519D  61                            popad
086F519E  5D                            pop ebp

086F519F  C3                            ret

END_PROGRAM


**************************************************
	Target variable image generation
**************************************************


*** INPUT:
086F51A0  C3                            ret


*** OUTPUT:
086F51A1  C3                            ret



**************************************************
	Task Init init code
**************************************************

086F51A2  55                            push ebp
086F51A3  8B EC                         mov ebp, esp

086F51A5  8B E5                         mov esp, ebp
086F51A7  5D                            pop ebp

086F51A8  C3                            ret

**************************************************
	List program: InitParDB
**************************************************

PROGRAM InitParDB

        VAR
warningsKiller : USINT;
dummyCrc32 : UDINT;
	END_VAR

END_PROGRAM

086F51C0  55                            push ebp
086F51C1  8B EC                         mov ebp, esp
086F51C3  60                            pushad

#0		{SRC:InitParDB}
#1		(*$WAITSWITCH$*)
#2		
#3			(* dummyCrc32 := 3949969151; *)
#4			MOVE		3949969151,dummyCrc32	{LNXT:3|5|-1}
(*) UDINT
086F51C4  B8 FF BE 6F EB                mov eax, EB6FBEFFH
086F51C9  89 05 CC CC CC CC             mov [CCCCCCCCH], eax ; $$DATA$$+60

#5		
#6			(* warningsKiller := sysDBase_SetExtTable( ADR( $$ParDB ), $$ParDBLength ); *)
#7			ADR		$$ParDB	{LNXT:5|3|-1}
(*) UDINT
086F51CF  B8 CC CC CC CC                mov eax, CCCCCCCCH ; $$CODE$$+336

#8			sysDBase_SetExtTable		$$ParDBLength	{LNXT:5|3|-1}
(*) @USINT
086F51D4  68 17 00 00 00                push 23
086F51D9  8B C8                         mov ecx, eax
086F51DB  51                            push ecx
086F51DC  B9 CC CC CC CC                mov ecx, CCCCCCCCH ; sysDBase_SetExtTable
086F51E1  FF D1                         call ecx
086F51E3  81 C4 08 00 00 00             add esp, 8

#9			ST		warningsKiller	{LNXT:5|3|-1}
(*) USINT
086F51E9  88 05 CC CC CC CC             mov [CCCCCCCCH], al ; $$DATA$$+59

086F51EF  61                            popad
086F51F0  5D                            pop ebp

086F51F1  C3                            ret

END_PROGRAM


**************************************************
	Target variable image generation
**************************************************


*** INPUT:
086F51F2  C3                            ret


*** OUTPUT:
086F51F3  C3                            ret



**************************************************
	Task Serv init code
**************************************************

086F51F4  55                            push ebp
086F51F5  8B EC                         mov ebp, esp

086F51F7  8B E5                         mov esp, ebp
086F51F9  5D                            pop ebp

086F51FA  C3                            ret

**************************************************
	List program: sr_pressure
**************************************************

PROGRAM sr_pressure

        VAR
tmp_test : INT;
	END_VAR

END_PROGRAM

086F5210  55                            push ebp
086F5211  8B EC                         mov ebp, esp
086F5213  60                            pushad

#0		{SRC:sr_pressure}
#1		(*$WAITSWITCH$*)
#2		
#3			(* Pressure := to_int(to_real(i_adc_pressure )/10); *)
#4			LDP0		i_adc_pressure	{LNXT:2|2|-1}
(*) UDINT
#5			to_real	{LNXT:2|2|-1}
(*) UDINT
086F5214  0F BF 05 CC CC CC CC          movsx eax, word ptr [CCCCCCCCH] ; $$DATA$$+438
086F521B  50                            push eax
086F521C  DB 04 24                      fild dword ptr [esp]
086F521F  58                            pop eax

#6			DIV		10	{LNXT:2|2|-1}
(*) REAL
086F5220  68 0A 00 00 00                push 10
086F5225  DA 34 24                      fidiv [esp]
086F5228  81 C4 04 00 00 00             add esp, 4

#7			to_int	{LNXT:2|2|-1}
(*) REAL
086F522E  81 EC 08 00 00 00             sub esp, 8
086F5234  DF 3C 24                      fistp qword ptr [esp]
086F5237  58                            pop eax
086F5238  81 C4 04 00 00 00             add esp, 4

#8			ST		Pressure	{LNXT:2|2|-1}
(*) INT
086F523E  66 89 05 CC CC CC CC          mov [CCCCCCCCH], ax ; %M110+0

END_PROGRAM
**************************************************
	List program: sr_counters
**************************************************

PROGRAM sr_counters

        VAR
kw_trig : R_TRIG;
q_trig : R_TRIG;
kw_pulses_per_acs : UINT;
q_pulses_per_acs : UINT;
test_freq : UDINT;
	END_VAR

END_PROGRAM

#0		{SRC:sr_counters}
#1		(*$WAITSWITCH$*)
#2		
#3			(* kw_pulses_per_acs 	:= 8000; *)
#4			MOVE		8000,kw_pulses_per_acs	{LNXT:2|3|-1}
(*) UDINT
086F5245  B8 40 1F 00 00                mov eax, 1F40H
086F524A  66 89 05 CC CC CC CC          mov [CCCCCCCCH], ax ; $$DATA$$+266

#5		
#6			(* q_pulses_per_acs	:= 1; *)
#7			MOVE		1,q_pulses_per_acs	{LNXT:3|15|-1}
(*) UINT
086F5251  B8 01 00 00 00                mov eax, 01H
086F5256  66 89 05 CC CC CC CC          mov [CCCCCCCCH], ax ; $$DATA$$+268

#8		
#9		
#10			(* IF fdi_q_cnt >= q_pulses_per_acs *)
#11			LD		fdi_q_cnt	{LNXT:15|-1|-1}
(*) UNDEF
086F525D  8B 05 CC CC CC CC             mov eax, [CCCCCCCCH] ; %M500+0

#12			GE		q_pulses_per_acs	{LNXT:15|-1|-1}
(*) UDINT
086F5263  33 C9                         xor ecx, ecx
086F5265  66 8B 0D CC CC CC CC          mov cx, [CCCCCCCCH] ; $$DATA$$+268
086F526C  3B C1                         cmp eax, ecx
086F526E  0F 93 C0                      setae al
086F5271  25 FF 00 00 00                and eax, 0FFh

#13			JMPCN	$label0	{LNXT:15|16|20}
(-) BOOL
086F5276  84 C0                         test al, al
086F5278  90 74 22 90 90 90             je 086F529DH

#14		
#15			(* THEN *)
#16		
#17				(* q_counter := q_counter + 1; *)
#18				LD		q_counter	{LNXT:16|17|-1}
(*) UNDEF
086F527E  8B 05 CC CC CC CC             mov eax, [CCCCCCCCH] ; %M110+8

#19				ADD		1	{LNXT:16|17|-1}
(*) DWORD
086F5284  05 01 00 00 00                add eax, 1

#20				ST		q_counter	{LNXT:16|17|-1}
(*) DWORD
086F5289  89 05 CC CC CC CC             mov [CCCCCCCCH], eax ; %M110+8

#21		
#22				(* fdi_q_reset := true; *)
#23				MOVE		true,fdi_q_reset	{LNXT:17|20|-1}
(*) DWORD
086F528F  B8 01 00 00 00                mov eax, 01H
086F5294  84 C0                         test al, al
086F5296  0F 95 05 CC CC CC CC          setne [CCCCCCCCH] ; %M550+0

#24		
#25		$label0:
#26			(* END_IF *)
#27		
#28			(* q_value := to_int((3600 * to_real(fdi_q_freq)) / (to_real(q_pulses_per_acs) / 1)); *)
#29			LDP0		fdi_q_freq	{LNXT:20|2|-1}
(*) BOOL
#30			to_real	{LNXT:20|2|-1}
(*) BOOL
086F529D  8B 05 CC CC CC CC             mov eax, [CCCCCCCCH] ; %M500+4
086F52A3  68 00 00 00 00                push 0
086F52A8  50                            push eax
086F52A9  DF 2C 24                      fild qword ptr [esp]
086F52AC  81 C4 08 00 00 00             add esp, 8

#31			MUL		3600	{LNXT:20|2|-1}
(*) REAL
086F52B2  68 10 0E 00 00                push 3600
086F52B7  DA 0C 24                      fimul [esp]
086F52BA  81 C4 04 00 00 00             add esp, 4

#32			DIV(		0	{LNXT:20|2|-1}
(*) REAL
086F52C0  81 EC 04 00 00 00             sub esp, 4
086F52C6  D9 1C 24                      fstp dword ptr [esp]
086F52C9  B8 00 00 00 00                mov eax, 00H

#33			LDP0		q_pulses_per_acs	{LNXT:20|2|-1}
(*) USINT
#34			to_real	{LNXT:20|2|-1}
(*) USINT
086F52CE  33 C0                         xor eax, eax
086F52D0  66 8B 05 CC CC CC CC          mov ax, [CCCCCCCCH] ; $$DATA$$+268
086F52D7  68 00 00 00 00                push 0
086F52DC  50                            push eax
086F52DD  DF 2C 24                      fild qword ptr [esp]
086F52E0  81 C4 08 00 00 00             add esp, 8

#35			DIV		1	{LNXT:20|2|-1}
(*) REAL
086F52E6  68 01 00 00 00                push 1
086F52EB  DA 34 24                      fidiv [esp]
086F52EE  81 C4 04 00 00 00             add esp, 4

#36			)	{LNXT:20|2|-1}
(*) REAL
086F52F4  81 EC 04 00 00 00             sub esp, 4
086F52FA  D9 1C 24                      fstp dword ptr [esp]
086F52FD  D9 44 24 04                   fld dword ptr 4[esp]
086F5301  D8 34 24                      fdiv dword ptr [esp]
086F5304  81 C4 08 00 00 00             add esp, 8

#37			to_int	{LNXT:20|2|-1}
(*) REAL
086F530A  81 EC 08 00 00 00             sub esp, 8
086F5310  DF 3C 24                      fistp qword ptr [esp]
086F5313  58                            pop eax
086F5314  81 C4 04 00 00 00             add esp, 4

#38			ST		q_value	{LNXT:20|2|-1}
(*) INT
086F531A  66 89 05 CC CC CC CC          mov [CCCCCCCCH], ax ; %M110+14

END_PROGRAM
**************************************************
	List program: sr_save_counters
**************************************************

PROGRAM sr_save_counters

        VAR
power_err : R_TRIG;
ton_start_up : TON;
res_q : BOOL;
res_kw : BOOL;
	END_VAR

END_PROGRAM

#0		{SRC:sr_save_counters}
#1		(*$WAITSWITCH$*)
#2		
#3			(* ton_start_up *)
#4			MOVE		true,ton_start_up.IN	{LNXT:1|-1|-1}
(*) UDINT
086F5321  B8 01 00 00 00                mov eax, 01H
086F5326  84 C0                         test al, al
086F5328  0F 95 05 CC CC CC CC          setne [CCCCCCCCH] ; $$DATA$$+276

#5			MOVE		5000,ton_start_up.PT	{LNXT:1|-1|-1}
(*) BOOL
086F532F  B8 88 13 00 00                mov eax, 1388H
086F5334  89 05 CC CC CC CC             mov [CCCCCCCCH], eax ; $$DATA$$+277

#6			CAL		ton_start_up	{LNXT:1|2|-1}
(*) UDINT
086F533A  50                            push eax
086F533B  BB CC CC CC CC                mov ebx, CCCCCCCCH ; $$DATA$$+272
086F5340  E8 94 F1 FF FF                call 086F44D9H ; $$CODE$$+17625
086F5345  58                            pop eax

#7		
#8			(* power_err *)
#9			LD		ton_start_up.Q	{LNXT:2|-1|-1}
(*) UNDEF
086F5346  33 C0                         xor eax, eax
086F5348  8A 05 CC CC CC CC             mov al, [CCCCCCCCH] ; $$DATA$$+281

#10			AND		i_rnpp	{LNXT:2|-1|-1}
(*) BOOL
086F534E  33 C9                         xor ecx, ecx
086F5350  8A 0D CC CC CC CC             mov cl, [CCCCCCCCH] ; $$DATA$$+436
086F5356  23 C1                         and eax, ecx

#11			ST		power_err.clk	{LNXT:2|-1|-1}
(*) BOOL
086F5358  84 C0                         test al, al
086F535A  0F 95 05 CC CC CC CC          setne [CCCCCCCCH] ; $$DATA$$+295

#12			CAL		power_err	{LNXT:2|3|-1}
(*) BOOL
086F5361  50                            push eax
086F5362  BB CC CC CC CC                mov ebx, CCCCCCCCH ; $$DATA$$+294
086F5367  E8 44 F1 FF FF                call 086F44B0H ; $$CODE$$+17584
086F536C  58                            pop eax

#13		
#14		
#15			(* IF power_err.q *)
#16			LD		power_err.q	{LNXT:3|-1|-1}
(*) UNDEF
086F536D  33 C0                         xor eax, eax
086F536F  8A 05 CC CC CC CC             mov al, [CCCCCCCCH] ; $$DATA$$+296

#17			JMPCN	$label0	{LNXT:3|4|1}
(-) BOOL
086F5375  84 C0                         test al, al
086F5377  0F 84 82 00 00 00             je 086F53FFH

#18		
#19			(* THEN *)
#20		
#21		
#22				(* IF epprom_q_cnt <> q_counter *)
#23				LD		epprom_q_cnt	{LNXT:4|-1|-1}
(*) UNDEF
086F537D  8B 05 CC CC CC CC             mov eax, [CCCCCCCCH] ; %M101+0

#24				NE		q_counter	{LNXT:4|-1|-1}
(*) DWORD
086F5383  3B 05 CC CC CC CC             cmp eax, [CCCCCCCCH] ; %M110+8
086F5389  0F 95 C0                      setne al
086F538C  25 FF 00 00 00                and eax, 0FFh

#25				JMPCN	$label1	{LNXT:4|4|5}
(-) BOOL
086F5391  84 C0                         test al, al
086F5393  90 74 28 90 90 90             je 086F53BEH

#26		
#27				(* THEN *)
#28		
#29					(* res_q := sysWriteParUINT(ADR(epprom_q_cnt), q_counter); *)
#30					ADR		epprom_q_cnt	{LNXT:4|5|-1}
(*) BOOL
086F5399  B8 CC CC CC CC                mov eax, CCCCCCCCH ; %M101+0

#31					sysWriteParUINT		q_counter	{LNXT:4|5|-1}
(*) @DWORD
086F539E  8B 0D CC CC CC CC             mov ecx, [CCCCCCCCH] ; %M110+8
086F53A4  51                            push ecx
086F53A5  8B C8                         mov ecx, eax
086F53A7  51                            push ecx
086F53A8  B9 CC CC CC CC                mov ecx, CCCCCCCCH ; sysWriteParUINT
086F53AD  FF D1                         call ecx
086F53AF  81 C4 08 00 00 00             add esp, 8

#32					ST		res_q	{LNXT:4|5|-1}
(*) BOOL
086F53B5  84 C0                         test al, al
086F53B7  0F 95 05 CC CC CC CC          setne [CCCCCCCCH] ; $$DATA$$+265

#33		
#34		$label1:
#35				(* END_IF *)
#36		
#37		
#38				(* IF epprom_kw_cnt <> kw_counter *)
#39				LD		epprom_kw_cnt	{LNXT:5|-1|-1}
(*) UNDEF
086F53BE  8B 05 CC CC CC CC             mov eax, [CCCCCCCCH] ; %M101+8

#40				NE		kw_counter	{LNXT:5|-1|-1}
(*) DWORD
086F53C4  3B 05 CC CC CC CC             cmp eax, [CCCCCCCCH] ; %M110+4
086F53CA  0F 95 C0                      setne al
086F53CD  25 FF 00 00 00                and eax, 0FFh

#41				JMPCN	$label2	{LNXT:5|5|1}
(-) BOOL
086F53D2  84 C0                         test al, al
086F53D4  90 74 28 90 90 90             je 086F53FFH

#42		
#43				(* THEN *)
#44		
#45					(* res_kw := sysWriteParUINT(ADR(epprom_kw_cnt), kw_counter); *)
#46					ADR		epprom_kw_cnt	{LNXT:5|1|-1}
(*) BOOL
086F53DA  B8 CC CC CC CC                mov eax, CCCCCCCCH ; %M101+8

#47					sysWriteParUINT		kw_counter	{LNXT:5|1|-1}
(*) @DWORD
086F53DF  8B 0D CC CC CC CC             mov ecx, [CCCCCCCCH] ; %M110+4
086F53E5  51                            push ecx
086F53E6  8B C8                         mov ecx, eax
086F53E8  51                            push ecx
086F53E9  B9 CC CC CC CC                mov ecx, CCCCCCCCH ; sysWriteParUINT
086F53EE  FF D1                         call ecx
086F53F0  81 C4 08 00 00 00             add esp, 8

#48					ST		res_kw	{LNXT:5|1|-1}
(*) BOOL
086F53F6  84 C0                         test al, al
086F53F8  0F 95 05 CC CC CC CC          setne [CCCCCCCCH] ; $$DATA$$+305

END_PROGRAM
**************************************************
	List program: sr_ATS_Ctrl
**************************************************

PROGRAM sr_ATS_Ctrl

        VAR
TON_StartUp_1 : TON;
TON_StartUp_2 : TON;
stopping_timer : TON;
downtimeIN : BOOL;
washing_timer : TON;
checkWashAndStart : CheckWashAndStart;
isRunningWash : BOOL;
onWash : BOOL := false;
time_sec : INT := 4000;
prev_wash_time_minutes : INT;
	END_VAR

END_PROGRAM

#0		{SRC:sr_ATS_Ctrl}
#1		(*$WAITSWITCH$*)
#2		
#3		
#4			(* IF i_pb_rem = 1 And
#5		Not Alarms.0 And 
#6		Not Alarms.3 And 
#7		Not Alarms.4 And 
#8		Not Alarms.5 And 
#9		Not Alarms.7 *)
#10			LD		Alarms.7	{LNXT:2|-1|-1}
(*) UNDEF
086F53FF  33 C0                         xor eax, eax
086F5401  66 8B 05 CC CC CC CC          mov ax, [CCCCCCCCH] ; %M110+32
086F5408  C1 E8 07                      shr eax, 7
086F540B  25 01 00 00 00                and eax, 1

#11			NOT	{LNXT:2|-1|-1}
(*) BOOL
086F5410  84 C0                         test al, al
086F5412  0F 94 C0                      sete al

#12			AND(		Alarms.5	{LNXT:2|-1|-1}
(*) BOOL
086F5415  50                            push eax
086F5416  33 C0                         xor eax, eax
086F5418  66 8B 05 CC CC CC CC          mov ax, [CCCCCCCCH] ; %M110+32
086F541F  C1 E8 05                      shr eax, 5
086F5422  25 01 00 00 00                and eax, 1

#13			NOT	{LNXT:2|-1|-1}
(*) BOOL
086F5427  84 C0                         test al, al
086F5429  0F 94 C0                      sete al

#14			AND(		Alarms.4	{LNXT:2|-1|-1}
(*) BOOL
086F542C  50                            push eax
086F542D  33 C0                         xor eax, eax
086F542F  66 8B 05 CC CC CC CC          mov ax, [CCCCCCCCH] ; %M110+32
086F5436  C1 E8 04                      shr eax, 4
086F5439  25 01 00 00 00                and eax, 1

#15			NOT	{LNXT:2|-1|-1}
(*) BOOL
086F543E  84 C0                         test al, al
086F5440  0F 94 C0                      sete al

#16			AND(		Alarms.3	{LNXT:2|-1|-1}
(*) BOOL
086F5443  50                            push eax
086F5444  33 C0                         xor eax, eax
086F5446  66 8B 05 CC CC CC CC          mov ax, [CCCCCCCCH] ; %M110+32
086F544D  C1 E8 03                      shr eax, 3
086F5450  25 01 00 00 00                and eax, 1

#17			NOT	{LNXT:2|-1|-1}
(*) BOOL
086F5455  84 C0                         test al, al
086F5457  0F 94 C0                      sete al

#18			AND(		Alarms.0	{LNXT:2|-1|-1}
(*) BOOL
086F545A  50                            push eax
086F545B  33 C0                         xor eax, eax
086F545D  66 8B 05 CC CC CC CC          mov ax, [CCCCCCCCH] ; %M110+32
086F5464  25 01 00 00 00                and eax, 1

#19			NOT	{LNXT:2|-1|-1}
(*) BOOL
086F5469  84 C0                         test al, al
086F546B  0F 94 C0                      sete al

#20			AND(		i_pb_rem	{LNXT:2|-1|-1}
(*) BOOL
086F546E  50                            push eax
086F546F  0F BF 05 CC CC CC CC          movsx eax, word ptr [CCCCCCCCH] ; $$DATA$$+418

#21			EQ		1	{LNXT:2|-1|-1}
(*) INT
086F5476  3D 01 00 00 00                cmp eax, 1
086F547B  0F 94 C0                      sete al
086F547E  25 FF 00 00 00                and eax, 0FFh

#22			)	{LNXT:2|-1|-1}
(*) BOOL
086F5483  8B C8                         mov ecx, eax
086F5485  58                            pop eax
086F5486  23 C1                         and eax, ecx

#23			)	{LNXT:2|-1|-1}
(*) BOOL
086F5488  8B C8                         mov ecx, eax
086F548A  58                            pop eax
086F548B  23 C1                         and eax, ecx

#24			)	{LNXT:2|-1|-1}
(*) BOOL
086F548D  8B C8                         mov ecx, eax
086F548F  58                            pop eax
086F5490  23 C1                         and eax, ecx

#25			)	{LNXT:2|-1|-1}
(*) BOOL
086F5492  8B C8                         mov ecx, eax
086F5494  58                            pop eax
086F5495  23 C1                         and eax, ecx

#26			)	{LNXT:2|-1|-1}
(*) BOOL
086F5497  8B C8                         mov ecx, eax
086F5499  58                            pop eax
086F549A  23 C1                         and eax, ecx

#27			JMPCN	$label0	{LNXT:2|9|30}
(-) BOOL
086F549C  84 C0                         test al, al
086F549E  0F 84 C9 00 00 00             je 086F556DH

#28		
#29			(* THEN *)
#30		
#31		
#32				(* IF CMD.0 *)
#33				LD		CMD.0	{LNXT:9|-1|-1}
(*) UNDEF
086F54A4  33 C0                         xor eax, eax
086F54A6  66 8B 05 CC CC CC CC          mov ax, [CCCCCCCCH] ; %M110+34
086F54AD  25 01 00 00 00                and eax, 1

#34				JMPCN	$label2	{LNXT:9|10|26}
(-) BOOL
086F54B2  84 C0                         test al, al
086F54B4  0F 84 A0 00 00 00             je 086F555AH

#35		
#36				(* THEN *)
#37		
#38					(* checkWashAndStart *)
#39					MOVE		o_val_close_fall,checkWashAndStart.o_val_close_fall_FB	{LNXT:10|-1|-1}
(*) BOOL
086F54BA  B8 CC CC CC CC                mov eax, CCCCCCCCH ; %Q1+1
086F54BF  89 05 CC CC CC CC             mov [CCCCCCCCH], eax ; $$DATA$$+185

#40					MOVE		o_val_close_R,checkWashAndStart.o_val_close_R_FB	{LNXT:11|-1|-1}
(*) BOOL^
086F54C5  B8 CC CC CC CC                mov eax, CCCCCCCCH ; %Q1+3
086F54CA  89 05 CC CC CC CC             mov [CCCCCCCCH], eax ; $$DATA$$+177

#41					MOVE		o_val_open_fall,checkWashAndStart.o_val_open_fall_FB	{LNXT:12|-1|-1}
(*) BOOL^
086F54D0  B8 CC CC CC CC                mov eax, CCCCCCCCH ; %Q1+0
086F54D5  89 05 CC CC CC CC             mov [CCCCCCCCH], eax ; $$DATA$$+181

#42					MOVE		o_val_open_R,checkWashAndStart.o_val_open_R_FB	{LNXT:13|-1|-1}
(*) BOOL^
086F54DB  B8 CC CC CC CC                mov eax, CCCCCCCCH ; %Q1+2
086F54E0  89 05 CC CC CC CC             mov [CCCCCCCCH], eax ; $$DATA$$+173

#43					MOVE		sv_washing,checkWashAndStart.sv_washing_FB	{LNXT:14|-1|-1}
(*) BOOL^
086F54E6  B8 CC CC CC CC                mov eax, CCCCCCCCH ; %M110+38
086F54EB  89 05 CC CC CC CC             mov [CCCCCCCCH], eax ; $$DATA$$+169

#44					MOVE		q_start_ats,checkWashAndStart.q_start_ats_FB	{LNXT:15|-1|-1}
(*) BOOL^
086F54F1  B8 CC CC CC CC                mov eax, CCCCCCCCH ; %Q1+7
086F54F6  89 05 CC CC CC CC             mov [CCCCCCCCH], eax ; $$DATA$$+189

#45					MOVE		time_sec,checkWashAndStart.ep_time_wash_FB	{LNXT:16|-1|-1}
(*) BOOL^
086F54FC  B8 CC CC CC CC                mov eax, CCCCCCCCH ; $$DATA$$+230
086F5501  89 05 CC CC CC CC             mov [CCCCCCCCH], eax ; $$DATA$$+193

#46					MOVE		i_val_state,checkWashAndStart.i_val_state_FB	{LNXT:17|-1|-1}
(*) INT^
086F5507  B8 CC CC CC CC                mov eax, CCCCCCCCH ; $$DATA$$+420
086F550C  89 05 CC CC CC CC             mov [CCCCCCCCH], eax ; $$DATA$$+197

#47					MOVE		di_val_open_state_fall,checkWashAndStart.di_val_open_state_fall_FB	{LNXT:18|-1|-1}
(*) INT^
086F5512  B8 CC CC CC CC                mov eax, CCCCCCCCH ; $$DATA$$+422
086F5517  89 05 CC CC CC CC             mov [CCCCCCCCH], eax ; $$DATA$$+201

#48					MOVE		di_val_close_state_fall,checkWashAndStart.di_val_close_state_fall_FB	{LNXT:19|-1|-1}
(*) INT^
086F551D  B8 CC CC CC CC                mov eax, CCCCCCCCH ; $$DATA$$+424
086F5522  89 05 CC CC CC CC             mov [CCCCCCCCH], eax ; $$DATA$$+205

#49					MOVE		di_val_open_state_R,checkWashAndStart.di_val_open_state_R_FB	{LNXT:20|-1|-1}
(*) INT^
086F5528  B8 CC CC CC CC                mov eax, CCCCCCCCH ; $$DATA$$+426
086F552D  89 05 CC CC CC CC             mov [CCCCCCCCH], eax ; $$DATA$$+209

#50					MOVE		di_val_close_state_R,checkWashAndStart.di_val_close_state_R_FB	{LNXT:21|-1|-1}
(*) INT^
086F5533  B8 CC CC CC CC                mov eax, CCCCCCCCH ; $$DATA$$+428
086F5538  89 05 CC CC CC CC             mov [CCCCCCCCH], eax ; $$DATA$$+213

#51					MOVE		Alarms_Val,checkWashAndStart.Alarm_Val_FB	{LNXT:22|-1|-1}
(*) BOOL^
086F553E  B8 CC CC CC CC                mov eax, CCCCCCCCH ; %M110+40
086F5543  89 05 CC CC CC CC             mov [CCCCCCCCH], eax ; $$DATA$$+217

#52					CAL		checkWashAndStart	{LNXT:10|57|-1}
(*) WORD^
086F5549  50                            push eax
086F554A  BB CC CC CC CC                mov ebx, CCCCCCCCH ; $$DATA$$+66
086F554F  E8 B6 F1 FF FF                call 086F470AH ; $$CODE$$+18186
086F5554  58                            pop eax

#53					JMP		$label3	{LNXT:9|10|26}
(-) WORD^
086F5555  EB 11 90 90 90                jmp 086F5568H

#54		$label2:
#55		
#56				(* ELSE *)
#57		
#58					(* q_start_ats := False; *)
#59					MOVE		False,q_start_ats	{LNXT:26|57|-1}
(*) WORD^
086F555A  B8 00 00 00 00                mov eax, 00H
086F555F  84 C0                         test al, al
086F5561  0F 95 05 CC CC CC CC          setne [CCCCCCCCH] ; %Q1+7

#60		
#61		$label3:
#62				(* END_IF *)
#63				JMP		$label1	{LNXT:2|9|30}
(-) BOOL
086F5568  EB 35 90 90 90                jmp 086F559FH

#64		$label0:
#65		
#66			(* ELSE *)
#67		
#68				(* CMD.0 := False; *)
#69				MOVE		False,CMD.0	{LNXT:30|31|-1}
(*) BOOL
086F556D  B8 00 00 00 00                mov eax, 00H
086F5572  84 C0                         test al, al
086F5574  90 75 11 90 90 90             jne 00000014H@
086F557A  66 0F BA 35 CC CC CC CC 00    btr word ptr [CCCCCCCCH], 0 ; %M110+34
086F5583  EB 0C 90 90 90                jmp 0000000EH@
086F5588  66 0F BA 2D CC CC CC CC 00    bts word ptr [CCCCCCCCH], 0 ; %M110+34

#70		
#71				(* q_start_ats := False; *)
#72				MOVE		False,q_start_ats	{LNXT:31|57|-1}
(*) WORD
086F5591  B8 00 00 00 00                mov eax, 00H
086F5596  84 C0                         test al, al
086F5598  0F 95 05 CC CC CC CC          setne [CCCCCCCCH] ; %Q1+7

#73		
#74		$label1:
#75			(* END_IF *)
#76		
#77		
#78			(* IF wash_time_minutes <> prev_wash_time_minutes *)
#79			LD		wash_time_minutes	{LNXT:57|-1|-1}
(*) UNDEF
086F559F  0F BF 05 CC CC CC CC          movsx eax, word ptr [CCCCCCCCH] ; %M110+42

#80			NE		prev_wash_time_minutes	{LNXT:57|-1|-1}
(*) INT
086F55A6  0F BF 0D CC CC CC CC          movsx ecx, word ptr [CCCCCCCCH] ; $$DATA$$+430
086F55AD  3B C1                         cmp eax, ecx
086F55AF  0F 95 C0                      setne al
086F55B2  25 FF 00 00 00                and eax, 0FFh

#81			JMPCN	$label4	{LNXT:57|59|64}
(-) BOOL
086F55B7  84 C0                         test al, al
086F55B9  90 74 40 90 90 90             je 086F55FCH

#82		
#83			(* THEN *)
#84		
#85				(* ( *)
#86				LD		wash_time_minutes	{LNXT:59|60|-1}
(*) UNDEF
086F55BF  0F BF 05 CC CC CC CC          movsx eax, word ptr [CCCCCCCCH] ; %M110+42

#87				MUL		60	{LNXT:59|60|-1}
(*) INT
086F55C6  B9 3C 00 00 00                mov ecx, 60
086F55CB  F7 E9                         imul ecx

#88				ST		$$TMP6	{LNXT:59|60|-1}
(*) INT
086F55CD  89 05 CC CC CC CC             mov [CCCCCCCCH], eax ; $$DATA$$+432

#89				ADR		ep_time_wash	{LNXT:59|60|-1}
(*) INT
086F55D3  B8 CC CC CC CC                mov eax, CCCCCCCCH ; %M101+4

#90				sysWriteParINT		$$TMP6	{LNXT:59|60|-1}
(*) @INT
086F55D8  FF 35 CC CC CC CC             push [CCCCCCCCH] ; $$DATA$$+432
086F55DE  8B C8                         mov ecx, eax
086F55E0  51                            push ecx
086F55E1  B9 CC CC CC CC                mov ecx, CCCCCCCCH ; sysWriteParINT
086F55E6  FF D1                         call ecx
086F55E8  81 C4 08 00 00 00             add esp, 8

#91		
#92				(* prev_wash_time_minutes:=wash_time_minutes; *)
#93				MOVE		wash_time_minutes,prev_wash_time_minutes	{LNXT:60|64|-1}
(*) BOOL
086F55EE  0F BF 05 CC CC CC CC          movsx eax, word ptr [CCCCCCCCH] ; %M110+42
086F55F5  66 89 05 CC CC CC CC          mov [CCCCCCCCH], ax ; $$DATA$$+430

#94		
#95		$label4:
#96			(* END_IF *)
#97		
#98		
#99			(* IF q_start_ats *)
#100			LD		q_start_ats	{LNXT:64|-1|-1}
(*) UNDEF
086F55FC  33 C0                         xor eax, eax
086F55FE  8A 05 CC CC CC CC             mov al, [CCCCCCCCH] ; %Q1+7

#101			NOT	{LNXT:64|-1|-1}
(*) BOOL
086F5604  84 C0                         test al, al
086F5606  0F 94 C0                      sete al

#102			JMPCN	$label5	{LNXT:64|65|67}
(-) BOOL
086F5609  84 C0                         test al, al
086F560B  90 74 16 90 90 90             je 086F5624H

#103		
#104			(* THEN *)
#105		
#106				(* downtimeIN:=true; *)
#107				MOVE		true,downtimeIN	{LNXT:65|71|-1}
(*) BOOL
086F5611  B8 01 00 00 00                mov eax, 01H
086F5616  84 C0                         test al, al
086F5618  0F 95 05 CC CC CC CC          setne [CCCCCCCCH] ; $$DATA$$+229

#108				JMP		$label6	{LNXT:64|65|67}
(-) BOOL
086F561F  EB 11 90 90 90                jmp 086F5632H

#109		$label5:
#110		
#111			(* ELSE *)
#112		
#113				(* downtimeIN:=false; *)
#114				MOVE		false,downtimeIN	{LNXT:67|71|-1}
(*) BOOL
086F5624  B8 00 00 00 00                mov eax, 00H
086F5629  84 C0                         test al, al
086F562B  0F 95 05 CC CC CC CC          setne [CCCCCCCCH] ; $$DATA$$+229

#115		
#116		$label6:
#117			(* END_IF *)
#118		
#119			(* stopping_timer *)
#120			MOVE		downtimeIN,stopping_timer.IN	{LNXT:71|-1|-1}
(*) BOOL
086F5632  33 C0                         xor eax, eax
086F5634  8A 05 CC CC CC CC             mov al, [CCCCCCCCH] ; $$DATA$$+229
086F563A  84 C0                         test al, al
086F563C  0F 95 05 CC CC CC CC          setne [CCCCCCCCH] ; $$DATA$$+244

#121			MOVE		50000,stopping_timer.PT	{LNXT:71|-1|-1}
(*) BOOL
086F5643  B8 50 C3 00 00                mov eax, C350H
086F5648  89 05 CC CC CC CC             mov [CCCCCCCCH], eax ; $$DATA$$+245

#122			CAL		stopping_timer	{LNXT:71|73|-1}
(*) UDINT
086F564E  50                            push eax
086F564F  BB CC CC CC CC                mov ebx, CCCCCCCCH ; $$DATA$$+240
086F5654  E8 80 EE FF FF                call 086F44D9H ; $$CODE$$+17625
086F5659  58                            pop eax

#123		
#124		
#125			(* IF stopping_timer.Q *)
#126			LD		stopping_timer.Q	{LNXT:73|-1|-1}
(*) UNDEF
086F565A  33 C0                         xor eax, eax
086F565C  8A 05 CC CC CC CC             mov al, [CCCCCCCCH] ; $$DATA$$+249

#127			JMPCN	$label7	{LNXT:73|74|78}
(-) BOOL
086F5662  84 C0                         test al, al
086F5664  90 74 11 90 90 90             je 086F5678H

#128		
#129			(* THEN *)
#130		
#131				(* sv_washing :=true; *)
#132				MOVE		true,sv_washing	{LNXT:74|78|-1}
(*) BOOL
086F566A  B8 01 00 00 00                mov eax, 01H
086F566F  84 C0                         test al, al
086F5671  0F 95 05 CC CC CC CC          setne [CCCCCCCCH] ; %M110+38

#133		
#134		$label7:
#135			(* END_IF *)
#136		
#137			(* Alarms.2 := i_sns_door; *)
#138			MOVE		i_sns_door,Alarms.2	{LNXT:78|81|-1}
(*) BOOL
086F5678  33 C0                         xor eax, eax
086F567A  8A 05 CC CC CC CC             mov al, [CCCCCCCCH] ; $$DATA$$+429
086F5680  84 C0                         test al, al
086F5682  90 75 11 90 90 90             jne 00000014H@
086F5688  66 0F BA 35 CC CC CC CC 02    btr word ptr [CCCCCCCCH], 2 ; %M110+32
086F5691  EB 0C 90 90 90                jmp 0000000EH@
086F5696  66 0F BA 2D CC CC CC CC 02    bts word ptr [CCCCCCCCH], 2 ; %M110+32

#139		
#140			(* Alarms.3 := i_rnpp; *)
#141			MOVE		i_rnpp,Alarms.3	{LNXT:81|87|-1}
(*) BOOL
086F569F  33 C0                         xor eax, eax
086F56A1  8A 05 CC CC CC CC             mov al, [CCCCCCCCH] ; $$DATA$$+436
086F56A7  84 C0                         test al, al
086F56A9  90 75 11 90 90 90             jne 00000014H@
086F56AF  66 0F BA 35 CC CC CC CC 03    btr word ptr [CCCCCCCCH], 3 ; %M110+32
086F56B8  EB 0C 90 90 90                jmp 0000000EH@
086F56BD  66 0F BA 2D CC CC CC CC 03    bts word ptr [CCCCCCCCH], 3 ; %M110+32

#142		
#143			(* Alarms.5 := i_no_alm_ats; *)
#144			MOVE		i_no_alm_ats,Alarms.5	{LNXT:87|104|-1}
(*) BOOL
086F56C6  33 C0                         xor eax, eax
086F56C8  8A 05 CC CC CC CC             mov al, [CCCCCCCCH] ; $$DATA$$+437
086F56CE  84 C0                         test al, al
086F56D0  90 75 11 90 90 90             jne 00000014H@
086F56D6  66 0F BA 35 CC CC CC CC 05    btr word ptr [CCCCCCCCH], 5 ; %M110+32
086F56DF  EB 0C 90 90 90                jmp 0000000EH@
086F56E4  66 0F BA 2D CC CC CC CC 05    bts word ptr [CCCCCCCCH], 5 ; %M110+32

#145		
#146		
#147			(* IF CMD.1 *)
#148			LD		CMD.1	{LNXT:104|-1|-1}
(*) UNDEF
086F56ED  33 C0                         xor eax, eax
086F56EF  66 8B 05 CC CC CC CC          mov ax, [CCCCCCCCH] ; %M110+34
086F56F6  C1 E8 01                      shr eax, 1
086F56F9  25 01 00 00 00                and eax, 1

#149			JMPCN	$label8	{LNXT:104|105|2}
(-) BOOL
086F56FE  84 C0                         test al, al
086F5700  90 74 33 90 90 90             je 086F5736H

#150		
#151			(* THEN *)
#152		
#153				(* Alarms := 0; *)
#154				MOVE		0,Alarms	{LNXT:105|106|-1}
(*) BOOL
086F5706  B8 00 00 00 00                mov eax, 00H
086F570B  66 89 05 CC CC CC CC          mov [CCCCCCCCH], ax ; %M110+32

#155		
#156				(* CMD.1 := False; *)
#157				MOVE		False,CMD.1	{LNXT:106|2|-1}
(*) WORD
086F5712  B8 00 00 00 00                mov eax, 00H
086F5717  84 C0                         test al, al
086F5719  90 75 11 90 90 90             jne 00000014H@
086F571F  66 0F BA 35 CC CC CC CC 01    btr word ptr [CCCCCCCCH], 1 ; %M110+34
086F5728  EB 0C 90 90 90                jmp 0000000EH@
086F572D  66 0F BA 2D CC CC CC CC 01    bts word ptr [CCCCCCCCH], 1 ; %M110+34

086F5736  61                            popad
086F5737  5D                            pop ebp

086F5738  C3                            ret

END_PROGRAM


**************************************************
	Target variable image generation
**************************************************


*** INPUT:
086F5739  55                            push ebp
086F573A  8B EC                         mov ebp, esp

086F573C  66 8B 0D CC CC CC CC          mov cx, [CCCCCCCCH] ; %I1+14
086F5743  66 89 0D CC CC CC CC          mov [CCCCCCCCH], cx ; $$DATA$$+418

086F574A  66 8B 0D CC CC CC CC          mov cx, [CCCCCCCCH] ; %I1+4
086F5751  66 89 0D CC CC CC CC          mov [CCCCCCCCH], cx ; $$DATA$$+420

086F5758  66 8B 0D CC CC CC CC          mov cx, [CCCCCCCCH] ; %I1+6
086F575F  66 89 0D CC CC CC CC          mov [CCCCCCCCH], cx ; $$DATA$$+422

086F5766  66 8B 0D CC CC CC CC          mov cx, [CCCCCCCCH] ; %I1+8
086F576D  66 89 0D CC CC CC CC          mov [CCCCCCCCH], cx ; $$DATA$$+424

086F5774  66 8B 0D CC CC CC CC          mov cx, [CCCCCCCCH] ; %I1+10
086F577B  66 89 0D CC CC CC CC          mov [CCCCCCCCH], cx ; $$DATA$$+426

086F5782  8A 0D CC CC CC CC             mov cl, [CCCCCCCCH] ; %I0+0
086F5788  88 0D CC CC CC CC             mov [CCCCCCCCH], cl ; $$DATA$$+428

086F578E  8A 0D CC CC CC CC             mov cl, [CCCCCCCCH] ; %I0+3
086F5794  88 0D CC CC CC CC             mov [CCCCCCCCH], cl ; $$DATA$$+429

086F579A  8A 0D CC CC CC CC             mov cl, [CCCCCCCCH] ; %I0+4
086F57A0  88 0D CC CC CC CC             mov [CCCCCCCCH], cl ; $$DATA$$+436

086F57A6  8A 0D CC CC CC CC             mov cl, [CCCCCCCCH] ; %I0+6
086F57AC  88 0D CC CC CC CC             mov [CCCCCCCCH], cl ; $$DATA$$+437

086F57B2  66 8B 0D CC CC CC CC          mov cx, [CCCCCCCCH] ; %I1+0
086F57B9  66 89 0D CC CC CC CC          mov [CCCCCCCCH], cx ; $$DATA$$+438

086F57C0  8B E5                         mov esp, ebp
086F57C2  5D                            pop ebp

086F57C3  C3                            ret


*** OUTPUT:
086F57C4  55                            push ebp
086F57C5  8B EC                         mov ebp, esp

086F57C7  8B E5                         mov esp, ebp
086F57C9  5D                            pop ebp

086F57CA  C3                            ret



**************************************************
	Task Timed init code
**************************************************

086F57CB  55                            push ebp
086F57CC  8B EC                         mov ebp, esp

Var init: V::SR_ATS_CTRL.TIME_SEC = 4000
086F57CE  66 C7 05 CC CC CC CC A0 0F    mov word ptr [CCCCCCCCH], 0FA0H ; $$DATA$$+230

086F57D7  8B E5                         mov esp, ebp
086F57D9  5D                            pop ebp

086F57DA  C3                            ret



**************************************************
	Global init code
**************************************************

086F57F0  55                            push ebp
086F57F1  8B EC                         mov ebp, esp

Var init: V:EMBEDDEDELEMENTS:$$POUCBARRAY$$BACKGROUND = [?ATS_mdb.$$POUCB$$, 0]
086F57F3  B9 CC CC CC CC                mov ecx, CCCCCCCCH ; $$DATA$$+440
086F57F8  89 0D CC CC CC CC             mov [CCCCCCCCH], ecx ; $$DATA$$+308

Var init: V:EMBEDDEDELEMENTS:$$POUCBARRAY$$BOOT = [?sr_init_counters.$$POUCB$$, 0]
086F57FE  B9 CC CC CC CC                mov ecx, CCCCCCCCH ; $$DATA$$+446
086F5803  89 0D CC CC CC CC             mov [CCCCCCCCH], ecx ; $$DATA$$+316

Var init: V:EMBEDDEDELEMENTS:$$POUCBARRAY$$INIT = [?init_val.$$POUCB$$, 0]
086F5809  B9 CC CC CC CC                mov ecx, CCCCCCCCH ; $$DATA$$+452
086F580E  89 0D CC CC CC CC             mov [CCCCCCCCH], ecx ; $$DATA$$+324

Var init: V:EMBEDDEDELEMENTS:$$POUCBARRAY$$SERV = [?InitParDB.$$POUCB$$, 0]
086F5814  B9 CC CC CC CC                mov ecx, CCCCCCCCH ; $$DATA$$+458
086F5819  89 0D CC CC CC CC             mov [CCCCCCCCH], ecx ; $$DATA$$+332

Var init: V:EMBEDDEDELEMENTS:$$POUCBARRAY$$TIMED = [?sr_pressure.$$POUCB$$, ?sr_counters.$$POUCB$$, ?sr_save_counters.$$POUCB$$, ?sr_ATS_Ctrl.$$POUCB$$, 0]
086F581F  B9 CC CC CC CC                mov ecx, CCCCCCCCH ; $$DATA$$+464
086F5824  89 0D CC CC CC CC             mov [CCCCCCCCH], ecx ; $$DATA$$+340
086F582A  B9 CC CC CC CC                mov ecx, CCCCCCCCH ; $$DATA$$+470
086F582F  89 0D CC CC CC CC             mov [CCCCCCCCH], ecx ; $$DATA$$+344
086F5835  B9 CC CC CC CC                mov ecx, CCCCCCCCH ; $$DATA$$+476
086F583A  89 0D CC CC CC CC             mov [CCCCCCCCH], ecx ; $$DATA$$+348
086F5840  B9 CC CC CC CC                mov ecx, CCCCCCCCH ; $$DATA$$+482
086F5845  89 0D CC CC CC CC             mov [CCCCCCCCH], ecx ; $$DATA$$+352

086F584B  8B E5                         mov esp, ebp
086F584D  5D                            pop ebp

086F584E  C3                            ret



**************************************************
	Global RETAIN init code
**************************************************

086F584F  55                            push ebp
086F5850  8B EC                         mov ebp, esp

086F5852  8B E5                         mov esp, ebp
086F5854  5D                            pop ebp

086F5855  C3                            ret



**************************************************
	Task $$VirtualTables init code
**************************************************

086F5856  55                            push ebp
086F5857  8B EC                         mov ebp, esp

086F5859  8B E5                         mov esp, ebp
086F585B  5D                            pop ebp

086F585C  C3                            ret



********************************************
MEMORY MAP
********************************************

Code area type:          		       main code
Start code area:          		00000000086F0000h
End code area:            		00000000086F62ACh
Code size:                		000062ACh

Start local data area:    		0000000008570000h
End local data area:      		00000000085701E8h
Local data size:          		000001E8h

Start retentive data area:		0000000000000000h
End retentive data area:  		0000000000000000h
Retentive data size:      		00000000h

Start bit data area:      		0000000000000000h
End bit data area:        		0000000000000000h
Bit data size:            		00000000h



********************************************
CODE ID:                                D0B22A11
DEBUG MEMO ID:                          000034F7
FULL MEMO ID:                           00002668
RELOCATION ADDR:                        00000000086F0000
********************************************
