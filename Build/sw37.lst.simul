***********************************************************************
*
*	CODE GENERATION LISTING FOR: sw37
*	COMPILER VERSION: 6.0.0.52
*
***********************************************************************

**************************************************
	List function block: R_TRIG
**************************************************

FUNCTION_BLOCK R_TRIG

	{ DE:"<HTML>The output Q will remain FALSE as long as the input variable CLK is FALSE.<br>
As soon as CLK returns TRUE, Q will first return TRUE.<br><br>
This means each time the function is called up, Q will return FALSE until CLK has falling edge followed by an rising edge.<br><br>
<img src= r_trig.png>" }

        VAR_INPUT
clk : BOOL;	{ DE:"Input for edge detection" }
	END_VAR

        VAR_OUTPUT
q : BOOL;	{ DE:"Raising edge output" }
	END_VAR

        VAR
m : BOOL := FALSE;
	END_VAR

END_FUNCTION_BLOCK

08894490  55                            push ebp
08894491  8B EB                         mov ebp, ebx
08894493  57                            push edi

#0		{SRC:R_TRIG}
#1		
#2			LD		clk
(*) UNDEF
08894494  33 C0                         xor eax, eax
08894496  8A 45 01                      mov al, 1[ebp]

#3			ANDN	m
(*) BOOL
08894499  33 C9                         xor ecx, ecx
0889449B  8A 4D 00                      mov cl, [ebp]
0889449E  84 C9                         test cl, cl
088944A0  0F 94 C1                      sete cl
088944A3  23 C1                         and eax, ecx

#4			ST		q
(*) BOOL
088944A5  84 C0                         test al, al
088944A7  0F 95 45 02                   setne 2[ebp]

#5		
#6			LD		clk
(*) UNDEF
088944AB  33 C0                         xor eax, eax
088944AD  8A 45 01                      mov al, 1[ebp]

#7			ST		m
(*) BOOL
088944B0  84 C0                         test al, al
088944B2  0F 95 45 00                   setne [ebp]

088944B6  5F                            pop edi
088944B7  5D                            pop ebp

088944B8  C3                            ret


Frame allocation (hex):

	0000 bit  0: VAR m
	0001 bit  0: VAR clk
	0002 bit  0: VAR q

END_FUNCTION_BLOCK
**************************************************
	List function block: TON
**************************************************

FUNCTION_BLOCK TON

	{ DE:"<HTML>The TON block produces a delayed output Q of the input IN. The delay time is expressed in milliseconds on the PT input.</br></br>
<img src= tonscheme.png>
<ul>
<li>if IN is FALSE Q is false</li>
<li>Q becomes TRUE as IN remains TRUE for PT milliseconds</li>
<li>Q remains TRUE until IN remains TRUE</li>
</ul>" }

        VAR_INPUT
IN : BOOL;	{ DE:"Timer input source" }
PT : UDINT;	{ DE:"Preset time value (ms)" }
	END_VAR

        VAR_OUTPUT
Q : BOOL;	{ DE:"Timer output" }
ET : UDINT;	{ DE:"Timer current value (ms)" }
	END_VAR

        VAR_EXTERNAL
	{G:"System_Timers"}
sysTimer AT %MD0.0 : UDINT;	{ DE:"System timer [ms]" }
	END_VAR

        VAR
timStart : UDINT;	{ DE:"Time value at start of counting" }
	END_VAR

END_FUNCTION_BLOCK

088944B9  55                            push ebp
088944BA  8B EB                         mov ebp, ebx
088944BC  57                            push edi

#0		{SRC:TON}
#1		
#2			(*	Check if in counting	*)
#3		
#4			LD		IN
(*) UNDEF
088944BD  33 C0                         xor eax, eax
088944BF  8A 45 04                      mov al, 4[ebp]

#5			JMPCN	lReset
(-) BOOL
088944C2  84 C0                         test al, al
088944C4  90 74 61 90 90 90             je 08894528H

#6		
#7			(*	Check if Q is TRUE *)
#8			LD		Q
(*) UNDEF
088944CA  33 C0                         xor eax, eax
088944CC  8A 45 09                      mov al, 9[ebp]

#9			RETC
#10			
(-) BOOL
088944CF  84 C0                         test al, al
088944D1  90 75 6A 90 90 90             jne 0889453EH

#11			(*	Check if already in counting *)
#12			LD		timStart
(*) UNDEF
088944D7  8B 45 00                      mov eax, [ebp]

#13			EQ		0
(*) UDINT
088944DA  3D 00 00 00 00                cmp eax, 0
088944DF  0F 94 C0                      sete al
088944E2  25 FF 00 00 00                and eax, 0FFh

#14			JMPCN	lUpdate
(-) BOOL
088944E7  84 C0                         test al, al
088944E9  90 74 0C 90 90 90             je 088944F8H

#15		
#16			(*	Start of counting *)
#17			LD		sysTimer
(*) UNDEF
088944EF  8B 05 CC CC CC CC             mov eax, [CCCCCCCCH] ; %M0+0

#18			ST		timStart
(*) UDINT
088944F5  89 45 00                      mov [ebp], eax

#19			
#20		lUpdate:
#21		
#22			(*	Update timer and check if time elapsed *)
#23			LD		sysTimer
(*) UNDEF
088944F8  8B 05 CC CC CC CC             mov eax, [CCCCCCCCH] ; %M0+0

#24			SUB		timStart
(*) UDINT
088944FE  2B 45 00                      sub eax, [ebp]

#25			ST		ET
(*) UDINT
08894501  89 45 0A                      mov 10[ebp], eax

#26			GE		PT
(*) UDINT
08894504  3B 45 05                      cmp eax, [ebp+5]
08894507  0F 93 C0                      setae al
0889450A  25 FF 00 00 00                and eax, 0FFh

#27			ST		Q
(*) BOOL
0889450F  84 C0                         test al, al
08894511  0F 95 45 09                   setne 9[ebp]

#28			RETCN
#29		
(-) BOOL
08894515  84 C0                         test al, al
08894517  90 74 24 90 90 90             je 0889453EH

#30			(*	Limit actual time value *)
#31			LD		PT
(*) UNDEF
0889451D  8B 45 05                      mov eax, 5[ebp]

#32			ST		ET
(*) UDINT
08894520  89 45 0A                      mov 10[ebp], eax

#33			RET
#34		
(-) UDINT
08894523  EB 19 90 90 90                jmp 0889453EH

#35		lReset:
#36		
#37			(*	Reset status *)
#38			LD		0
(*) UNDEF
08894528  B8 00 00 00 00                mov eax, 00H

#39			ST		ET
(*) USINT
0889452D  89 45 0A                      mov 10[ebp], eax

#40			ST		timStart
(*) UDINT
08894530  89 45 00                      mov [ebp], eax

#41			LD		FALSE
(*) UNDEF
08894533  B8 00 00 00 00                mov eax, 00H

#42			ST		Q
(*) BOOL
08894538  84 C0                         test al, al
0889453A  0F 95 45 09                   setne 9[ebp]

0889453E  5F                            pop edi
0889453F  5D                            pop ebp

08894540  C3                            ret


Frame allocation (hex):

	0000       : VAR timStart
	0004 bit  0: VAR IN
	0005       : VAR PT
	0009 bit  0: VAR Q
	000A       : VAR ET

END_FUNCTION_BLOCK
**************************************************
	List function block: CheckAlarmVal
**************************************************

FUNCTION_BLOCK CheckAlarmVal

        VAR_IN_OUT
di_val_open_state_fall_FB : INT^;
di_val_close_state_fall_FB : INT^;
di_val_open_state_R_FB : INT^;
di_val_close_state_R_FB : BOOL^;
Alarm_Val_FB : WORD^;
o_val_open_R_FB : BOOL^;
o_val_close_R_FB : BOOL^;
o_val_open_fall_FB : BOOL^;
o_val_close_fall_FB : BOOL^;
start_check : BOOL^;
	END_VAR

        VAR_OUTPUT
check_timer : TON;	{ DE:"локальний FB таймера" }
is_check_done : BOOL;
isOK : BOOL;
	END_VAR

        VAR
should_run_timer : BOOL;
	END_VAR

END_FUNCTION_BLOCK

08894541  55                            push ebp
08894542  8B EB                         mov ebp, ebx
08894544  57                            push edi

#0		{SRC:CheckAlarmVal}
#1		(*$WAITSWITCH$*)
#2		
#3		
#4			(* IF check_timer.IN *)
#5			LD		check_timer.IN	{LNXT:3|-1|-1}
(*) UNDEF
08894545  33 C0                         xor eax, eax
08894547  8A 45 05                      mov al, 5[ebp]

#6			JMPCN	$label0	{LNXT:3|4|8}
(-) BOOL
0889454A  84 C0                         test al, al
0889454C  90 74 19 90 90 90             je 08894568H

#7		
#8			(* THEN *)
#9		
#10				(* isOK := TRUE; *)
#11				MOVE		TRUE,isOK	{LNXT:4|5|-1}
(*) BOOL
08894552  B8 01 00 00 00                mov eax, 01H
08894557  84 C0                         test al, al
08894559  0F 95 45 18                   setne 24[ebp]

#12		
#13				(* is_check_done := false; *)
#14				MOVE		false,is_check_done	{LNXT:5|8|-1}
(*) BOOL
0889455D  B8 00 00 00 00                mov eax, 00H
08894562  84 C0                         test al, al
08894564  0F 95 45 17                   setne 23[ebp]

#15		
#16		$label0:
#17			(* END_IF *)
#18		
#19		
#20			(* IF start_check *)
#21			LD		start_check	{LNXT:8|-1|-1}
(*) UNDEF
08894568  8B 55 3D                      mov edx, 61[ebp]
0889456B  33 C0                         xor eax, eax
0889456D  8A 02                         mov al, [edx]

#22			JMPCN	$label1	{LNXT:8|9|13}
(-) BOOL
0889456F  84 C0                         test al, al
08894571  90 74 25 90 90 90             je 08894599H

#23		
#24			(* THEN *)
#25		
#26				(* check_timer *)
#27				MOVE		true,check_timer.IN	{LNXT:9|-1|-1}
(*) BOOL
08894577  B8 01 00 00 00                mov eax, 01H
0889457C  84 C0                         test al, al
0889457E  0F 95 45 05                   setne 5[ebp]

#28				MOVE		10000,check_timer.PT	{LNXT:9|-1|-1}
(*) BOOL
08894582  B8 10 27 00 00                mov eax, 2710H
08894587  89 45 06                      mov 6[ebp], eax

#29				CAL		check_timer	{LNXT:9|13|-1}
(*) UDINT
0889458A  50                            push eax
0889458B  8B DD                         mov ebx, ebp
0889458D  81 C3 01 00 00 00             add ebx, 1
08894593  E8 21 FF FF FF                call 088944B9H ; $$CODE$$+17593
08894598  58                            pop eax

#30		
#31		$label1:
#32			(* END_IF *)
#33		
#34		
#35			(* IF check_timer.Q *)
#36			LD		check_timer.Q	{LNXT:13|-1|-1}
(*) UNDEF
08894599  33 C0                         xor eax, eax
0889459B  8A 45 0A                      mov al, 10[ebp]

#37			JMPCN	$label2	{LNXT:13|15|41}
(-) BOOL
0889459E  84 C0                         test al, al
088945A0  0F 84 32 01 00 00             je 088946D8H

#38		
#39			(* THEN *)
#40		
#41				(* check_timer *)
#42				MOVE		false,check_timer.IN	{LNXT:15|-1|-1}
(*) BOOL
088945A6  B8 00 00 00 00                mov eax, 00H
088945AB  84 C0                         test al, al
088945AD  0F 95 45 05                   setne 5[ebp]

#43				CAL		check_timer	{LNXT:15|17|-1}
(*) BOOL
088945B1  50                            push eax
088945B2  8B DD                         mov ebx, ebp
088945B4  81 C3 01 00 00 00             add ebx, 1
088945BA  E8 FA FE FF FF                call 088944B9H ; $$CODE$$+17593
088945BF  58                            pop eax

#44		
#45		
#46				(* IF o_val_open_R_FB^ AND NOT di_val_open_state_R_FB^ *)
#47				LD		di_val_open_state_R_FB^	{LNXT:17|-1|-1}
(*) UNDEF
088945C0  8B 55 21                      mov edx, 33[ebp]
088945C3  0F BF 02                      movsx eax, word ptr [edx]

#48				NOT	{LNXT:17|-1|-1}
(*) INT
088945C6  66 F7 D0                      not ax

#49				AND		o_val_open_R_FB^	{LNXT:17|-1|-1}
(*) INT
088945C9  8B 55 2D                      mov edx, 45[ebp]
088945CC  33 C9                         xor ecx, ecx
088945CE  8A 0A                         mov cl, [edx]
088945D0  23 C1                         and eax, ecx

#50				JMPCN	$label3	{LNXT:17|18|21}
(-) INT
088945D2  66 85 C0                      test ax, ax
088945D5  90 74 20 90 90 90             je 088945F8H

#51		
#52				(* THEN *)
#53		
#54					(* Alarm_Val_FB^.0 := TRUE; *)
#55					MOVE		TRUE,Alarm_Val_FB^.0	{LNXT:18|21|-1}
(*) INT
088945DB  B8 01 00 00 00                mov eax, 01H
088945E0  8B 55 29                      mov edx, 41[ebp]
088945E3  84 C0                         test al, al
088945E5  90 75 0C 90 90 90             jne 0000000FH@
088945EB  0F BA 32 00                   btr [edx], 0
088945EF  EB 07 90 90 90                jmp 00000009H@
088945F4  0F BA 2A 00                   bts [edx], 0

#56		
#57		$label3:
#58				(* END_IF *)
#59		
#60		
#61				(* IF o_val_close_R_FB^ AND NOT di_val_close_state_R_FB^ *)
#62				LD		di_val_close_state_R_FB^	{LNXT:21|-1|-1}
(*) UNDEF
088945F8  8B 55 25                      mov edx, 37[ebp]
088945FB  33 C0                         xor eax, eax
088945FD  8A 02                         mov al, [edx]

#63				NOT	{LNXT:21|-1|-1}
(*) BOOL
088945FF  84 C0                         test al, al
08894601  0F 94 C0                      sete al

#64				AND		o_val_close_R_FB^	{LNXT:21|-1|-1}
(*) BOOL
08894604  8B 55 31                      mov edx, 49[ebp]
08894607  8B 55 31                      mov edx, 49[ebp]
0889460A  33 C9                         xor ecx, ecx
0889460C  8A 0A                         mov cl, [edx]
0889460E  23 C1                         and eax, ecx

#65				JMPCN	$label4	{LNXT:21|22|25}
(-) BOOL
08894610  84 C0                         test al, al
08894612  90 74 20 90 90 90             je 08894635H

#66		
#67				(* THEN *)
#68		
#69					(* Alarm_Val_FB^.1 := TRUE; *)
#70					MOVE		TRUE,Alarm_Val_FB^.1	{LNXT:22|25|-1}
(*) BOOL
08894618  B8 01 00 00 00                mov eax, 01H
0889461D  8B 55 29                      mov edx, 41[ebp]
08894620  84 C0                         test al, al
08894622  90 75 0C 90 90 90             jne 0000000FH@
08894628  0F BA 32 01                   btr [edx], 1
0889462C  EB 07 90 90 90                jmp 00000009H@
08894631  0F BA 2A 01                   bts [edx], 1

#71		
#72		$label4:
#73				(* END_IF *)
#74		
#75		
#76				(* IF o_val_open_fall_FB^ AND NOT di_val_open_state_fall_FB^ *)
#77				LD		di_val_open_state_fall_FB^	{LNXT:25|-1|-1}
(*) UNDEF
08894635  8B 55 19                      mov edx, 25[ebp]
08894638  0F BF 02                      movsx eax, word ptr [edx]

#78				NOT	{LNXT:25|-1|-1}
(*) INT
0889463B  66 F7 D0                      not ax

#79				AND		o_val_open_fall_FB^	{LNXT:25|-1|-1}
(*) INT
0889463E  8B 55 35                      mov edx, 53[ebp]
08894641  33 C9                         xor ecx, ecx
08894643  8A 0A                         mov cl, [edx]
08894645  23 C1                         and eax, ecx

#80				JMPCN	$label5	{LNXT:25|26|29}
(-) INT
08894647  66 85 C0                      test ax, ax
0889464A  90 74 20 90 90 90             je 0889466DH

#81		
#82				(* THEN *)
#83		
#84					(* Alarm_Val_FB^.2 := TRUE; *)
#85					MOVE		TRUE,Alarm_Val_FB^.2	{LNXT:26|29|-1}
(*) INT
08894650  B8 01 00 00 00                mov eax, 01H
08894655  8B 55 29                      mov edx, 41[ebp]
08894658  84 C0                         test al, al
0889465A  90 75 0C 90 90 90             jne 0000000FH@
08894660  0F BA 32 02                   btr [edx], 2
08894664  EB 07 90 90 90                jmp 00000009H@
08894669  0F BA 2A 02                   bts [edx], 2

#86		
#87		$label5:
#88				(* END_IF *)
#89		
#90		
#91				(* IF o_val_close_fall_FB^ AND NOT di_val_close_state_fall_FB^ *)
#92				LD		di_val_close_state_fall_FB^	{LNXT:29|-1|-1}
(*) UNDEF
0889466D  8B 55 1D                      mov edx, 29[ebp]
08894670  0F BF 02                      movsx eax, word ptr [edx]

#93				NOT	{LNXT:29|-1|-1}
(*) INT
08894673  66 F7 D0                      not ax

#94				AND		o_val_close_fall_FB^	{LNXT:29|-1|-1}
(*) INT
08894676  8B 55 39                      mov edx, 57[ebp]
08894679  33 C9                         xor ecx, ecx
0889467B  8A 0A                         mov cl, [edx]
0889467D  23 C1                         and eax, ecx

#95				JMPCN	$label6	{LNXT:29|30|34}
(-) INT
0889467F  66 85 C0                      test ax, ax
08894682  90 74 20 90 90 90             je 088946A5H

#96		
#97				(* THEN *)
#98		
#99					(* Alarm_Val_FB^.3 := TRUE; *)
#100					MOVE		TRUE,Alarm_Val_FB^.3	{LNXT:30|34|-1}
(*) INT
08894688  B8 01 00 00 00                mov eax, 01H
0889468D  8B 55 29                      mov edx, 41[ebp]
08894690  84 C0                         test al, al
08894692  90 75 0C 90 90 90             jne 0000000FH@
08894698  0F BA 32 03                   btr [edx], 3
0889469C  EB 07 90 90 90                jmp 00000009H@
088946A1  0F BA 2A 03                   bts [edx], 3

#101		
#102		$label6:
#103				(* END_IF *)
#104		
#105		
#106				(* IF Alarm_Val_FB^ > 0 *)
#107				LD		Alarm_Val_FB^	{LNXT:34|-1|-1}
(*) UNDEF
088946A5  8B 55 29                      mov edx, 41[ebp]
088946A8  33 C0                         xor eax, eax
088946AA  66 8B 02                      mov ax, [edx]

#108				GT		0	{LNXT:34|-1|-1}
(*) WORD
088946AD  3D 00 00 00 00                cmp eax, 0
088946B2  0F 9F C0                      setg al
088946B5  25 FF 00 00 00                and eax, 0FFh

#109				JMPCN	$label7	{LNXT:34|35|38}
(-) BOOL
088946BA  84 C0                         test al, al
088946BC  90 74 0E 90 90 90             je 088946CDH

#110		
#111				(* THEN *)
#112		
#113					(* isOK := FALSE; *)
#114					MOVE		FALSE,isOK	{LNXT:35|38|-1}
(*) BOOL
088946C2  B8 00 00 00 00                mov eax, 00H
088946C7  84 C0                         test al, al
088946C9  0F 95 45 18                   setne 24[ebp]

#115		
#116		$label7:
#117				(* END_IF *)
#118		
#119				(* is_check_done := TRUE; *)
#120				MOVE		TRUE,is_check_done	{LNXT:38|41|-1}
(*) BOOL
088946CD  B8 01 00 00 00                mov eax, 01H
088946D2  84 C0                         test al, al
088946D4  0F 95 45 17                   setne 23[ebp]

#121		
#122		$label2:
#123			(* END_IF *)
#124		
#125			(* check_timer *)
#126			CAL		check_timer	{LNXT:41|-1|-1}
(*) BOOL
088946D8  50                            push eax
088946D9  8B DD                         mov ebx, ebp
088946DB  81 C3 01 00 00 00             add ebx, 1
088946E1  E8 D3 FD FF FF                call 088944B9H ; $$CODE$$+17593
088946E6  58                            pop eax

088946E7  5F                            pop edi
088946E8  5D                            pop ebp

088946E9  C3                            ret


Frame allocation (hex):

	0000 bit  0: VAR should_run_timer
	0001       : FB check_timer
	0017 bit  0: VAR is_check_done
	0018 bit  0: VAR isOK
	0019       : VAR di_val_open_state_fall_FB
	001D       : VAR di_val_close_state_fall_FB
	0021       : VAR di_val_open_state_R_FB
	0025       : VAR di_val_close_state_R_FB
	0029       : VAR Alarm_Val_FB
	002D       : VAR o_val_open_R_FB
	0031       : VAR o_val_close_R_FB
	0035       : VAR o_val_open_fall_FB
	0039       : VAR o_val_close_fall_FB
	003D       : VAR start_check

END_FUNCTION_BLOCK
**************************************************
	List function block: CheckWashAndStart
**************************************************

FUNCTION_BLOCK CheckWashAndStart

        VAR_IN_OUT
sv_washing_FB : BOOL^;
o_val_open_R_FB : BOOL^;
o_val_close_R_FB : BOOL^;
o_val_open_fall_FB : BOOL^;
o_val_close_fall_FB : BOOL^;
q_start_ats_FB : BOOL^;
ep_time_wash_FB : INT^;
i_val_state_FB : INT^;
di_val_open_state_fall_FB : INT^;
di_val_close_state_fall_FB : INT^;
di_val_open_state_R_FB : INT^;
di_val_close_state_R_FB : BOOL^;
Alarm_Val_FB : WORD^;
	END_VAR

        VAR_OUTPUT
is_running_wash : BOOL;
	END_VAR

        VAR
washing_timer : TON;	{ DE:"локальний FB таймера" }
onWash : BOOL;
checkAlarmVal : CheckAlarmVal;
valve_rising : BOOL;
prev_val_open_fall : BOOL;
prev_val_close_fall : BOOL;
prev_val_open_R : BOOL;
prev_val_close_R : BOOL;
finish_val_rising : BOOL;
	END_VAR

END_FUNCTION_BLOCK

088946EA  55                            push ebp
088946EB  8B EB                         mov ebp, ebx
088946ED  57                            push edi

#0		{SRC:CheckWashAndStart}
#1		(*$WAITSWITCH$*)
#2		
#3		
#4			(* IF sv_washing_FB^ and i_val_state_FB^=1 *)
#5			LD		i_val_state_FB^	{LNXT:1|-1|-1}
(*) UNDEF
088946EE  8B 95 83 00 00 00             mov edx, 131[ebp]
088946F4  0F BF 02                      movsx eax, word ptr [edx]

#6			EQ		1	{LNXT:1|-1|-1}
(*) INT
088946F7  3D 01 00 00 00                cmp eax, 1
088946FC  0F 94 C0                      sete al
088946FF  25 FF 00 00 00                and eax, 0FFh

#7			AND		sv_washing_FB^	{LNXT:1|-1|-1}
(*) BOOL
08894704  8B 55 67                      mov edx, 103[ebp]
08894707  8B 55 67                      mov edx, 103[ebp]
0889470A  33 C9                         xor ecx, ecx
0889470C  8A 0A                         mov cl, [edx]
0889470E  23 C1                         and eax, ecx

#8			JMPCN	$label0	{LNXT:1|2|4}
(-) BOOL
08894710  84 C0                         test al, al
08894712  90 74 13 90 90 90             je 08894728H

#9		
#10			(* THEN *)
#11		
#12				(* onWash :=true; *)
#13				MOVE		true,onWash	{LNXT:2|7|-1}
(*) BOOL
08894718  B8 01 00 00 00                mov eax, 01H
0889471D  84 C0                         test al, al
0889471F  0F 95 45 16                   setne 22[ebp]

#14				JMP		$label1	{LNXT:1|2|4}
(-) BOOL
08894723  EB 0E 90 90 90                jmp 08894733H

#15		$label0:
#16		
#17			(* ELSE *)
#18		
#19				(* onWash :=false; *)
#20				MOVE		false,onWash	{LNXT:4|7|-1}
(*) BOOL
08894728  B8 00 00 00 00                mov eax, 00H
0889472D  84 C0                         test al, al
0889472F  0F 95 45 16                   setne 22[ebp]

#21		
#22		$label1:
#23			(* END_IF *)
#24		
#25		
#26			(* IF onWash *)
#27			LD		onWash	{LNXT:7|-1|-1}
(*) UNDEF
08894733  33 C0                         xor eax, eax
08894735  8A 45 16                      mov al, 22[ebp]

#28			JMPCN	$label2	{LNXT:7|10|53}
(-) BOOL
08894738  84 C0                         test al, al
0889473A  0F 84 87 01 00 00             je 088948C7H

#29		
#30			(* THEN *)
#31		
#32				(* is_running_wash :=true; *)
#33				MOVE		true,is_running_wash	{LNXT:10|12|-1}
(*) BOOL
08894740  B8 01 00 00 00                mov eax, 01H
08894745  84 C0                         test al, al
08894747  0F 95 45 66                   setne 102[ebp]

#34		
#35				(* prev_val_open_fall:=o_val_open_fall_FB^; *)
#36				MOVE		o_val_open_fall_FB^,prev_val_open_fall	{LNXT:12|13|-1}
(*) BOOL
0889474B  8B 55 73                      mov edx, 115[ebp]
0889474E  33 C0                         xor eax, eax
08894750  8A 02                         mov al, [edx]
08894752  84 C0                         test al, al
08894754  0F 95 45 61                   setne 97[ebp]

#37		
#38				(* prev_val_close_fall:=o_val_close_fall_FB^; *)
#39				MOVE		o_val_close_fall_FB^,prev_val_close_fall	{LNXT:13|14|-1}
(*) BOOL
08894758  8B 55 77                      mov edx, 119[ebp]
0889475B  33 C0                         xor eax, eax
0889475D  8A 02                         mov al, [edx]
0889475F  84 C0                         test al, al
08894761  0F 95 45 62                   setne 98[ebp]

#40		
#41				(* prev_val_open_R:=o_val_open_R_FB^; *)
#42				MOVE		o_val_open_R_FB^,prev_val_open_R	{LNXT:14|15|-1}
(*) BOOL
08894765  8B 55 6B                      mov edx, 107[ebp]
08894768  33 C0                         xor eax, eax
0889476A  8A 02                         mov al, [edx]
0889476C  84 C0                         test al, al
0889476E  0F 95 45 63                   setne 99[ebp]

#43		
#44				(* prev_val_close_R:=o_val_close_R_FB^; *)
#45				MOVE		o_val_close_R_FB^,prev_val_close_R	{LNXT:15|17|-1}
(*) BOOL
08894772  8B 55 6F                      mov edx, 111[ebp]
08894775  33 C0                         xor eax, eax
08894777  8A 02                         mov al, [edx]
08894779  84 C0                         test al, al
0889477B  0F 95 45 64                   setne 100[ebp]

#46		
#47				(* o_val_close_R_FB^:=true; *)
#48				MOVE		true,o_val_close_R_FB^	{LNXT:17|18|-1}
(*) BOOL
0889477F  B8 01 00 00 00                mov eax, 01H
08894784  8B 55 6F                      mov edx, 111[ebp]
08894787  84 C0                         test al, al
08894789  0F 95 02                      setne [edx]

#49		
#50				(* o_val_open_R_FB^:=false; *)
#51				MOVE		false,o_val_open_R_FB^	{LNXT:18|19|-1}
(*) BOOL
0889478C  B8 00 00 00 00                mov eax, 00H
08894791  8B 55 6B                      mov edx, 107[ebp]
08894794  84 C0                         test al, al
08894796  0F 95 02                      setne [edx]

#52		
#53				(* o_val_open_fall_FB^:=true; *)
#54				MOVE		true,o_val_open_fall_FB^	{LNXT:19|20|-1}
(*) BOOL
08894799  B8 01 00 00 00                mov eax, 01H
0889479E  8B 55 73                      mov edx, 115[ebp]
088947A1  84 C0                         test al, al
088947A3  0F 95 02                      setne [edx]

#55		
#56				(* o_val_close_fall_FB^:=false; *)
#57				MOVE		false,o_val_close_fall_FB^	{LNXT:20|22|-1}
(*) BOOL
088947A6  B8 00 00 00 00                mov eax, 00H
088947AB  8B 55 77                      mov edx, 119[ebp]
088947AE  84 C0                         test al, al
088947B0  0F 95 02                      setne [edx]

#58		
#59				(* valve_rising :=
#60		    (o_val_open_fall_FB^ AND NOT prev_val_open_fall) OR
#61			(o_val_close_fall_FB^ AND NOT prev_val_close_fall) OR
#62			(o_val_open_R_FB^ AND NOT prev_val_open_R) OR
#63			(o_val_close_R_FB^ AND NOT prev_val_close_R); *)
#64				LD		prev_val_close_R	{LNXT:22|30|-1}
(*) UNDEF
088947B3  33 C0                         xor eax, eax
088947B5  8A 45 64                      mov al, 100[ebp]

#65				NOT	{LNXT:22|30|-1}
(*) BOOL
088947B8  84 C0                         test al, al
088947BA  0F 94 C0                      sete al

#66				AND		o_val_close_R_FB^	{LNXT:22|30|-1}
(*) BOOL
088947BD  8B 55 6F                      mov edx, 111[ebp]
088947C0  8B 55 6F                      mov edx, 111[ebp]
088947C3  33 C9                         xor ecx, ecx
088947C5  8A 0A                         mov cl, [edx]
088947C7  23 C1                         and eax, ecx

#67				OR(		prev_val_open_R	{LNXT:22|30|-1}
(*) BOOL
088947C9  50                            push eax
088947CA  33 C0                         xor eax, eax
088947CC  8A 45 63                      mov al, 99[ebp]

#68				NOT	{LNXT:22|30|-1}
(*) BOOL
088947CF  84 C0                         test al, al
088947D1  0F 94 C0                      sete al

#69				AND		o_val_open_R_FB^	{LNXT:22|30|-1}
(*) BOOL
088947D4  8B 55 6B                      mov edx, 107[ebp]
088947D7  8B 55 6B                      mov edx, 107[ebp]
088947DA  33 C9                         xor ecx, ecx
088947DC  8A 0A                         mov cl, [edx]
088947DE  23 C1                         and eax, ecx

#70				OR(		prev_val_close_fall	{LNXT:22|30|-1}
(*) BOOL
088947E0  50                            push eax
088947E1  33 C0                         xor eax, eax
088947E3  8A 45 62                      mov al, 98[ebp]

#71				NOT	{LNXT:22|30|-1}
(*) BOOL
088947E6  84 C0                         test al, al
088947E8  0F 94 C0                      sete al

#72				AND		o_val_close_fall_FB^	{LNXT:22|30|-1}
(*) BOOL
088947EB  8B 55 77                      mov edx, 119[ebp]
088947EE  8B 55 77                      mov edx, 119[ebp]
088947F1  33 C9                         xor ecx, ecx
088947F3  8A 0A                         mov cl, [edx]
088947F5  23 C1                         and eax, ecx

#73				OR(		prev_val_open_fall	{LNXT:22|30|-1}
(*) BOOL
088947F7  50                            push eax
088947F8  33 C0                         xor eax, eax
088947FA  8A 45 61                      mov al, 97[ebp]

#74				NOT	{LNXT:22|30|-1}
(*) BOOL
088947FD  84 C0                         test al, al
088947FF  0F 94 C0                      sete al

#75				AND		o_val_open_fall_FB^	{LNXT:22|30|-1}
(*) BOOL
08894802  8B 55 73                      mov edx, 115[ebp]
08894805  8B 55 73                      mov edx, 115[ebp]
08894808  33 C9                         xor ecx, ecx
0889480A  8A 0A                         mov cl, [edx]
0889480C  23 C1                         and eax, ecx

#76				)	{LNXT:22|30|-1}
(*) BOOL
0889480E  8B C8                         mov ecx, eax
08894810  58                            pop eax
08894811  0B C1                         or eax, ecx

#77				)	{LNXT:22|30|-1}
(*) BOOL
08894813  8B C8                         mov ecx, eax
08894815  58                            pop eax
08894816  0B C1                         or eax, ecx

#78				)	{LNXT:22|30|-1}
(*) BOOL
08894818  8B C8                         mov ecx, eax
0889481A  58                            pop eax
0889481B  0B C1                         or eax, ecx

#79				ST		valve_rising	{LNXT:22|30|-1}
(*) BOOL
0889481D  84 C0                         test al, al
0889481F  0F 95 45 60                   setne 96[ebp]

#80		
#81				(* checkAlarmVal *)
#82				MOVE		di_val_open_state_fall_FB,checkAlarmVal.di_val_open_state_fall_FB	{LNXT:30|-1|-1}
(*) BOOL
08894823  8B 95 87 00 00 00             mov edx, 135[ebp]
08894829  8D 02                         lea eax, [edx]
0889482B  89 45 30                      mov 48[ebp], eax

#83				MOVE		di_val_close_state_fall_FB,checkAlarmVal.di_val_close_state_fall_FB	{LNXT:30|-1|-1}
(*) INT^
0889482E  8B 95 8B 00 00 00             mov edx, 139[ebp]
08894834  8D 02                         lea eax, [edx]
08894836  89 45 34                      mov 52[ebp], eax

#84				MOVE		di_val_open_state_R_FB,checkAlarmVal.di_val_open_state_R_FB	{LNXT:31|-1|-1}
(*) INT^
08894839  8B 95 8F 00 00 00             mov edx, 143[ebp]
0889483F  8D 02                         lea eax, [edx]
08894841  89 45 38                      mov 56[ebp], eax

#85				MOVE		di_val_close_state_R_FB,checkAlarmVal.di_val_close_state_R_FB	{LNXT:32|-1|-1}
(*) INT^
08894844  8B 95 93 00 00 00             mov edx, 147[ebp]
0889484A  8D 02                         lea eax, [edx]
0889484C  89 45 3C                      mov 60[ebp], eax

#86				MOVE		Alarm_Val_FB,checkAlarmVal.Alarm_Val_FB	{LNXT:33|-1|-1}
(*) BOOL^
0889484F  8B 95 97 00 00 00             mov edx, 151[ebp]
08894855  8D 02                         lea eax, [edx]
08894857  89 45 40                      mov 64[ebp], eax

#87				MOVE		o_val_open_R_FB,checkAlarmVal.o_val_open_R_FB	{LNXT:34|-1|-1}
(*) WORD^
0889485A  8B 55 6B                      mov edx, 107[ebp]
0889485D  8D 02                         lea eax, [edx]
0889485F  89 45 44                      mov 68[ebp], eax

#88				MOVE		o_val_close_R_FB,checkAlarmVal.o_val_close_R_FB	{LNXT:35|-1|-1}
(*) BOOL^
08894862  8B 55 6F                      mov edx, 111[ebp]
08894865  8D 02                         lea eax, [edx]
08894867  89 45 48                      mov 72[ebp], eax

#89				MOVE		o_val_open_fall_FB,checkAlarmVal.o_val_open_fall_FB	{LNXT:36|-1|-1}
(*) BOOL^
0889486A  8B 55 73                      mov edx, 115[ebp]
0889486D  8D 02                         lea eax, [edx]
0889486F  89 45 4C                      mov 76[ebp], eax

#90				MOVE		o_val_close_fall_FB,checkAlarmVal.o_val_close_fall_FB	{LNXT:37|-1|-1}
(*) BOOL^
08894872  8B 55 77                      mov edx, 119[ebp]
08894875  8D 02                         lea eax, [edx]
08894877  89 45 50                      mov 80[ebp], eax

#91				MOVE		valve_rising,checkAlarmVal.start_check	{LNXT:38|-1|-1}
(*) BOOL^
0889487A  8D 45 60                      lea eax, 96[ebp]
0889487D  89 45 54                      mov 84[ebp], eax

#92				CAL		checkAlarmVal	{LNXT:30|43|-1}
(*) BOOL^
08894880  50                            push eax
08894881  8B DD                         mov ebx, ebp
08894883  81 C3 17 00 00 00             add ebx, 23
08894889  E8 B3 FC FF FF                call 08894541H ; $$CODE$$+17729
0889488E  58                            pop eax

#93		
#94		
#95				(* IF checkAlarmVal.is_check_done and checkAlarmVal.isOK *)
#96				LD		checkAlarmVal.is_check_done	{LNXT:43|-1|-1}
(*) UNDEF
0889488F  33 C0                         xor eax, eax
08894891  8A 45 2E                      mov al, 46[ebp]

#97				AND		checkAlarmVal.isOK	{LNXT:43|-1|-1}
(*) BOOL
08894894  33 C9                         xor ecx, ecx
08894896  8A 4D 2F                      mov cl, 47[ebp]
08894899  23 C1                         and eax, ecx

#98				JMPCN	$label4	{LNXT:43|44|47}
(-) BOOL
0889489B  84 C0                         test al, al
0889489D  90 74 15 90 90 90             je 088948B5H

#99		
#100				(* THEN *)
#101		
#102					(* q_start_ats_FB^:=true; *)
#103					MOVE		true,q_start_ats_FB^	{LNXT:44|57|-1}
(*) BOOL
088948A3  B8 01 00 00 00                mov eax, 01H
088948A8  8B 55 7B                      mov edx, 123[ebp]
088948AB  84 C0                         test al, al
088948AD  0F 95 02                      setne [edx]

#104					JMP		$label5	{LNXT:43|44|47}
(-) BOOL
088948B0  EB 10 90 90 90                jmp 088948C2H

#105		$label4:
#106		
#107				(* ELSE *)
#108		
#109					(* q_start_ats_FB^:=false; *)
#110					MOVE		false,q_start_ats_FB^	{LNXT:47|57|-1}
(*) BOOL
088948B5  B8 00 00 00 00                mov eax, 00H
088948BA  8B 55 7B                      mov edx, 123[ebp]
088948BD  84 C0                         test al, al
088948BF  0F 95 02                      setne [edx]

#111		
#112		$label5:
#113				(* END_IF *)
#114				JMP		$label3	{LNXT:7|10|53}
(-) BOOL
088948C2  EB 10 90 90 90                jmp 088948D4H

#115		$label2:
#116		
#117			(* ELSE *)
#118		
#119				(* q_start_ats_FB^:=true; *)
#120				MOVE		true,q_start_ats_FB^	{LNXT:53|57|-1}
(*) BOOL
088948C7  B8 01 00 00 00                mov eax, 01H
088948CC  8B 55 7B                      mov edx, 123[ebp]
088948CF  84 C0                         test al, al
088948D1  0F 95 02                      setne [edx]

#121		
#122		$label3:
#123			(* END_IF *)
#124		
#125		
#126			(* IF washing_timer.Q *)
#127			LD		washing_timer.Q	{LNXT:57|-1|-1}
(*) UNDEF
088948D4  33 C0                         xor eax, eax
088948D6  8A 45 09                      mov al, 9[ebp]

#128			JMPCN	$label6	{LNXT:57|60|93}
(-) BOOL
088948D9  84 C0                         test al, al
088948DB  0F 84 F0 00 00 00             je 088949D1H

#129		
#130			(* THEN *)
#131		
#132				(* prev_val_open_fall:=o_val_open_fall_FB^; *)
#133				MOVE		o_val_open_fall_FB^,prev_val_open_fall	{LNXT:60|61|-1}
(*) BOOL
088948E1  8B 55 73                      mov edx, 115[ebp]
088948E4  33 C0                         xor eax, eax
088948E6  8A 02                         mov al, [edx]
088948E8  84 C0                         test al, al
088948EA  0F 95 45 61                   setne 97[ebp]

#134		
#135				(* prev_val_close_fall:=o_val_close_fall_FB^; *)
#136				MOVE		o_val_close_fall_FB^,prev_val_close_fall	{LNXT:61|62|-1}
(*) BOOL
088948EE  8B 55 77                      mov edx, 119[ebp]
088948F1  33 C0                         xor eax, eax
088948F3  8A 02                         mov al, [edx]
088948F5  84 C0                         test al, al
088948F7  0F 95 45 62                   setne 98[ebp]

#137		
#138				(* prev_val_open_R:=o_val_open_R_FB^; *)
#139				MOVE		o_val_open_R_FB^,prev_val_open_R	{LNXT:62|63|-1}
(*) BOOL
088948FB  8B 55 6B                      mov edx, 107[ebp]
088948FE  33 C0                         xor eax, eax
08894900  8A 02                         mov al, [edx]
08894902  84 C0                         test al, al
08894904  0F 95 45 63                   setne 99[ebp]

#140		
#141				(* prev_val_close_R:=o_val_close_R_FB^; *)
#142				MOVE		o_val_close_R_FB^,prev_val_close_R	{LNXT:63|66|-1}
(*) BOOL
08894908  8B 55 6F                      mov edx, 111[ebp]
0889490B  33 C0                         xor eax, eax
0889490D  8A 02                         mov al, [edx]
0889490F  84 C0                         test al, al
08894911  0F 95 45 64                   setne 100[ebp]

#143		
#144				(* o_val_close_R_FB^:=false; *)
#145				MOVE		false,o_val_close_R_FB^	{LNXT:66|67|-1}
(*) BOOL
08894915  B8 00 00 00 00                mov eax, 00H
0889491A  8B 55 6F                      mov edx, 111[ebp]
0889491D  84 C0                         test al, al
0889491F  0F 95 02                      setne [edx]

#146		
#147				(* o_val_open_fall_FB^:=false; *)
#148				MOVE		false,o_val_open_fall_FB^	{LNXT:67|69|-1}
(*) BOOL
08894922  B8 00 00 00 00                mov eax, 00H
08894927  8B 55 73                      mov edx, 115[ebp]
0889492A  84 C0                         test al, al
0889492C  0F 95 02                      setne [edx]

#149		
#150				(* o_val_open_R_FB^:=true; *)
#151				MOVE		true,o_val_open_R_FB^	{LNXT:69|70|-1}
(*) BOOL
0889492F  B8 01 00 00 00                mov eax, 01H
08894934  8B 55 6B                      mov edx, 107[ebp]
08894937  84 C0                         test al, al
08894939  0F 95 02                      setne [edx]

#152		
#153				(* o_val_close_fall_FB^:=true; *)
#154				MOVE		true,o_val_close_fall_FB^	{LNXT:70|72|-1}
(*) BOOL
0889493C  B8 01 00 00 00                mov eax, 01H
08894941  8B 55 77                      mov edx, 119[ebp]
08894944  84 C0                         test al, al
08894946  0F 95 02                      setne [edx]

#155		
#156				(* valve_rising :=
#157		    (o_val_open_fall_FB^ AND NOT prev_val_open_fall) OR
#158			(o_val_close_fall_FB^ AND NOT prev_val_close_fall) OR
#159			(o_val_open_R_FB^ AND NOT prev_val_open_R) OR
#160			(o_val_close_R_FB^ AND NOT prev_val_close_R); *)
#161				LD		prev_val_close_R	{LNXT:72|78|-1}
(*) UNDEF
08894949  33 C0                         xor eax, eax
0889494B  8A 45 64                      mov al, 100[ebp]

#162				NOT	{LNXT:72|78|-1}
(*) BOOL
0889494E  84 C0                         test al, al
08894950  0F 94 C0                      sete al

#163				AND		o_val_close_R_FB^	{LNXT:72|78|-1}
(*) BOOL
08894953  8B 55 6F                      mov edx, 111[ebp]
08894956  8B 55 6F                      mov edx, 111[ebp]
08894959  33 C9                         xor ecx, ecx
0889495B  8A 0A                         mov cl, [edx]
0889495D  23 C1                         and eax, ecx

#164				OR(		prev_val_open_R	{LNXT:72|78|-1}
(*) BOOL
0889495F  50                            push eax
08894960  33 C0                         xor eax, eax
08894962  8A 45 63                      mov al, 99[ebp]

#165				NOT	{LNXT:72|78|-1}
(*) BOOL
08894965  84 C0                         test al, al
08894967  0F 94 C0                      sete al

#166				AND		o_val_open_R_FB^	{LNXT:72|78|-1}
(*) BOOL
0889496A  8B 55 6B                      mov edx, 107[ebp]
0889496D  8B 55 6B                      mov edx, 107[ebp]
08894970  33 C9                         xor ecx, ecx
08894972  8A 0A                         mov cl, [edx]
08894974  23 C1                         and eax, ecx

#167				OR(		prev_val_close_fall	{LNXT:72|78|-1}
(*) BOOL
08894976  50                            push eax
08894977  33 C0                         xor eax, eax
08894979  8A 45 62                      mov al, 98[ebp]

#168				NOT	{LNXT:72|78|-1}
(*) BOOL
0889497C  84 C0                         test al, al
0889497E  0F 94 C0                      sete al

#169				AND		o_val_close_fall_FB^	{LNXT:72|78|-1}
(*) BOOL
08894981  8B 55 77                      mov edx, 119[ebp]
08894984  8B 55 77                      mov edx, 119[ebp]
08894987  33 C9                         xor ecx, ecx
08894989  8A 0A                         mov cl, [edx]
0889498B  23 C1                         and eax, ecx

#170				OR(		prev_val_open_fall	{LNXT:72|78|-1}
(*) BOOL
0889498D  50                            push eax
0889498E  33 C0                         xor eax, eax
08894990  8A 45 61                      mov al, 97[ebp]

#171				NOT	{LNXT:72|78|-1}
(*) BOOL
08894993  84 C0                         test al, al
08894995  0F 94 C0                      sete al

#172				AND		o_val_open_fall_FB^	{LNXT:72|78|-1}
(*) BOOL
08894998  8B 55 73                      mov edx, 115[ebp]
0889499B  8B 55 73                      mov edx, 115[ebp]
0889499E  33 C9                         xor ecx, ecx
088949A0  8A 0A                         mov cl, [edx]
088949A2  23 C1                         and eax, ecx

#173				)	{LNXT:72|78|-1}
(*) BOOL
088949A4  8B C8                         mov ecx, eax
088949A6  58                            pop eax
088949A7  0B C1                         or eax, ecx

#174				)	{LNXT:72|78|-1}
(*) BOOL
088949A9  8B C8                         mov ecx, eax
088949AB  58                            pop eax
088949AC  0B C1                         or eax, ecx

#175				)	{LNXT:72|78|-1}
(*) BOOL
088949AE  8B C8                         mov ecx, eax
088949B0  58                            pop eax
088949B1  0B C1                         or eax, ecx

#176				ST		valve_rising	{LNXT:72|78|-1}
(*) BOOL
088949B3  84 C0                         test al, al
088949B5  0F 95 45 60                   setne 96[ebp]

#177		
#178		
#179				(* IF valve_rising *)
#180				LD		valve_rising	{LNXT:78|-1|-1}
(*) UNDEF
088949B9  33 C0                         xor eax, eax
088949BB  8A 45 60                      mov al, 96[ebp]

#181				JMPCN	$label7	{LNXT:78|79|93}
(-) BOOL
088949BE  84 C0                         test al, al
088949C0  90 74 0E 90 90 90             je 088949D1H

#182		
#183				(* THEN *)
#184		
#185					(* finish_val_rising :=true; *)
#186					MOVE		true,finish_val_rising	{LNXT:79|93|-1}
(*) BOOL
088949C6  B8 01 00 00 00                mov eax, 01H
088949CB  84 C0                         test al, al
088949CD  0F 95 45 65                   setne 101[ebp]

#187		
#188		$label7:
#189				(* END_IF *)
#190		
#191		$label6:
#192			(* END_IF *)
#193		
#194		
#195			(* IF finish_val_rising *)
#196			LD		finish_val_rising	{LNXT:93|-1|-1}
(*) UNDEF
088949D1  33 C0                         xor eax, eax
088949D3  8A 45 65                      mov al, 101[ebp]

#197			JMPCN	$label8	{LNXT:93|94|98}
(-) BOOL
088949D6  84 C0                         test al, al
088949D8  90 74 1B 90 90 90             je 088949F6H

#198		
#199			(* THEN *)
#200		
#201				(* sv_washing_FB^:=false; *)
#202				MOVE		false,sv_washing_FB^	{LNXT:94|95|-1}
(*) BOOL
088949DE  B8 00 00 00 00                mov eax, 00H
088949E3  8B 55 67                      mov edx, 103[ebp]
088949E6  84 C0                         test al, al
088949E8  0F 95 02                      setne [edx]

#203		
#204				(* onWash :=false; *)
#205				MOVE		false,onWash	{LNXT:95|98|-1}
(*) BOOL
088949EB  B8 00 00 00 00                mov eax, 00H
088949F0  84 C0                         test al, al
088949F2  0F 95 45 16                   setne 22[ebp]

#206		
#207		$label8:
#208			(* END_IF *)
#209		
#210		
#211			(* IF checkAlarmVal.check_timer.Q *)
#212			LD		checkAlarmVal.check_timer.Q	{LNXT:98|-1|-1}
(*) UNDEF
088949F6  33 C0                         xor eax, eax
088949F8  8A 45 21                      mov al, 33[ebp]

#213			JMPCN	$label9	{LNXT:98|100|106}
(-) BOOL
088949FB  84 C0                         test al, al
088949FD  90 74 0E 90 90 90             je 08894A0EH

#214		
#215			(* THEN *)
#216		
#217				(* is_running_wash :=false; *)
#218				MOVE		false,is_running_wash	{LNXT:100|106|-1}
(*) BOOL
08894A03  B8 00 00 00 00                mov eax, 00H
08894A08  84 C0                         test al, al
08894A0A  0F 95 45 66                   setne 102[ebp]

#219		
#220		$label9:
#221			(* END_IF *)
#222		
#223			(* checkAlarmVal *)
#224			MOVE		di_val_open_state_fall_FB,checkAlarmVal.di_val_open_state_fall_FB	{LNXT:106|-1|-1}
(*) BOOL
08894A0E  8B 95 87 00 00 00             mov edx, 135[ebp]
08894A14  8D 02                         lea eax, [edx]
08894A16  89 45 30                      mov 48[ebp], eax

#225			MOVE		di_val_close_state_fall_FB,checkAlarmVal.di_val_close_state_fall_FB	{LNXT:106|-1|-1}
(*) INT^
08894A19  8B 95 8B 00 00 00             mov edx, 139[ebp]
08894A1F  8D 02                         lea eax, [edx]
08894A21  89 45 34                      mov 52[ebp], eax

#226			MOVE		di_val_open_state_R_FB,checkAlarmVal.di_val_open_state_R_FB	{LNXT:107|-1|-1}
(*) INT^
08894A24  8B 95 8F 00 00 00             mov edx, 143[ebp]
08894A2A  8D 02                         lea eax, [edx]
08894A2C  89 45 38                      mov 56[ebp], eax

#227			MOVE		di_val_close_state_R_FB,checkAlarmVal.di_val_close_state_R_FB	{LNXT:108|-1|-1}
(*) INT^
08894A2F  8B 95 93 00 00 00             mov edx, 147[ebp]
08894A35  8D 02                         lea eax, [edx]
08894A37  89 45 3C                      mov 60[ebp], eax

#228			MOVE		Alarm_Val_FB,checkAlarmVal.Alarm_Val_FB	{LNXT:109|-1|-1}
(*) BOOL^
08894A3A  8B 95 97 00 00 00             mov edx, 151[ebp]
08894A40  8D 02                         lea eax, [edx]
08894A42  89 45 40                      mov 64[ebp], eax

#229			MOVE		o_val_open_R_FB,checkAlarmVal.o_val_open_R_FB	{LNXT:110|-1|-1}
(*) WORD^
08894A45  8B 55 6B                      mov edx, 107[ebp]
08894A48  8D 02                         lea eax, [edx]
08894A4A  89 45 44                      mov 68[ebp], eax

#230			MOVE		o_val_close_R_FB,checkAlarmVal.o_val_close_R_FB	{LNXT:111|-1|-1}
(*) BOOL^
08894A4D  8B 55 6F                      mov edx, 111[ebp]
08894A50  8D 02                         lea eax, [edx]
08894A52  89 45 48                      mov 72[ebp], eax

#231			MOVE		o_val_open_fall_FB,checkAlarmVal.o_val_open_fall_FB	{LNXT:112|-1|-1}
(*) BOOL^
08894A55  8B 55 73                      mov edx, 115[ebp]
08894A58  8D 02                         lea eax, [edx]
08894A5A  89 45 4C                      mov 76[ebp], eax

#232			MOVE		o_val_close_fall_FB,checkAlarmVal.o_val_close_fall_FB	{LNXT:113|-1|-1}
(*) BOOL^
08894A5D  8B 55 77                      mov edx, 119[ebp]
08894A60  8D 02                         lea eax, [edx]
08894A62  89 45 50                      mov 80[ebp], eax

#233			MOVE		finish_val_rising,checkAlarmVal.start_check	{LNXT:114|-1|-1}
(*) BOOL^
08894A65  8D 45 65                      lea eax, 101[ebp]
08894A68  89 45 54                      mov 84[ebp], eax

#234			CAL		checkAlarmVal	{LNXT:106|117|-1}
(*) BOOL^
08894A6B  50                            push eax
08894A6C  8B DD                         mov ebx, ebp
08894A6E  81 C3 17 00 00 00             add ebx, 23
08894A74  E8 C8 FA FF FF                call 08894541H ; $$CODE$$+17729
08894A79  58                            pop eax

#235		
#236		
#237			(* IF finish_val_rising *)
#238			LD		finish_val_rising	{LNXT:117|-1|-1}
(*) UNDEF
08894A7A  33 C0                         xor eax, eax
08894A7C  8A 45 65                      mov al, 101[ebp]

#239			JMPCN	$label10	{LNXT:117|118|121}
(-) BOOL
08894A7F  84 C0                         test al, al
08894A81  90 74 0E 90 90 90             je 08894A92H

#240		
#241			(* THEN *)
#242		
#243				(* finish_val_rising:=false; *)
#244				MOVE		false,finish_val_rising	{LNXT:118|121|-1}
(*) BOOL
08894A87  B8 00 00 00 00                mov eax, 00H
08894A8C  84 C0                         test al, al
08894A8E  0F 95 45 65                   setne 101[ebp]

#245		
#246		$label10:
#247			(* END_IF *)
#248		
#249			(* washing_timer *)
#250			LD		onWash	{LNXT:121|-1|-1}
(*) UNDEF
08894A92  33 C0                         xor eax, eax
08894A94  8A 45 16                      mov al, 22[ebp]

#251			AND		q_start_ats_FB^	{LNXT:121|-1|-1}
(*) BOOL
08894A97  8B 55 7B                      mov edx, 123[ebp]
08894A9A  8B 55 7B                      mov edx, 123[ebp]
08894A9D  33 C9                         xor ecx, ecx
08894A9F  8A 0A                         mov cl, [edx]
08894AA1  23 C1                         and eax, ecx

#252			ST		washing_timer.IN	{LNXT:121|-1|-1}
(*) BOOL
08894AA3  84 C0                         test al, al
08894AA5  0F 95 45 04                   setne 4[ebp]

#253			MOVE		ep_time_wash_FB^,washing_timer.PT	{LNXT:121|-1|-1}
(*) BOOL
08894AA9  8B 55 7F                      mov edx, 127[ebp]
08894AAC  0F BF 02                      movsx eax, word ptr [edx]
08894AAF  89 45 05                      mov 5[ebp], eax

#254			CAL		washing_timer	{LNXT:121|-1|-1}
(*) INT
08894AB2  50                            push eax
08894AB3  8B DD                         mov ebx, ebp
08894AB5  E8 FF F9 FF FF                call 088944B9H ; $$CODE$$+17593
08894ABA  58                            pop eax

08894ABB  5F                            pop edi
08894ABC  5D                            pop ebp

08894ABD  C3                            ret


Frame allocation (hex):

	0000       : FB washing_timer
	0016 bit  0: VAR onWash
	0017       : FB checkAlarmVal
	0060 bit  0: VAR valve_rising
	0061 bit  0: VAR prev_val_open_fall
	0062 bit  0: VAR prev_val_close_fall
	0063 bit  0: VAR prev_val_open_R
	0064 bit  0: VAR prev_val_close_R
	0065 bit  0: VAR finish_val_rising
	0066 bit  0: VAR is_running_wash
	0067       : VAR sv_washing_FB
	006B       : VAR o_val_open_R_FB
	006F       : VAR o_val_close_R_FB
	0073       : VAR o_val_open_fall_FB
	0077       : VAR o_val_close_fall_FB
	007B       : VAR q_start_ats_FB
	007F       : VAR ep_time_wash_FB
	0083       : VAR i_val_state_FB
	0087       : VAR di_val_open_state_fall_FB
	008B       : VAR di_val_close_state_fall_FB
	008F       : VAR di_val_open_state_R_FB
	0093       : VAR di_val_close_state_R_FB
	0097       : VAR Alarm_Val_FB

END_FUNCTION_BLOCK
**************************************************
	List program: ATS_mdb
**************************************************

PROGRAM ATS_mdb

        VAR
res_eta_lcr : UINT;
resp_eta_lcr : ARRAY[0..3] OF INT;
res : INT;
xTON : TON;
	END_VAR

END_PROGRAM

08894AC0  55                            push ebp
08894AC1  8B EC                         mov ebp, esp
08894AC3  60                            pushad

#0		{SRC:ATS_mdb}
#1		(*$WAITSWITCH$*)
#2		
#3			(* res := sysMbMRTU_FC03(	addr := 1, 
#4											base := 257, // 256
#5											no := 4, 
#6											object := ADR(resp_eta_lcr), 
#7											timeout := 200); *)
#8			ADR		resp_eta_lcr	{LNXT:2|8|-1}
(*) UDINT
08894AC4  B8 CC CC CC CC                mov eax, CCCCCCCCH ; $$DATA$$+12

#9			ST		$$TMP0	{LNXT:2|8|-1}
(*) @INT
08894AC9  89 05 CC CC CC CC             mov [CCCCCCCCH], eax ; $$DATA$$+20

#10			LDP0		1	{LNXT:2|8|-1}
(*) @INT
#11			sysMbMRTU_FC03		257, 4, $$TMP0, 200	{LNXT:2|8|-1}
(*) @INT
08894ACF  68 C8 00 00 00                push 200
08894AD4  FF 35 CC CC CC CC             push [CCCCCCCCH] ; $$DATA$$+20
08894ADA  68 04 00 00 00                push 4
08894ADF  68 01 01 00 00                push 257
08894AE4  68 01 00 00 00                push 1
08894AE9  B9 CC CC CC CC                mov ecx, CCCCCCCCH ; sysMbMRTU_FC03
08894AEE  FF D1                         call ecx
08894AF0  81 C4 14 00 00 00             add esp, 20

#12			ST		res	{LNXT:2|8|-1}
(*) UINT
08894AF6  66 89 05 CC CC CC CC          mov [CCCCCCCCH], ax ; $$DATA$$+24

#13		
#14			(* ATS22_DUT.Ready 	:= to_bool(resp_eta_lcr[0] And 16#01); *)
#15			LD		resp_eta_lcr[0]	{LNXT:8|9|-1}
(*) UNDEF
08894AFD  0F BF 05 CC CC CC CC          movsx eax, word ptr [CCCCCCCCH] ; $$DATA$$+12

#16			AND		16#01	{LNXT:8|9|-1}
(*) INT
08894B04  25 01 00 00 00                and eax, 00000001H

#17			to_bool	{LNXT:8|9|-1}
(*) INT
08894B09  66 85 C0                      test ax, ax
08894B0C  0F 95 C0                      setne al

#18			ST		ATS22_DUT.Ready	{LNXT:8|9|-1}
(*) BOOL
08894B0F  84 C0                         test al, al
08894B11  0F 95 05 CC CC CC CC          setne [CCCCCCCCH] ; $$DATA$$+26

#19		
#20			(* ATS22_DUT.On 		:= to_bool(resp_eta_lcr[0] And 16#02); *)
#21			LD		resp_eta_lcr[0]	{LNXT:9|10|-1}
(*) UNDEF
08894B18  0F BF 05 CC CC CC CC          movsx eax, word ptr [CCCCCCCCH] ; $$DATA$$+12

#22			AND		16#02	{LNXT:9|10|-1}
(*) INT
08894B1F  25 02 00 00 00                and eax, 00000002H

#23			to_bool	{LNXT:9|10|-1}
(*) INT
08894B24  66 85 C0                      test ax, ax
08894B27  0F 95 C0                      setne al

#24			ST		ATS22_DUT.On	{LNXT:9|10|-1}
(*) BOOL
08894B2A  84 C0                         test al, al
08894B2C  0F 95 05 CC CC CC CC          setne [CCCCCCCCH] ; $$DATA$$+27

#25		
#26			(* ATS22_DUT.Trip 		:= to_bool(resp_eta_lcr[0] And 16#04); *)
#27			LD		resp_eta_lcr[0]	{LNXT:10|11|-1}
(*) UNDEF
08894B33  0F BF 05 CC CC CC CC          movsx eax, word ptr [CCCCCCCCH] ; $$DATA$$+12

#28			AND		16#04	{LNXT:10|11|-1}
(*) INT
08894B3A  25 04 00 00 00                and eax, 00000004H

#29			to_bool	{LNXT:10|11|-1}
(*) INT
08894B3F  66 85 C0                      test ax, ax
08894B42  0F 95 C0                      setne al

#30			ST		ATS22_DUT.Trip	{LNXT:10|11|-1}
(*) BOOL
08894B45  84 C0                         test al, al
08894B47  0F 95 05 CC CC CC CC          setne [CCCCCCCCH] ; $$DATA$$+28

#31		
#32			(* ATS22_DUT.Warning 	:= to_bool(resp_eta_lcr[0] And 16#08); *)
#33			LD		resp_eta_lcr[0]	{LNXT:11|12|-1}
(*) UNDEF
08894B4E  0F BF 05 CC CC CC CC          movsx eax, word ptr [CCCCCCCCH] ; $$DATA$$+12

#34			AND		16#08	{LNXT:11|12|-1}
(*) INT
08894B55  25 08 00 00 00                and eax, 00000008H

#35			to_bool	{LNXT:11|12|-1}
(*) INT
08894B5A  66 85 C0                      test ax, ax
08894B5D  0F 95 C0                      setne al

#36			ST		ATS22_DUT.Warning	{LNXT:11|12|-1}
(*) BOOL
08894B60  84 C0                         test al, al
08894B62  0F 95 05 CC CC CC CC          setne [CCCCCCCCH] ; $$DATA$$+29

#37		
#38			(* ATS22_DUT.LI3 		:= to_bool(resp_eta_lcr[0] And 16#20); *)
#39			LD		resp_eta_lcr[0]	{LNXT:12|13|-1}
(*) UNDEF
08894B69  0F BF 05 CC CC CC CC          movsx eax, word ptr [CCCCCCCCH] ; $$DATA$$+12

#40			AND		16#20	{LNXT:12|13|-1}
(*) INT
08894B70  25 20 00 00 00                and eax, 00000020H

#41			to_bool	{LNXT:12|13|-1}
(*) INT
08894B75  66 85 C0                      test ax, ax
08894B78  0F 95 C0                      setne al

#42			ST		ATS22_DUT.LI3	{LNXT:12|13|-1}
(*) BOOL
08894B7B  84 C0                         test al, al
08894B7D  0F 95 05 CC CC CC CC          setne [CCCCCCCCH] ; $$DATA$$+30

#43		
#44			(* ATS22_DUT.LI2 		:= to_bool(resp_eta_lcr[0] And 16#40); *)
#45			LD		resp_eta_lcr[0]	{LNXT:13|14|-1}
(*) UNDEF
08894B84  0F BF 05 CC CC CC CC          movsx eax, word ptr [CCCCCCCCH] ; $$DATA$$+12

#46			AND		16#40	{LNXT:13|14|-1}
(*) INT
08894B8B  25 40 00 00 00                and eax, 00000040H

#47			to_bool	{LNXT:13|14|-1}
(*) INT
08894B90  66 85 C0                      test ax, ax
08894B93  0F 95 C0                      setne al

#48			ST		ATS22_DUT.LI2	{LNXT:13|14|-1}
(*) BOOL
08894B96  84 C0                         test al, al
08894B98  0F 95 05 CC CC CC CC          setne [CCCCCCCCH] ; $$DATA$$+31

#49		
#50			(* ATS22_DUT.LI1 		:= to_bool(resp_eta_lcr[0] And 16#80); *)
#51			LD		resp_eta_lcr[0]	{LNXT:14|17|-1}
(*) UNDEF
08894B9F  0F BF 05 CC CC CC CC          movsx eax, word ptr [CCCCCCCCH] ; $$DATA$$+12

#52			AND		16#80	{LNXT:14|17|-1}
(*) INT
08894BA6  25 80 00 00 00                and eax, 00000080H

#53			to_bool	{LNXT:14|17|-1}
(*) INT
08894BAB  66 85 C0                      test ax, ax
08894BAE  0F 95 C0                      setne al

#54			ST		ATS22_DUT.LI1	{LNXT:14|17|-1}
(*) BOOL
08894BB1  84 C0                         test al, al
08894BB3  0F 95 05 CC CC CC CC          setne [CCCCCCCCH] ; $$DATA$$+32

#55		
#56			(* ATS_State_bits.0 := ATS22_DUT.Ready; *)
#57			MOVE		ATS22_DUT.Ready,ATS_State_bits.0	{LNXT:17|18|-1}
(*) BOOL
08894BBA  33 C0                         xor eax, eax
08894BBC  8A 05 CC CC CC CC             mov al, [CCCCCCCCH] ; $$DATA$$+26
08894BC2  84 C0                         test al, al
08894BC4  90 75 11 90 90 90             jne 00000014H@
08894BCA  66 0F BA 35 CC CC CC CC 00    btr word ptr [CCCCCCCCH], 0 ; %M110+16
08894BD3  EB 0C 90 90 90                jmp 0000000EH@
08894BD8  66 0F BA 2D CC CC CC CC 00    bts word ptr [CCCCCCCCH], 0 ; %M110+16

#58		
#59			(* ATS_State_bits.1 := ATS22_DUT.On And i_run_ats; *)
#60			LD		ATS22_DUT.On	{LNXT:18|19|-1}
(*) UNDEF
08894BE1  33 C0                         xor eax, eax
08894BE3  8A 05 CC CC CC CC             mov al, [CCCCCCCCH] ; $$DATA$$+27

#61			AND		i_run_ats	{LNXT:18|19|-1}
(*) BOOL
08894BE9  33 C9                         xor ecx, ecx
08894BEB  8A 0D CC CC CC CC             mov cl, [CCCCCCCCH] ; $$DATA$$+52
08894BF1  23 C1                         and eax, ecx

#62			ST		ATS_State_bits.1	{LNXT:18|19|-1}
(*) BOOL
08894BF3  84 C0                         test al, al
08894BF5  90 75 11 90 90 90             jne 00000014H@
08894BFB  66 0F BA 35 CC CC CC CC 01    btr word ptr [CCCCCCCCH], 1 ; %M110+16
08894C04  EB 0C 90 90 90                jmp 0000000EH@
08894C09  66 0F BA 2D CC CC CC CC 01    bts word ptr [CCCCCCCCH], 1 ; %M110+16

#63		
#64			(* ATS_State_bits.2 := ATS22_DUT.Trip Or Not i_no_alm_ats ; *)
#65			LD		i_no_alm_ats	{LNXT:19|20|-1}
(*) UNDEF
08894C12  33 C0                         xor eax, eax
08894C14  8A 05 CC CC CC CC             mov al, [CCCCCCCCH] ; $$DATA$$+53

#66			NOT	{LNXT:19|20|-1}
(*) BOOL
08894C1A  84 C0                         test al, al
08894C1C  0F 94 C0                      sete al

#67			OR		ATS22_DUT.Trip	{LNXT:19|20|-1}
(*) BOOL
08894C1F  33 C9                         xor ecx, ecx
08894C21  8A 0D CC CC CC CC             mov cl, [CCCCCCCCH] ; $$DATA$$+28
08894C27  0B C1                         or eax, ecx

#68			ST		ATS_State_bits.2	{LNXT:19|20|-1}
(*) BOOL
08894C29  84 C0                         test al, al
08894C2B  90 75 11 90 90 90             jne 00000014H@
08894C31  66 0F BA 35 CC CC CC CC 02    btr word ptr [CCCCCCCCH], 2 ; %M110+16
08894C3A  EB 0C 90 90 90                jmp 0000000EH@
08894C3F  66 0F BA 2D CC CC CC CC 02    bts word ptr [CCCCCCCCH], 2 ; %M110+16

#69		
#70			(* ATS_State_bits.3 := ATS22_DUT.Warning; *)
#71			MOVE		ATS22_DUT.Warning,ATS_State_bits.3	{LNXT:20|21|-1}
(*) BOOL
08894C48  33 C0                         xor eax, eax
08894C4A  8A 05 CC CC CC CC             mov al, [CCCCCCCCH] ; $$DATA$$+29
08894C50  84 C0                         test al, al
08894C52  90 75 11 90 90 90             jne 00000014H@
08894C58  66 0F BA 35 CC CC CC CC 03    btr word ptr [CCCCCCCCH], 3 ; %M110+16
08894C61  EB 0C 90 90 90                jmp 0000000EH@
08894C66  66 0F BA 2D CC CC CC CC 03    bts word ptr [CCCCCCCCH], 3 ; %M110+16

#72		
#73			(* ATS_State_bits.4 := ATS22_DUT.Local; *)
#74			MOVE		ATS22_DUT.Local,ATS_State_bits.4	{LNXT:21|22|-1}
(*) BOOL
08894C6F  33 C0                         xor eax, eax
08894C71  8A 05 CC CC CC CC             mov al, [CCCCCCCCH] ; $$DATA$$+34
08894C77  84 C0                         test al, al
08894C79  90 75 11 90 90 90             jne 00000014H@
08894C7F  66 0F BA 35 CC CC CC CC 04    btr word ptr [CCCCCCCCH], 4 ; %M110+16
08894C88  EB 0C 90 90 90                jmp 0000000EH@
08894C8D  66 0F BA 2D CC CC CC CC 04    bts word ptr [CCCCCCCCH], 4 ; %M110+16

#75		
#76			(* ATS_State_bits.5 := ATS22_DUT.Ramping; *)
#77			MOVE		ATS22_DUT.Ramping,ATS_State_bits.5	{LNXT:22|23|-1}
(*) BOOL
08894C96  33 C0                         xor eax, eax
08894C98  8A 05 CC CC CC CC             mov al, [CCCCCCCCH] ; $$DATA$$+35
08894C9E  84 C0                         test al, al
08894CA0  90 75 11 90 90 90             jne 00000014H@
08894CA6  66 0F BA 35 CC CC CC CC 05    btr word ptr [CCCCCCCCH], 5 ; %M110+16
08894CAF  EB 0C 90 90 90                jmp 0000000EH@
08894CB4  66 0F BA 2D CC CC CC CC 05    bts word ptr [CCCCCCCCH], 5 ; %M110+16

#78		
#79			(* ATS_State_bits.6 := ATS22_DUT.LI1; *)
#80			MOVE		ATS22_DUT.LI1,ATS_State_bits.6	{LNXT:23|24|-1}
(*) BOOL
08894CBD  33 C0                         xor eax, eax
08894CBF  8A 05 CC CC CC CC             mov al, [CCCCCCCCH] ; $$DATA$$+32
08894CC5  84 C0                         test al, al
08894CC7  90 75 11 90 90 90             jne 00000014H@
08894CCD  66 0F BA 35 CC CC CC CC 06    btr word ptr [CCCCCCCCH], 6 ; %M110+16
08894CD6  EB 0C 90 90 90                jmp 0000000EH@
08894CDB  66 0F BA 2D CC CC CC CC 06    bts word ptr [CCCCCCCCH], 6 ; %M110+16

#81		
#82			(* ATS_State_bits.7 := ATS22_DUT.LI2; *)
#83			MOVE		ATS22_DUT.LI2,ATS_State_bits.7	{LNXT:24|25|-1}
(*) BOOL
08894CE4  33 C0                         xor eax, eax
08894CE6  8A 05 CC CC CC CC             mov al, [CCCCCCCCH] ; $$DATA$$+31
08894CEC  84 C0                         test al, al
08894CEE  90 75 11 90 90 90             jne 00000014H@
08894CF4  66 0F BA 35 CC CC CC CC 07    btr word ptr [CCCCCCCCH], 7 ; %M110+16
08894CFD  EB 0C 90 90 90                jmp 0000000EH@
08894D02  66 0F BA 2D CC CC CC CC 07    bts word ptr [CCCCCCCCH], 7 ; %M110+16

#84		
#85			(* ATS_State_bits.8 := ATS22_DUT.LI3; *)
#86			MOVE		ATS22_DUT.LI3,ATS_State_bits.8	{LNXT:25|28|-1}
(*) BOOL
08894D0B  33 C0                         xor eax, eax
08894D0D  8A 05 CC CC CC CC             mov al, [CCCCCCCCH] ; $$DATA$$+30
08894D13  84 C0                         test al, al
08894D15  90 75 11 90 90 90             jne 00000014H@
08894D1B  66 0F BA 35 CC CC CC CC 08    btr word ptr [CCCCCCCCH], 8 ; %M110+16
08894D24  EB 0C 90 90 90                jmp 0000000EH@
08894D29  66 0F BA 2D CC CC CC CC 08    bts word ptr [CCCCCCCCH], 8 ; %M110+16

#87		
#88			(* ATS_State_bits.9 := i_pb_loc; *)
#89			MOVE		i_pb_loc,ATS_State_bits.9	{LNXT:28|29|-1}
(*) BOOL
08894D32  0F BF 05 CC CC CC CC          movsx eax, word ptr [CCCCCCCCH] ; $$DATA$$+54
08894D39  66 85 C0                      test ax, ax
08894D3C  90 75 11 90 90 90             jne 00000014H@
08894D42  66 0F BA 35 CC CC CC CC 09    btr word ptr [CCCCCCCCH], 9 ; %M110+16
08894D4B  EB 0C 90 90 90                jmp 0000000EH@
08894D50  66 0F BA 2D CC CC CC CC 09    bts word ptr [CCCCCCCCH], 9 ; %M110+16

#90		
#91			(* ATS_State_bits.10 := i_pb_rem; *)
#92			MOVE		i_pb_rem,ATS_State_bits.10	{LNXT:29|31|-1}
(*) INT
08894D59  0F BF 05 CC CC CC CC          movsx eax, word ptr [CCCCCCCCH] ; $$DATA$$+56
08894D60  66 85 C0                      test ax, ax
08894D63  90 75 11 90 90 90             jne 00000014H@
08894D69  66 0F BA 35 CC CC CC CC 0A    btr word ptr [CCCCCCCCH], 10 ; %M110+16
08894D72  EB 0C 90 90 90                jmp 0000000EH@
08894D77  66 0F BA 2D CC CC CC CC 0A    bts word ptr [CCCCCCCCH], 10 ; %M110+16

#93		
#94		
#95			(* IF i_pb_loc AND not i_pb_rem *)
#96			LD		i_pb_rem	{LNXT:31|-1|-1}
(*) UNDEF
08894D80  0F BF 05 CC CC CC CC          movsx eax, word ptr [CCCCCCCCH] ; $$DATA$$+56

#97			NOT	{LNXT:31|-1|-1}
(*) INT
08894D87  66 F7 D0                      not ax

#98			AND(		i_pb_loc	{LNXT:31|-1|-1}
(*) INT
08894D8A  50                            push eax
08894D8B  0F BF 05 CC CC CC CC          movsx eax, word ptr [CCCCCCCCH] ; $$DATA$$+54

#99			NOT	{LNXT:31|-1|-1}
(*) INT
08894D92  66 F7 D0                      not ax

#100			)	{LNXT:31|-1|-1}
(*) INT
08894D95  8B C8                         mov ecx, eax
08894D97  58                            pop eax
08894D98  23 C1                         and eax, ecx

#101			JMPCN	$label0	{LNXT:31|32|34}
(-) INT
08894D9A  66 85 C0                      test ax, ax
08894D9D  90 74 27 90 90 90             je 08894DC7H

#102		
#103			(* THEN *)
#104		
#105				(* ATS_State_bits.11 := TRUE; *)
#106				MOVE		TRUE,ATS_State_bits.11	{LNXT:32|34|-1}
(*) INT
08894DA3  B8 01 00 00 00                mov eax, 01H
08894DA8  84 C0                         test al, al
08894DAA  90 75 11 90 90 90             jne 00000014H@
08894DB0  66 0F BA 35 CC CC CC CC 0B    btr word ptr [CCCCCCCCH], 11 ; %M110+16
08894DB9  EB 0C 90 90 90                jmp 0000000EH@
08894DBE  66 0F BA 2D CC CC CC CC 0B    bts word ptr [CCCCCCCCH], 11 ; %M110+16

#107		
#108		$label0:
#109			(* END_IF *)
#110		
#111		
#112			(* IF i_pb_loc AND i_pb_rem *)
#113			LD		i_pb_loc	{LNXT:34|-1|-1}
(*) UNDEF
08894DC7  0F BF 05 CC CC CC CC          movsx eax, word ptr [CCCCCCCCH] ; $$DATA$$+54

#114			NOT	{LNXT:34|-1|-1}
(*) INT
08894DCE  66 F7 D0                      not ax

#115			AND		i_pb_rem	{LNXT:34|-1|-1}
(*) INT
08894DD1  0F BF 0D CC CC CC CC          movsx ecx, word ptr [CCCCCCCCH] ; $$DATA$$+56
08894DD8  23 C1                         and eax, ecx

#116			JMPCN	$label1	{LNXT:34|35|37}
(-) INT
08894DDA  66 85 C0                      test ax, ax
08894DDD  90 74 27 90 90 90             je 08894E07H

#117		
#118			(* THEN *)
#119		
#120				(* ATS_State_bits.11 := FALSE; *)
#121				MOVE		FALSE,ATS_State_bits.11	{LNXT:35|37|-1}
(*) INT
08894DE3  B8 00 00 00 00                mov eax, 00H
08894DE8  84 C0                         test al, al
08894DEA  90 75 11 90 90 90             jne 00000014H@
08894DF0  66 0F BA 35 CC CC CC CC 0B    btr word ptr [CCCCCCCCH], 11 ; %M110+16
08894DF9  EB 0C 90 90 90                jmp 0000000EH@
08894DFE  66 0F BA 2D CC CC CC CC 0B    bts word ptr [CCCCCCCCH], 11 ; %M110+16

#122		
#123		$label1:
#124			(* END_IF *)
#125		
#126		
#127			(* IF i_pb_loc AND not i_pb_rem *)
#128			LD		i_pb_rem	{LNXT:37|-1|-1}
(*) UNDEF
08894E07  0F BF 05 CC CC CC CC          movsx eax, word ptr [CCCCCCCCH] ; $$DATA$$+56

#129			NOT	{LNXT:37|-1|-1}
(*) INT
08894E0E  66 F7 D0                      not ax

#130			AND		i_pb_loc	{LNXT:37|-1|-1}
(*) INT
08894E11  0F BF 0D CC CC CC CC          movsx ecx, word ptr [CCCCCCCCH] ; $$DATA$$+54
08894E18  23 C1                         and eax, ecx

#131			JMPCN	$label2	{LNXT:37|38|43}
(-) INT
08894E1A  66 85 C0                      test ax, ax
08894E1D  90 74 27 90 90 90             je 08894E47H

#132		
#133			(* THEN *)
#134		
#135				(* ATS_State_bits.11 := FALSE; *)
#136				MOVE		FALSE,ATS_State_bits.11	{LNXT:38|43|-1}
(*) INT
08894E23  B8 00 00 00 00                mov eax, 00H
08894E28  84 C0                         test al, al
08894E2A  90 75 11 90 90 90             jne 00000014H@
08894E30  66 0F BA 35 CC CC CC CC 0B    btr word ptr [CCCCCCCCH], 11 ; %M110+16
08894E39  EB 0C 90 90 90                jmp 0000000EH@
08894E3E  66 0F BA 2D CC CC CC CC 0B    bts word ptr [CCCCCCCCH], 11 ; %M110+16

#137		
#138		$label2:
#139			(* END_IF *)
#140		
#141			(* ATS22_DUT.EtaCurrent := to_byte(SHR(resp_eta_lcr[0] AND 16#3F00, 16#08) * 200 / 63); *)
#142			LD		resp_eta_lcr[0]	{LNXT:43|44|-1}
(*) UNDEF
08894E47  0F BF 05 CC CC CC CC          movsx eax, word ptr [CCCCCCCCH] ; $$DATA$$+12

#143			AND		16#3F00	{LNXT:43|44|-1}
(*) INT
08894E4E  25 00 3F 00 00                and eax, 00003F00H

#144			SHR		16#08	{LNXT:43|44|-1}
(*) INT
08894E53  C1 E8 08                      shr eax, 8

#145			MUL		200	{LNXT:43|44|-1}
(*) DINT
08894E56  B9 C8 00 00 00                mov ecx, 200
08894E5B  F7 E9                         imul ecx

#146			DIV		63	{LNXT:43|44|-1}
(*) DINT
08894E5D  99                            cdq
08894E5E  B9 3F 00 00 00                mov ecx, 63
08894E63  F7 F9                         idiv ecx

#147			to_byte	{LNXT:43|44|-1}
(*) DINT
#148			ST		ATS22_DUT.EtaCurrent	{LNXT:43|44|-1}
(*) BYTE
08894E65  88 05 CC CC CC CC             mov [CCCCCCCCH], al ; $$DATA$$+33

#149		
#150			(* ATS_Current_prsnt	 := ATS22_DUT.EtaCurrent; *)
#151			MOVE		ATS22_DUT.EtaCurrent,ATS_Current_prsnt	{LNXT:44|46|-1}
(*) BYTE
08894E6B  33 C0                         xor eax, eax
08894E6D  8A 05 CC CC CC CC             mov al, [CCCCCCCCH] ; $$DATA$$+33
08894E73  66 89 05 CC CC CC CC          mov [CCCCCCCCH], ax ; %M110+18

#152		
#153			(* ATS22_DUT.Local 	:= to_bool(resp_eta_lcr[0] And 16#4000); *)
#154			LD		resp_eta_lcr[0]	{LNXT:46|47|-1}
(*) UNDEF
08894E7A  0F BF 05 CC CC CC CC          movsx eax, word ptr [CCCCCCCCH] ; $$DATA$$+12

#155			AND		16#4000	{LNXT:46|47|-1}
(*) INT
08894E81  25 00 40 00 00                and eax, 00004000H

#156			to_bool	{LNXT:46|47|-1}
(*) INT
08894E86  66 85 C0                      test ax, ax
08894E89  0F 95 C0                      setne al

#157			ST		ATS22_DUT.Local	{LNXT:46|47|-1}
(*) BOOL
08894E8C  84 C0                         test al, al
08894E8E  0F 95 05 CC CC CC CC          setne [CCCCCCCCH] ; $$DATA$$+34

#158		
#159			(* ATS22_DUT.Ramping 	:= to_bool(resp_eta_lcr[0] And 16#8000); *)
#160			LD		resp_eta_lcr[0]	{LNXT:47|49|-1}
(*) UNDEF
08894E95  0F BF 05 CC CC CC CC          movsx eax, word ptr [CCCCCCCCH] ; $$DATA$$+12

#161			AND		16#8000	{LNXT:47|49|-1}
(*) INT
08894E9C  25 00 80 00 00                and eax, 00008000H

#162			to_bool	{LNXT:47|49|-1}
(*) INT
08894EA1  66 85 C0                      test ax, ax
08894EA4  0F 95 C0                      setne al

#163			ST		ATS22_DUT.Ramping	{LNXT:47|49|-1}
(*) BOOL
08894EA7  84 C0                         test al, al
08894EA9  0F 95 05 CC CC CC CC          setne [CCCCCCCCH] ; $$DATA$$+35

#164		
#165			(* ATS22_DUT.Lcr1 := resp_eta_lcr[1]; *)
#166			MOVE		resp_eta_lcr[1],ATS22_DUT.Lcr1	{LNXT:49|50|-1}
(*) BOOL
08894EB0  0F BF 05 CC CC CC CC          movsx eax, word ptr [CCCCCCCCH] ; $$DATA$$+14
08894EB7  66 89 05 CC CC CC CC          mov [CCCCCCCCH], ax ; $$DATA$$+36

#167		
#168			(* ATS22_DUT.Lcr2 := resp_eta_lcr[2]; *)
#169			MOVE		resp_eta_lcr[2],ATS22_DUT.Lcr2	{LNXT:50|51|-1}
(*) INT
08894EBE  0F BF 05 CC CC CC CC          movsx eax, word ptr [CCCCCCCCH] ; $$DATA$$+16
08894EC5  66 89 05 CC CC CC CC          mov [CCCCCCCCH], ax ; $$DATA$$+38

#170		
#171			(* ATS22_DUT.Lcr3 := resp_eta_lcr[3]; *)
#172			MOVE		resp_eta_lcr[3],ATS22_DUT.Lcr3	{LNXT:51|53|-1}
(*) INT
08894ECC  0F BF 05 CC CC CC CC          movsx eax, word ptr [CCCCCCCCH] ; $$DATA$$+18
08894ED3  66 89 05 CC CC CC CC          mov [CCCCCCCCH], ax ; $$DATA$$+40

#173		
#174			(* ATS_Current_L1 := ATS22_DUT.Lcr1; *)
#175			MOVE		ATS22_DUT.Lcr1,ATS_Current_L1	{LNXT:53|54|-1}
(*) INT
08894EDA  0F BF 05 CC CC CC CC          movsx eax, word ptr [CCCCCCCCH] ; $$DATA$$+36
08894EE1  66 89 05 CC CC CC CC          mov [CCCCCCCCH], ax ; %M110+20

#176		
#177			(* ATS_Current_L2 := ATS22_DUT.Lcr2; *)
#178			MOVE		ATS22_DUT.Lcr2,ATS_Current_L2	{LNXT:54|55|-1}
(*) INT
08894EE8  0F BF 05 CC CC CC CC          movsx eax, word ptr [CCCCCCCCH] ; $$DATA$$+38
08894EEF  66 89 05 CC CC CC CC          mov [CCCCCCCCH], ax ; %M110+22

#179		
#180			(* ATS_Current_L3 := ATS22_DUT.Lcr3; *)
#181			MOVE		ATS22_DUT.Lcr3,ATS_Current_L3	{LNXT:55|57|-1}
(*) INT
08894EF6  0F BF 05 CC CC CC CC          movsx eax, word ptr [CCCCCCCCH] ; $$DATA$$+40
08894EFD  66 89 05 CC CC CC CC          mov [CCCCCCCCH], ax ; %M110+24

#182		
#183			(* res := sysMbMRTU_FC03(	addr := 1, 
#184											base := 261, // 260
#185											no := 1, 
#186											object := ADR(resp_eta_lcr), 
#187											timeout := 200); *)
#188			ADR		resp_eta_lcr	{LNXT:57|63|-1}
(*) INT
08894F04  B8 CC CC CC CC                mov eax, CCCCCCCCH ; $$DATA$$+12

#189			ST		$$TMP0	{LNXT:57|63|-1}
(*) @INT
08894F09  89 05 CC CC CC CC             mov [CCCCCCCCH], eax ; $$DATA$$+20

#190			LDP0		1	{LNXT:57|63|-1}
(*) @INT
#191			sysMbMRTU_FC03		261, 1, $$TMP0, 200	{LNXT:57|63|-1}
(*) @INT
08894F0F  68 C8 00 00 00                push 200
08894F14  FF 35 CC CC CC CC             push [CCCCCCCCH] ; $$DATA$$+20
08894F1A  68 01 00 00 00                push 1
08894F1F  68 05 01 00 00                push 261
08894F24  68 01 00 00 00                push 1
08894F29  B9 CC CC CC CC                mov ecx, CCCCCCCCH ; sysMbMRTU_FC03
08894F2E  FF D1                         call ecx
08894F30  81 C4 14 00 00 00             add esp, 20

#192			ST		res	{LNXT:57|63|-1}
(*) UINT
08894F36  66 89 05 CC CC CC CC          mov [CCCCCCCCH], ax ; $$DATA$$+24

#193		
#194			(* ATS22_DUT.LcrVoltage	:= resp_eta_lcr[0]; *)
#195			MOVE		resp_eta_lcr[0],ATS22_DUT.LcrVoltage	{LNXT:63|64|-1}
(*) UINT
08894F3D  0F BF 05 CC CC CC CC          movsx eax, word ptr [CCCCCCCCH] ; $$DATA$$+12
08894F44  66 89 05 CC CC CC CC          mov [CCCCCCCCH], ax ; $$DATA$$+42

#196		
#197			(* ATS_Voltage := ATS22_DUT.LcrVoltage; *)
#198			MOVE		ATS22_DUT.LcrVoltage,ATS_Voltage	{LNXT:64|68|-1}
(*) INT
08894F4B  0F BF 05 CC CC CC CC          movsx eax, word ptr [CCCCCCCCH] ; $$DATA$$+42
08894F52  66 89 05 CC CC CC CC          mov [CCCCCCCCH], ax ; %M110+36

#199		
#200			(* res := sysMbMRTU_FC03(	addr := 1, 
#201											base := 280, // 279
#202											no := 1, 
#203											object := ADR(resp_eta_lcr), 
#204											timeout := 200); *)
#205			ADR		resp_eta_lcr	{LNXT:68|74|-1}
(*) INT
08894F59  B8 CC CC CC CC                mov eax, CCCCCCCCH ; $$DATA$$+12

#206			ST		$$TMP0	{LNXT:68|74|-1}
(*) @INT
08894F5E  89 05 CC CC CC CC             mov [CCCCCCCCH], eax ; $$DATA$$+20

#207			LDP0		1	{LNXT:68|74|-1}
(*) @INT
#208			sysMbMRTU_FC03		280, 1, $$TMP0, 200	{LNXT:68|74|-1}
(*) @INT
08894F64  68 C8 00 00 00                push 200
08894F69  FF 35 CC CC CC CC             push [CCCCCCCCH] ; $$DATA$$+20
08894F6F  68 01 00 00 00                push 1
08894F74  68 18 01 00 00                push 280
08894F79  68 01 00 00 00                push 1
08894F7E  B9 CC CC CC CC                mov ecx, CCCCCCCCH ; sysMbMRTU_FC03
08894F83  FF D1                         call ecx
08894F85  81 C4 14 00 00 00             add esp, 20

#209			ST		res	{LNXT:68|74|-1}
(*) UINT
08894F8B  66 89 05 CC CC CC CC          mov [CCCCCCCCH], ax ; $$DATA$$+24

#210		
#211			(* ATS22_DUT.LastFLT 	:= resp_eta_lcr[0]; *)
#212			MOVE		resp_eta_lcr[0],ATS22_DUT.LastFLT	{LNXT:74|75|-1}
(*) UINT
08894F92  0F BF 05 CC CC CC CC          movsx eax, word ptr [CCCCCCCCH] ; $$DATA$$+12
08894F99  66 89 05 CC CC CC CC          mov [CCCCCCCCH], ax ; $$DATA$$+44

#213		
#214			(* ATS_Last_FaultCode := ATS22_DUT.LastFLT; *)
#215			MOVE		ATS22_DUT.LastFLT,ATS_Last_FaultCode	{LNXT:75|78|-1}
(*) INT
08894FA0  0F BF 05 CC CC CC CC          movsx eax, word ptr [CCCCCCCCH] ; $$DATA$$+44
08894FA7  66 89 05 CC CC CC CC          mov [CCCCCCCCH], ax ; %M110+26

#216		
#217			(* res := sysMbMRTU_FC03(	addr := 1, 
#218											base := 274, // 273
#219											no := 3, 
#220											object := ADR(resp_eta_lcr), 
#221											timeout := 200); *)
#222			ADR		resp_eta_lcr	{LNXT:78|84|-1}
(*) INT
08894FAE  B8 CC CC CC CC                mov eax, CCCCCCCCH ; $$DATA$$+12

#223			ST		$$TMP0	{LNXT:78|84|-1}
(*) @INT
08894FB3  89 05 CC CC CC CC             mov [CCCCCCCCH], eax ; $$DATA$$+20

#224			LDP0		1	{LNXT:78|84|-1}
(*) @INT
#225			sysMbMRTU_FC03		274, 3, $$TMP0, 200	{LNXT:78|84|-1}
(*) @INT
08894FB9  68 C8 00 00 00                push 200
08894FBE  FF 35 CC CC CC CC             push [CCCCCCCCH] ; $$DATA$$+20
08894FC4  68 03 00 00 00                push 3
08894FC9  68 12 01 00 00                push 274
08894FCE  68 01 00 00 00                push 1
08894FD3  B9 CC CC CC CC                mov ecx, CCCCCCCCH ; sysMbMRTU_FC03
08894FD8  FF D1                         call ecx
08894FDA  81 C4 14 00 00 00             add esp, 20

#226			ST		res	{LNXT:78|84|-1}
(*) UINT
08894FE0  66 89 05 CC CC CC CC          mov [CCCCCCCCH], ax ; $$DATA$$+24

#227		
#228		
#229			(* IF res <> 0 *)
#230			LD		res	{LNXT:84|-1|-1}
(*) UNDEF
08894FE7  0F BF 05 CC CC CC CC          movsx eax, word ptr [CCCCCCCCH] ; $$DATA$$+24

#231			NE		0	{LNXT:84|-1|-1}
(*) INT
08894FEE  3D 00 00 00 00                cmp eax, 0
08894FF3  0F 95 C0                      setne al
08894FF6  25 FF 00 00 00                and eax, 0FFh

#232			JMPCN	$label3	{LNXT:84|84|86}
(-) BOOL
08894FFB  84 C0                         test al, al
08894FFD  90 74 27 90 90 90             je 08895027H

#233		
#234			(* THEN *)
#235		
#236				(* Alarms.6 := true; *)
#237				MOVE		true,Alarms.6	{LNXT:84|86|-1}
(*) BOOL
08895003  B8 01 00 00 00                mov eax, 01H
08895008  84 C0                         test al, al
0889500A  90 75 11 90 90 90             jne 00000014H@
08895010  66 0F BA 35 CC CC CC CC 06    btr word ptr [CCCCCCCCH], 6 ; %M110+32
08895019  EB 0C 90 90 90                jmp 0000000EH@
0889501E  66 0F BA 2D CC CC CC CC 06    bts word ptr [CCCCCCCCH], 6 ; %M110+32

#238		
#239		$label3:
#240			(* END_IF *)
#241		
#242			(* ATS22_DUT.MotRunTime 		:= resp_eta_lcr[0]; *)
#243			MOVE		resp_eta_lcr[0],ATS22_DUT.MotRunTime	{LNXT:86|87|-1}
(*) WORD
08895027  0F BF 05 CC CC CC CC          movsx eax, word ptr [CCCCCCCCH] ; $$DATA$$+12
0889502E  66 89 05 CC CC CC CC          mov [CCCCCCCCH], ax ; $$DATA$$+46

#244		
#245			(* ATS22_DUT.MotStartCnt 		:= resp_eta_lcr[1]; *)
#246			MOVE		resp_eta_lcr[1],ATS22_DUT.MotStartCnt	{LNXT:87|88|-1}
(*) INT
08895035  0F BF 05 CC CC CC CC          movsx eax, word ptr [CCCCCCCCH] ; $$DATA$$+14
0889503C  66 89 05 CC CC CC CC          mov [CCCCCCCCH], ax ; $$DATA$$+48

#247		
#248			(* ATS22_DUT.MotLastStartTime 	:= resp_eta_lcr[2]; *)
#249			MOVE		resp_eta_lcr[2],ATS22_DUT.MotLastStartTime	{LNXT:88|90|-1}
(*) INT
08895043  0F BF 05 CC CC CC CC          movsx eax, word ptr [CCCCCCCCH] ; $$DATA$$+16
0889504A  66 89 05 CC CC CC CC          mov [CCCCCCCCH], ax ; $$DATA$$+50

#250		
#251			(* ATS_RunTime_Hors	:= to_word(ATS22_DUT.MotRunTime); *)
#252			LDP0		ATS22_DUT.MotRunTime	{LNXT:90|91|-1}
(*) INT
#253			to_word	{LNXT:90|91|-1}
(*) INT
08895051  0F BF 05 CC CC CC CC          movsx eax, word ptr [CCCCCCCCH] ; $$DATA$$+46

#254			ST		ATS_RunTime_Hors	{LNXT:90|91|-1}
(*) WORD
08895058  66 89 05 CC CC CC CC          mov [CCCCCCCCH], ax ; %M110+28

#255		
#256			(* ATS_OnTimes_Cnt		:= to_word(ATS22_DUT.MotStartCnt); *)
#257			LDP0		ATS22_DUT.MotStartCnt	{LNXT:91|2|-1}
(*) WORD
#258			to_word	{LNXT:91|2|-1}
(*) WORD
0889505F  0F BF 05 CC CC CC CC          movsx eax, word ptr [CCCCCCCCH] ; $$DATA$$+48

#259			ST		ATS_OnTimes_Cnt	{LNXT:91|2|-1}
(*) WORD
08895066  66 89 05 CC CC CC CC          mov [CCCCCCCCH], ax ; %M110+30

0889506D  61                            popad
0889506E  5D                            pop ebp

0889506F  C3                            ret

END_PROGRAM


**************************************************
	Target variable image generation
**************************************************


*** INPUT:
08895070  55                            push ebp
08895071  8B EC                         mov ebp, esp

08895073  8A 0D CC CC CC CC             mov cl, [CCCCCCCCH] ; %I0+7
08895079  88 0D CC CC CC CC             mov [CCCCCCCCH], cl ; $$DATA$$+52

0889507F  8A 0D CC CC CC CC             mov cl, [CCCCCCCCH] ; %I0+6
08895085  88 0D CC CC CC CC             mov [CCCCCCCCH], cl ; $$DATA$$+53

0889508B  66 8B 0D CC CC CC CC          mov cx, [CCCCCCCCH] ; %I1+12
08895092  66 89 0D CC CC CC CC          mov [CCCCCCCCH], cx ; $$DATA$$+54

08895099  66 8B 0D CC CC CC CC          mov cx, [CCCCCCCCH] ; %I1+14
088950A0  66 89 0D CC CC CC CC          mov [CCCCCCCCH], cx ; $$DATA$$+56

088950A7  8B E5                         mov esp, ebp
088950A9  5D                            pop ebp

088950AA  C3                            ret


*** OUTPUT:
088950AB  55                            push ebp
088950AC  8B EC                         mov ebp, esp

088950AE  8B E5                         mov esp, ebp
088950B0  5D                            pop ebp

088950B1  C3                            ret



**************************************************
	Task Background init code
**************************************************

088950B2  55                            push ebp
088950B3  8B EC                         mov ebp, esp

088950B5  8B E5                         mov esp, ebp
088950B7  5D                            pop ebp

088950B8  C3                            ret

**************************************************
	List program: sr_init_counters
**************************************************

PROGRAM sr_init_counters

END_PROGRAM

088950D0  55                            push ebp
088950D1  8B EC                         mov ebp, esp
088950D3  60                            pushad

#0		{SRC:sr_init_counters}
#1		(*$WAITSWITCH$*)
#2		
#3			(* kw_counter 	:= epprom_kw_cnt; *)
#4			MOVE		epprom_kw_cnt,kw_counter	{LNXT:1|2|-1}
(*) UDINT
088950D4  8B 05 CC CC CC CC             mov eax, [CCCCCCCCH] ; %M101+8
088950DA  89 05 CC CC CC CC             mov [CCCCCCCCH], eax ; %M110+4

#5		
#6			(* q_counter	:= epprom_q_cnt; *)
#7			MOVE		epprom_q_cnt,q_counter	{LNXT:2|1|-1}
(*) DWORD
088950E0  8B 05 CC CC CC CC             mov eax, [CCCCCCCCH] ; %M101+0
088950E6  89 05 CC CC CC CC             mov [CCCCCCCCH], eax ; %M110+8

088950EC  61                            popad
088950ED  5D                            pop ebp

088950EE  C3                            ret

END_PROGRAM


**************************************************
	Target variable image generation
**************************************************


*** INPUT:
088950EF  C3                            ret


*** OUTPUT:
088950F0  C3                            ret



**************************************************
	Task Boot init code
**************************************************

088950F1  55                            push ebp
088950F2  8B EC                         mov ebp, esp

088950F4  8B E5                         mov esp, ebp
088950F6  5D                            pop ebp

088950F7  C3                            ret

**************************************************
	List program: init_val
**************************************************

PROGRAM init_val

END_PROGRAM

08895110  55                            push ebp
08895111  8B EC                         mov ebp, esp
08895113  60                            pushad

#0		{SRC:init_val}
#1		(*$WAITSWITCH$*)
#2		
#3		
#4			(* IF di_val_close_state_R *)
#5			LD		di_val_close_state_R	{LNXT:1|-1|-1}
(*) UNDEF
08895114  33 C0                         xor eax, eax
08895116  8A 05 CC CC CC CC             mov al, [CCCCCCCCH] ; %I0+0

#6			NOT	{LNXT:1|-1|-1}
(*) BOOL
0889511C  84 C0                         test al, al
0889511E  0F 94 C0                      sete al

#7			JMPCN	$label0	{LNXT:1|2|6}
(-) BOOL
08895121  84 C0                         test al, al
08895123  90 74 1F 90 90 90             je 08895145H

#8		
#9			(* THEN *)
#10		
#11				(* o_val_close_R:=true; *)
#12				MOVE		true,o_val_close_R	{LNXT:2|3|-1}
(*) BOOL
08895129  B8 01 00 00 00                mov eax, 01H
0889512E  84 C0                         test al, al
08895130  0F 95 05 CC CC CC CC          setne [CCCCCCCCH] ; %Q1+3

#13		
#14				(* o_val_open_R:=false; *)
#15				MOVE		false,o_val_open_R	{LNXT:3|6|-1}
(*) BOOL
08895137  B8 00 00 00 00                mov eax, 00H
0889513C  84 C0                         test al, al
0889513E  0F 95 05 CC CC CC CC          setne [CCCCCCCCH] ; %Q1+2

#16		
#17		$label0:
#18			(* END_IF *)
#19		
#20		
#21			(* IF di_val_close_state_fall = 0 *)
#22			LD		di_val_close_state_fall	{LNXT:6|-1|-1}
(*) UNDEF
08895145  0F BF 05 CC CC CC CC          movsx eax, word ptr [CCCCCCCCH] ; %I1+8

#23			EQ		0	{LNXT:6|-1|-1}
(*) INT
0889514C  3D 00 00 00 00                cmp eax, 0
08895151  0F 94 C0                      sete al
08895154  25 FF 00 00 00                and eax, 0FFh

#24			JMPCN	$label1	{LNXT:6|7|1}
(-) BOOL
08895159  84 C0                         test al, al
0889515B  90 74 1F 90 90 90             je 0889517DH

#25		
#26			(* THEN *)
#27		
#28				(* o_val_close_fall:=true; *)
#29				MOVE		true,o_val_close_fall	{LNXT:7|8|-1}
(*) BOOL
08895161  B8 01 00 00 00                mov eax, 01H
08895166  84 C0                         test al, al
08895168  0F 95 05 CC CC CC CC          setne [CCCCCCCCH] ; %Q1+1

#30		
#31				(* o_val_open_fall:=false; *)
#32				MOVE		false,o_val_open_fall	{LNXT:8|1|-1}
(*) BOOL
0889516F  B8 00 00 00 00                mov eax, 00H
08895174  84 C0                         test al, al
08895176  0F 95 05 CC CC CC CC          setne [CCCCCCCCH] ; %Q1+0

0889517D  61                            popad
0889517E  5D                            pop ebp

0889517F  C3                            ret

END_PROGRAM


**************************************************
	Target variable image generation
**************************************************


*** INPUT:
08895180  C3                            ret


*** OUTPUT:
08895181  C3                            ret



**************************************************
	Task Init init code
**************************************************

08895182  55                            push ebp
08895183  8B EC                         mov ebp, esp

08895185  8B E5                         mov esp, ebp
08895187  5D                            pop ebp

08895188  C3                            ret

**************************************************
	List program: InitParDB
**************************************************

PROGRAM InitParDB

        VAR
warningsKiller : USINT;
dummyCrc32 : UDINT;
	END_VAR

END_PROGRAM

088951A0  55                            push ebp
088951A1  8B EC                         mov ebp, esp
088951A3  60                            pushad

#0		{SRC:InitParDB}
#1		(*$WAITSWITCH$*)
#2		
#3			(* dummyCrc32 := 541599759; *)
#4			MOVE		541599759,dummyCrc32	{LNXT:3|5|-1}
(*) UDINT
088951A4  B8 0F 28 48 20                mov eax, 2048280FH
088951A9  89 05 CC CC CC CC             mov [CCCCCCCCH], eax ; $$DATA$$+60

#5		
#6			(* warningsKiller := sysDBase_SetExtTable( ADR( $$ParDB ), $$ParDBLength ); *)
#7			ADR		$$ParDB	{LNXT:5|3|-1}
(*) UDINT
088951AF  B8 CC CC CC CC                mov eax, CCCCCCCCH ; $$CODE$$+336

#8			sysDBase_SetExtTable		$$ParDBLength	{LNXT:5|3|-1}
(*) @USINT
088951B4  68 16 00 00 00                push 22
088951B9  8B C8                         mov ecx, eax
088951BB  51                            push ecx
088951BC  B9 CC CC CC CC                mov ecx, CCCCCCCCH ; sysDBase_SetExtTable
088951C1  FF D1                         call ecx
088951C3  81 C4 08 00 00 00             add esp, 8

#9			ST		warningsKiller	{LNXT:5|3|-1}
(*) USINT
088951C9  88 05 CC CC CC CC             mov [CCCCCCCCH], al ; $$DATA$$+59

088951CF  61                            popad
088951D0  5D                            pop ebp

088951D1  C3                            ret

END_PROGRAM


**************************************************
	Target variable image generation
**************************************************


*** INPUT:
088951D2  C3                            ret


*** OUTPUT:
088951D3  C3                            ret



**************************************************
	Task Serv init code
**************************************************

088951D4  55                            push ebp
088951D5  8B EC                         mov ebp, esp

088951D7  8B E5                         mov esp, ebp
088951D9  5D                            pop ebp

088951DA  C3                            ret

**************************************************
	List program: sr_pressure
**************************************************

PROGRAM sr_pressure

        VAR
tmp_test : INT;
	END_VAR

END_PROGRAM

088951F0  55                            push ebp
088951F1  8B EC                         mov ebp, esp
088951F3  60                            pushad

#0		{SRC:sr_pressure}
#1		(*$WAITSWITCH$*)
#2		
#3			(* Pressure := to_int(to_real(i_adc_pressure )/10); *)
#4			LDP0		i_adc_pressure	{LNXT:2|2|-1}
(*) UDINT
#5			to_real	{LNXT:2|2|-1}
(*) UDINT
088951F4  0F BF 05 CC CC CC CC          movsx eax, word ptr [CCCCCCCCH] ; $$DATA$$+270
088951FB  50                            push eax
088951FC  DB 04 24                      fild dword ptr [esp]
088951FF  58                            pop eax

#6			DIV		10	{LNXT:2|2|-1}
(*) REAL
08895200  68 0A 00 00 00                push 10
08895205  DA 34 24                      fidiv [esp]
08895208  81 C4 04 00 00 00             add esp, 4

#7			to_int	{LNXT:2|2|-1}
(*) REAL
0889520E  81 EC 08 00 00 00             sub esp, 8
08895214  DF 3C 24                      fistp qword ptr [esp]
08895217  58                            pop eax
08895218  81 C4 04 00 00 00             add esp, 4

#8			ST		Pressure	{LNXT:2|2|-1}
(*) INT
0889521E  66 89 05 CC CC CC CC          mov [CCCCCCCCH], ax ; %M110+0

END_PROGRAM
**************************************************
	List program: sr_counters
**************************************************

PROGRAM sr_counters

        VAR
kw_trig : R_TRIG;
q_trig : R_TRIG;
kw_pulses_per_acs : UINT;
q_pulses_per_acs : UINT;
test_freq : UDINT;
	END_VAR

END_PROGRAM

#0		{SRC:sr_counters}
#1		(*$WAITSWITCH$*)
#2		
#3			(* kw_pulses_per_acs 	:= 8000; *)
#4			MOVE		8000,kw_pulses_per_acs	{LNXT:2|3|-1}
(*) UDINT
08895225  B8 40 1F 00 00                mov eax, 1F40H
0889522A  66 89 05 CC CC CC CC          mov [CCCCCCCCH], ax ; $$DATA$$+266

#5		
#6			(* q_pulses_per_acs	:= 1; *)
#7			MOVE		1,q_pulses_per_acs	{LNXT:3|15|-1}
(*) UINT
08895231  B8 01 00 00 00                mov eax, 01H
08895236  66 89 05 CC CC CC CC          mov [CCCCCCCCH], ax ; $$DATA$$+268

#8		
#9		
#10			(* IF fdi_q_cnt >= q_pulses_per_acs *)
#11			LD		fdi_q_cnt	{LNXT:15|-1|-1}
(*) UNDEF
0889523D  8B 05 CC CC CC CC             mov eax, [CCCCCCCCH] ; %M500+0

#12			GE		q_pulses_per_acs	{LNXT:15|-1|-1}
(*) UDINT
08895243  33 C9                         xor ecx, ecx
08895245  66 8B 0D CC CC CC CC          mov cx, [CCCCCCCCH] ; $$DATA$$+268
0889524C  3B C1                         cmp eax, ecx
0889524E  0F 93 C0                      setae al
08895251  25 FF 00 00 00                and eax, 0FFh

#13			JMPCN	$label0	{LNXT:15|16|20}
(-) BOOL
08895256  84 C0                         test al, al
08895258  90 74 22 90 90 90             je 0889527DH

#14		
#15			(* THEN *)
#16		
#17				(* q_counter := q_counter + 1; *)
#18				LD		q_counter	{LNXT:16|17|-1}
(*) UNDEF
0889525E  8B 05 CC CC CC CC             mov eax, [CCCCCCCCH] ; %M110+8

#19				ADD		1	{LNXT:16|17|-1}
(*) DWORD
08895264  05 01 00 00 00                add eax, 1

#20				ST		q_counter	{LNXT:16|17|-1}
(*) DWORD
08895269  89 05 CC CC CC CC             mov [CCCCCCCCH], eax ; %M110+8

#21		
#22				(* fdi_q_reset := true; *)
#23				MOVE		true,fdi_q_reset	{LNXT:17|20|-1}
(*) DWORD
0889526F  B8 01 00 00 00                mov eax, 01H
08895274  84 C0                         test al, al
08895276  0F 95 05 CC CC CC CC          setne [CCCCCCCCH] ; %M550+0

#24		
#25		$label0:
#26			(* END_IF *)
#27		
#28			(* q_value := to_int((3600 * to_real(fdi_q_freq)) / (to_real(q_pulses_per_acs) / 1)); *)
#29			LDP0		fdi_q_freq	{LNXT:20|2|-1}
(*) BOOL
#30			to_real	{LNXT:20|2|-1}
(*) BOOL
0889527D  8B 05 CC CC CC CC             mov eax, [CCCCCCCCH] ; %M500+4
08895283  68 00 00 00 00                push 0
08895288  50                            push eax
08895289  DF 2C 24                      fild qword ptr [esp]
0889528C  81 C4 08 00 00 00             add esp, 8

#31			MUL		3600	{LNXT:20|2|-1}
(*) REAL
08895292  68 10 0E 00 00                push 3600
08895297  DA 0C 24                      fimul [esp]
0889529A  81 C4 04 00 00 00             add esp, 4

#32			DIV(		0	{LNXT:20|2|-1}
(*) REAL
088952A0  81 EC 04 00 00 00             sub esp, 4
088952A6  D9 1C 24                      fstp dword ptr [esp]
088952A9  B8 00 00 00 00                mov eax, 00H

#33			LDP0		q_pulses_per_acs	{LNXT:20|2|-1}
(*) USINT
#34			to_real	{LNXT:20|2|-1}
(*) USINT
088952AE  33 C0                         xor eax, eax
088952B0  66 8B 05 CC CC CC CC          mov ax, [CCCCCCCCH] ; $$DATA$$+268
088952B7  68 00 00 00 00                push 0
088952BC  50                            push eax
088952BD  DF 2C 24                      fild qword ptr [esp]
088952C0  81 C4 08 00 00 00             add esp, 8

#35			DIV		1	{LNXT:20|2|-1}
(*) REAL
088952C6  68 01 00 00 00                push 1
088952CB  DA 34 24                      fidiv [esp]
088952CE  81 C4 04 00 00 00             add esp, 4

#36			)	{LNXT:20|2|-1}
(*) REAL
088952D4  81 EC 04 00 00 00             sub esp, 4
088952DA  D9 1C 24                      fstp dword ptr [esp]
088952DD  D9 44 24 04                   fld dword ptr 4[esp]
088952E1  D8 34 24                      fdiv dword ptr [esp]
088952E4  81 C4 08 00 00 00             add esp, 8

#37			to_int	{LNXT:20|2|-1}
(*) REAL
088952EA  81 EC 08 00 00 00             sub esp, 8
088952F0  DF 3C 24                      fistp qword ptr [esp]
088952F3  58                            pop eax
088952F4  81 C4 04 00 00 00             add esp, 4

#38			ST		q_value	{LNXT:20|2|-1}
(*) INT
088952FA  66 89 05 CC CC CC CC          mov [CCCCCCCCH], ax ; %M110+14

END_PROGRAM
**************************************************
	List program: sr_save_counters
**************************************************

PROGRAM sr_save_counters

        VAR
power_err : R_TRIG;
ton_start_up : TON;
res_q : BOOL;
res_kw : BOOL;
	END_VAR

END_PROGRAM

#0		{SRC:sr_save_counters}
#1		(*$WAITSWITCH$*)
#2		
#3			(* ton_start_up *)
#4			MOVE		true,ton_start_up.IN	{LNXT:1|-1|-1}
(*) UDINT
08895301  B8 01 00 00 00                mov eax, 01H
08895306  84 C0                         test al, al
08895308  0F 95 05 CC CC CC CC          setne [CCCCCCCCH] ; $$DATA$$+276

#5			MOVE		5000,ton_start_up.PT	{LNXT:1|-1|-1}
(*) BOOL
0889530F  B8 88 13 00 00                mov eax, 1388H
08895314  89 05 CC CC CC CC             mov [CCCCCCCCH], eax ; $$DATA$$+277

#6			CAL		ton_start_up	{LNXT:1|2|-1}
(*) UDINT
0889531A  50                            push eax
0889531B  BB CC CC CC CC                mov ebx, CCCCCCCCH ; $$DATA$$+272
08895320  E8 94 F1 FF FF                call 088944B9H ; $$CODE$$+17593
08895325  58                            pop eax

#7		
#8			(* power_err *)
#9			LD		ton_start_up.Q	{LNXT:2|-1|-1}
(*) UNDEF
08895326  33 C0                         xor eax, eax
08895328  8A 05 CC CC CC CC             mov al, [CCCCCCCCH] ; $$DATA$$+281

#10			AND		i_rnpp	{LNXT:2|-1|-1}
(*) BOOL
0889532E  33 C9                         xor ecx, ecx
08895330  8A 0D CC CC CC CC             mov cl, [CCCCCCCCH] ; $$DATA$$+263
08895336  23 C1                         and eax, ecx

#11			ST		power_err.clk	{LNXT:2|-1|-1}
(*) BOOL
08895338  84 C0                         test al, al
0889533A  0F 95 05 CC CC CC CC          setne [CCCCCCCCH] ; $$DATA$$+295

#12			CAL		power_err	{LNXT:2|3|-1}
(*) BOOL
08895341  50                            push eax
08895342  BB CC CC CC CC                mov ebx, CCCCCCCCH ; $$DATA$$+294
08895347  E8 44 F1 FF FF                call 08894490H ; $$CODE$$+17552
0889534C  58                            pop eax

#13		
#14		
#15			(* IF power_err.q *)
#16			LD		power_err.q	{LNXT:3|-1|-1}
(*) UNDEF
0889534D  33 C0                         xor eax, eax
0889534F  8A 05 CC CC CC CC             mov al, [CCCCCCCCH] ; $$DATA$$+296

#17			JMPCN	$label0	{LNXT:3|4|1}
(-) BOOL
08895355  84 C0                         test al, al
08895357  0F 84 82 00 00 00             je 088953DFH

#18		
#19			(* THEN *)
#20		
#21		
#22				(* IF epprom_q_cnt <> q_counter *)
#23				LD		epprom_q_cnt	{LNXT:4|-1|-1}
(*) UNDEF
0889535D  8B 05 CC CC CC CC             mov eax, [CCCCCCCCH] ; %M101+0

#24				NE		q_counter	{LNXT:4|-1|-1}
(*) DWORD
08895363  3B 05 CC CC CC CC             cmp eax, [CCCCCCCCH] ; %M110+8
08895369  0F 95 C0                      setne al
0889536C  25 FF 00 00 00                and eax, 0FFh

#25				JMPCN	$label1	{LNXT:4|4|5}
(-) BOOL
08895371  84 C0                         test al, al
08895373  90 74 28 90 90 90             je 0889539EH

#26		
#27				(* THEN *)
#28		
#29					(* res_q := sysWriteParUINT(ADR(epprom_q_cnt), q_counter); *)
#30					ADR		epprom_q_cnt	{LNXT:4|5|-1}
(*) BOOL
08895379  B8 CC CC CC CC                mov eax, CCCCCCCCH ; %M101+0

#31					sysWriteParUINT		q_counter	{LNXT:4|5|-1}
(*) @DWORD
0889537E  8B 0D CC CC CC CC             mov ecx, [CCCCCCCCH] ; %M110+8
08895384  51                            push ecx
08895385  8B C8                         mov ecx, eax
08895387  51                            push ecx
08895388  B9 CC CC CC CC                mov ecx, CCCCCCCCH ; sysWriteParUINT
0889538D  FF D1                         call ecx
0889538F  81 C4 08 00 00 00             add esp, 8

#32					ST		res_q	{LNXT:4|5|-1}
(*) BOOL
08895395  84 C0                         test al, al
08895397  0F 95 05 CC CC CC CC          setne [CCCCCCCCH] ; $$DATA$$+265

#33		
#34		$label1:
#35				(* END_IF *)
#36		
#37		
#38				(* IF epprom_kw_cnt <> kw_counter *)
#39				LD		epprom_kw_cnt	{LNXT:5|-1|-1}
(*) UNDEF
0889539E  8B 05 CC CC CC CC             mov eax, [CCCCCCCCH] ; %M101+8

#40				NE		kw_counter	{LNXT:5|-1|-1}
(*) DWORD
088953A4  3B 05 CC CC CC CC             cmp eax, [CCCCCCCCH] ; %M110+4
088953AA  0F 95 C0                      setne al
088953AD  25 FF 00 00 00                and eax, 0FFh

#41				JMPCN	$label2	{LNXT:5|5|1}
(-) BOOL
088953B2  84 C0                         test al, al
088953B4  90 74 28 90 90 90             je 088953DFH

#42		
#43				(* THEN *)
#44		
#45					(* res_kw := sysWriteParUINT(ADR(epprom_kw_cnt), kw_counter); *)
#46					ADR		epprom_kw_cnt	{LNXT:5|1|-1}
(*) BOOL
088953BA  B8 CC CC CC CC                mov eax, CCCCCCCCH ; %M101+8

#47					sysWriteParUINT		kw_counter	{LNXT:5|1|-1}
(*) @DWORD
088953BF  8B 0D CC CC CC CC             mov ecx, [CCCCCCCCH] ; %M110+4
088953C5  51                            push ecx
088953C6  8B C8                         mov ecx, eax
088953C8  51                            push ecx
088953C9  B9 CC CC CC CC                mov ecx, CCCCCCCCH ; sysWriteParUINT
088953CE  FF D1                         call ecx
088953D0  81 C4 08 00 00 00             add esp, 8

#48					ST		res_kw	{LNXT:5|1|-1}
(*) BOOL
088953D6  84 C0                         test al, al
088953D8  0F 95 05 CC CC CC CC          setne [CCCCCCCCH] ; $$DATA$$+305

END_PROGRAM
**************************************************
	List program: sr_ATS_Ctrl
**************************************************

PROGRAM sr_ATS_Ctrl

        VAR
TON_StartUp_1 : TON;
TON_StartUp_2 : TON;
stopping_timer : TON;
downtimeIN : BOOL;
washing_timer : TON;
checkWashAndStart : CheckWashAndStart;
isRunningWash : BOOL;
onWash : BOOL := false;
time_sec : INT := 4000;
	END_VAR

END_PROGRAM

#0		{SRC:sr_ATS_Ctrl}
#1		(*$WAITSWITCH$*)
#2		
#3		
#4			(* IF i_pb_rem = 1 And
#5		Not Alarms.0 And 
#6		Not Alarms.3 And 
#7		Not Alarms.4 And 
#8		Not Alarms.5 And 
#9		Not Alarms.7 *)
#10			LD		Alarms.7	{LNXT:2|-1|-1}
(*) UNDEF
088953DF  33 C0                         xor eax, eax
088953E1  66 8B 05 CC CC CC CC          mov ax, [CCCCCCCCH] ; %M110+32
088953E8  C1 E8 07                      shr eax, 7
088953EB  25 01 00 00 00                and eax, 1

#11			NOT	{LNXT:2|-1|-1}
(*) BOOL
088953F0  84 C0                         test al, al
088953F2  0F 94 C0                      sete al

#12			AND(		Alarms.5	{LNXT:2|-1|-1}
(*) BOOL
088953F5  50                            push eax
088953F6  33 C0                         xor eax, eax
088953F8  66 8B 05 CC CC CC CC          mov ax, [CCCCCCCCH] ; %M110+32
088953FF  C1 E8 05                      shr eax, 5
08895402  25 01 00 00 00                and eax, 1

#13			NOT	{LNXT:2|-1|-1}
(*) BOOL
08895407  84 C0                         test al, al
08895409  0F 94 C0                      sete al

#14			AND(		Alarms.4	{LNXT:2|-1|-1}
(*) BOOL
0889540C  50                            push eax
0889540D  33 C0                         xor eax, eax
0889540F  66 8B 05 CC CC CC CC          mov ax, [CCCCCCCCH] ; %M110+32
08895416  C1 E8 04                      shr eax, 4
08895419  25 01 00 00 00                and eax, 1

#15			NOT	{LNXT:2|-1|-1}
(*) BOOL
0889541E  84 C0                         test al, al
08895420  0F 94 C0                      sete al

#16			AND(		Alarms.3	{LNXT:2|-1|-1}
(*) BOOL
08895423  50                            push eax
08895424  33 C0                         xor eax, eax
08895426  66 8B 05 CC CC CC CC          mov ax, [CCCCCCCCH] ; %M110+32
0889542D  C1 E8 03                      shr eax, 3
08895430  25 01 00 00 00                and eax, 1

#17			NOT	{LNXT:2|-1|-1}
(*) BOOL
08895435  84 C0                         test al, al
08895437  0F 94 C0                      sete al

#18			AND(		Alarms.0	{LNXT:2|-1|-1}
(*) BOOL
0889543A  50                            push eax
0889543B  33 C0                         xor eax, eax
0889543D  66 8B 05 CC CC CC CC          mov ax, [CCCCCCCCH] ; %M110+32
08895444  25 01 00 00 00                and eax, 1

#19			NOT	{LNXT:2|-1|-1}
(*) BOOL
08895449  84 C0                         test al, al
0889544B  0F 94 C0                      sete al

#20			AND(		i_pb_rem	{LNXT:2|-1|-1}
(*) BOOL
0889544E  50                            push eax
0889544F  0F BF 05 CC CC CC CC          movsx eax, word ptr [CCCCCCCCH] ; $$DATA$$+64

#21			EQ		1	{LNXT:2|-1|-1}
(*) INT
08895456  3D 01 00 00 00                cmp eax, 1
0889545B  0F 94 C0                      sete al
0889545E  25 FF 00 00 00                and eax, 0FFh

#22			)	{LNXT:2|-1|-1}
(*) BOOL
08895463  8B C8                         mov ecx, eax
08895465  58                            pop eax
08895466  23 C1                         and eax, ecx

#23			)	{LNXT:2|-1|-1}
(*) BOOL
08895468  8B C8                         mov ecx, eax
0889546A  58                            pop eax
0889546B  23 C1                         and eax, ecx

#24			)	{LNXT:2|-1|-1}
(*) BOOL
0889546D  8B C8                         mov ecx, eax
0889546F  58                            pop eax
08895470  23 C1                         and eax, ecx

#25			)	{LNXT:2|-1|-1}
(*) BOOL
08895472  8B C8                         mov ecx, eax
08895474  58                            pop eax
08895475  23 C1                         and eax, ecx

#26			)	{LNXT:2|-1|-1}
(*) BOOL
08895477  8B C8                         mov ecx, eax
08895479  58                            pop eax
0889547A  23 C1                         and eax, ecx

#27			JMPCN	$label0	{LNXT:2|9|30}
(-) BOOL
0889547C  84 C0                         test al, al
0889547E  0F 84 C9 00 00 00             je 0889554DH

#28		
#29			(* THEN *)
#30		
#31		
#32				(* IF CMD.0 *)
#33				LD		CMD.0	{LNXT:9|-1|-1}
(*) UNDEF
08895484  33 C0                         xor eax, eax
08895486  66 8B 05 CC CC CC CC          mov ax, [CCCCCCCCH] ; %M110+34
0889548D  25 01 00 00 00                and eax, 1

#34				JMPCN	$label2	{LNXT:9|10|26}
(-) BOOL
08895492  84 C0                         test al, al
08895494  0F 84 A0 00 00 00             je 0889553AH

#35		
#36				(* THEN *)
#37		
#38					(* checkWashAndStart *)
#39					MOVE		o_val_close_fall,checkWashAndStart.o_val_close_fall_FB	{LNXT:10|-1|-1}
(*) BOOL
0889549A  B8 CC CC CC CC                mov eax, CCCCCCCCH ; %Q1+1
0889549F  89 05 CC CC CC CC             mov [CCCCCCCCH], eax ; $$DATA$$+185

#40					MOVE		o_val_close_R,checkWashAndStart.o_val_close_R_FB	{LNXT:11|-1|-1}
(*) BOOL^
088954A5  B8 CC CC CC CC                mov eax, CCCCCCCCH ; %Q1+3
088954AA  89 05 CC CC CC CC             mov [CCCCCCCCH], eax ; $$DATA$$+177

#41					MOVE		o_val_open_fall,checkWashAndStart.o_val_open_fall_FB	{LNXT:12|-1|-1}
(*) BOOL^
088954B0  B8 CC CC CC CC                mov eax, CCCCCCCCH ; %Q1+0
088954B5  89 05 CC CC CC CC             mov [CCCCCCCCH], eax ; $$DATA$$+181

#42					MOVE		o_val_open_R,checkWashAndStart.o_val_open_R_FB	{LNXT:13|-1|-1}
(*) BOOL^
088954BB  B8 CC CC CC CC                mov eax, CCCCCCCCH ; %Q1+2
088954C0  89 05 CC CC CC CC             mov [CCCCCCCCH], eax ; $$DATA$$+173

#43					MOVE		sv_washing,checkWashAndStart.sv_washing_FB	{LNXT:14|-1|-1}
(*) BOOL^
088954C6  B8 CC CC CC CC                mov eax, CCCCCCCCH ; %M110+38
088954CB  89 05 CC CC CC CC             mov [CCCCCCCCH], eax ; $$DATA$$+169

#44					MOVE		q_start_ats,checkWashAndStart.q_start_ats_FB	{LNXT:15|-1|-1}
(*) BOOL^
088954D1  B8 CC CC CC CC                mov eax, CCCCCCCCH ; %Q1+7
088954D6  89 05 CC CC CC CC             mov [CCCCCCCCH], eax ; $$DATA$$+189

#45					MOVE		time_sec,checkWashAndStart.ep_time_wash_FB	{LNXT:16|-1|-1}
(*) BOOL^
088954DC  B8 CC CC CC CC                mov eax, CCCCCCCCH ; $$DATA$$+230
088954E1  89 05 CC CC CC CC             mov [CCCCCCCCH], eax ; $$DATA$$+193

#46					MOVE		i_val_state,checkWashAndStart.i_val_state_FB	{LNXT:17|-1|-1}
(*) INT^
088954E7  B8 CC CC CC CC                mov eax, CCCCCCCCH ; $$DATA$$+232
088954EC  89 05 CC CC CC CC             mov [CCCCCCCCH], eax ; $$DATA$$+197

#47					MOVE		di_val_open_state_fall,checkWashAndStart.di_val_open_state_fall_FB	{LNXT:18|-1|-1}
(*) INT^
088954F2  B8 CC CC CC CC                mov eax, CCCCCCCCH ; $$DATA$$+234
088954F7  89 05 CC CC CC CC             mov [CCCCCCCCH], eax ; $$DATA$$+201

#48					MOVE		di_val_close_state_fall,checkWashAndStart.di_val_close_state_fall_FB	{LNXT:19|-1|-1}
(*) INT^
088954FD  B8 CC CC CC CC                mov eax, CCCCCCCCH ; $$DATA$$+236
08895502  89 05 CC CC CC CC             mov [CCCCCCCCH], eax ; $$DATA$$+205

#49					MOVE		di_val_open_state_R,checkWashAndStart.di_val_open_state_R_FB	{LNXT:20|-1|-1}
(*) INT^
08895508  B8 CC CC CC CC                mov eax, CCCCCCCCH ; $$DATA$$+238
0889550D  89 05 CC CC CC CC             mov [CCCCCCCCH], eax ; $$DATA$$+209

#50					MOVE		di_val_close_state_R,checkWashAndStart.di_val_close_state_R_FB	{LNXT:21|-1|-1}
(*) INT^
08895513  B8 CC CC CC CC                mov eax, CCCCCCCCH ; $$DATA$$+58
08895518  89 05 CC CC CC CC             mov [CCCCCCCCH], eax ; $$DATA$$+213

#51					MOVE		Alarms_Val,checkWashAndStart.Alarm_Val_FB	{LNXT:22|-1|-1}
(*) BOOL^
0889551E  B8 CC CC CC CC                mov eax, CCCCCCCCH ; %M110+40
08895523  89 05 CC CC CC CC             mov [CCCCCCCCH], eax ; $$DATA$$+217

#52					CAL		checkWashAndStart	{LNXT:10|59|-1}
(*) WORD^
08895529  50                            push eax
0889552A  BB CC CC CC CC                mov ebx, CCCCCCCCH ; $$DATA$$+66
0889552F  E8 B6 F1 FF FF                call 088946EAH ; $$CODE$$+18154
08895534  58                            pop eax

#53					JMP		$label3	{LNXT:9|10|26}
(-) WORD^
08895535  EB 11 90 90 90                jmp 08895548H

#54		$label2:
#55		
#56				(* ELSE *)
#57		
#58					(* q_start_ats := False; *)
#59					MOVE		False,q_start_ats	{LNXT:26|59|-1}
(*) WORD^
0889553A  B8 00 00 00 00                mov eax, 00H
0889553F  84 C0                         test al, al
08895541  0F 95 05 CC CC CC CC          setne [CCCCCCCCH] ; %Q1+7

#60		
#61		$label3:
#62				(* END_IF *)
#63				JMP		$label1	{LNXT:2|9|30}
(-) BOOL
08895548  EB 35 90 90 90                jmp 0889557FH

#64		$label0:
#65		
#66			(* ELSE *)
#67		
#68				(* CMD.0 := False; *)
#69				MOVE		False,CMD.0	{LNXT:30|31|-1}
(*) BOOL
0889554D  B8 00 00 00 00                mov eax, 00H
08895552  84 C0                         test al, al
08895554  90 75 11 90 90 90             jne 00000014H@
0889555A  66 0F BA 35 CC CC CC CC 00    btr word ptr [CCCCCCCCH], 0 ; %M110+34
08895563  EB 0C 90 90 90                jmp 0000000EH@
08895568  66 0F BA 2D CC CC CC CC 00    bts word ptr [CCCCCCCCH], 0 ; %M110+34

#70		
#71				(* q_start_ats := False; *)
#72				MOVE		False,q_start_ats	{LNXT:31|59|-1}
(*) WORD
08895571  B8 00 00 00 00                mov eax, 00H
08895576  84 C0                         test al, al
08895578  0F 95 05 CC CC CC CC          setne [CCCCCCCCH] ; %Q1+7

#73		
#74		$label1:
#75			(* END_IF *)
#76		
#77		
#78			(* IF q_start_ats *)
#79			LD		q_start_ats	{LNXT:59|-1|-1}
(*) UNDEF
0889557F  33 C0                         xor eax, eax
08895581  8A 05 CC CC CC CC             mov al, [CCCCCCCCH] ; %Q1+7

#80			NOT	{LNXT:59|-1|-1}
(*) BOOL
08895587  84 C0                         test al, al
08895589  0F 94 C0                      sete al

#81			JMPCN	$label4	{LNXT:59|60|62}
(-) BOOL
0889558C  84 C0                         test al, al
0889558E  90 74 16 90 90 90             je 088955A7H

#82		
#83			(* THEN *)
#84		
#85				(* downtimeIN:=true; *)
#86				MOVE		true,downtimeIN	{LNXT:60|66|-1}
(*) BOOL
08895594  B8 01 00 00 00                mov eax, 01H
08895599  84 C0                         test al, al
0889559B  0F 95 05 CC CC CC CC          setne [CCCCCCCCH] ; $$DATA$$+229

#87				JMP		$label5	{LNXT:59|60|62}
(-) BOOL
088955A2  EB 11 90 90 90                jmp 088955B5H

#88		$label4:
#89		
#90			(* ELSE *)
#91		
#92				(* downtimeIN:=false; *)
#93				MOVE		false,downtimeIN	{LNXT:62|66|-1}
(*) BOOL
088955A7  B8 00 00 00 00                mov eax, 00H
088955AC  84 C0                         test al, al
088955AE  0F 95 05 CC CC CC CC          setne [CCCCCCCCH] ; $$DATA$$+229

#94		
#95		$label5:
#96			(* END_IF *)
#97		
#98			(* stopping_timer *)
#99			MOVE		downtimeIN,stopping_timer.IN	{LNXT:66|-1|-1}
(*) BOOL
088955B5  33 C0                         xor eax, eax
088955B7  8A 05 CC CC CC CC             mov al, [CCCCCCCCH] ; $$DATA$$+229
088955BD  84 C0                         test al, al
088955BF  0F 95 05 CC CC CC CC          setne [CCCCCCCCH] ; $$DATA$$+244

#100			MOVE		50000,stopping_timer.PT	{LNXT:66|-1|-1}
(*) BOOL
088955C6  B8 50 C3 00 00                mov eax, C350H
088955CB  89 05 CC CC CC CC             mov [CCCCCCCCH], eax ; $$DATA$$+245

#101			CAL		stopping_timer	{LNXT:66|68|-1}
(*) UDINT
088955D1  50                            push eax
088955D2  BB CC CC CC CC                mov ebx, CCCCCCCCH ; $$DATA$$+240
088955D7  E8 DD EE FF FF                call 088944B9H ; $$CODE$$+17593
088955DC  58                            pop eax

#102		
#103		
#104			(* IF stopping_timer.Q *)
#105			LD		stopping_timer.Q	{LNXT:68|-1|-1}
(*) UNDEF
088955DD  33 C0                         xor eax, eax
088955DF  8A 05 CC CC CC CC             mov al, [CCCCCCCCH] ; $$DATA$$+249

#106			JMPCN	$label6	{LNXT:68|69|73}
(-) BOOL
088955E5  84 C0                         test al, al
088955E7  90 74 11 90 90 90             je 088955FBH

#107		
#108			(* THEN *)
#109		
#110				(* sv_washing :=true; *)
#111				MOVE		true,sv_washing	{LNXT:69|73|-1}
(*) BOOL
088955ED  B8 01 00 00 00                mov eax, 01H
088955F2  84 C0                         test al, al
088955F4  0F 95 05 CC CC CC CC          setne [CCCCCCCCH] ; %M110+38

#112		
#113		$label6:
#114			(* END_IF *)
#115		
#116			(* Alarms.2 := i_sns_door; *)
#117			MOVE		i_sns_door,Alarms.2	{LNXT:73|76|-1}
(*) BOOL
088955FB  33 C0                         xor eax, eax
088955FD  8A 05 CC CC CC CC             mov al, [CCCCCCCCH] ; $$DATA$$+262
08895603  84 C0                         test al, al
08895605  90 75 11 90 90 90             jne 00000014H@
0889560B  66 0F BA 35 CC CC CC CC 02    btr word ptr [CCCCCCCCH], 2 ; %M110+32
08895614  EB 0C 90 90 90                jmp 0000000EH@
08895619  66 0F BA 2D CC CC CC CC 02    bts word ptr [CCCCCCCCH], 2 ; %M110+32

#118		
#119			(* Alarms.3 := i_rnpp; *)
#120			MOVE		i_rnpp,Alarms.3	{LNXT:76|82|-1}
(*) BOOL
08895622  33 C0                         xor eax, eax
08895624  8A 05 CC CC CC CC             mov al, [CCCCCCCCH] ; $$DATA$$+263
0889562A  84 C0                         test al, al
0889562C  90 75 11 90 90 90             jne 00000014H@
08895632  66 0F BA 35 CC CC CC CC 03    btr word ptr [CCCCCCCCH], 3 ; %M110+32
0889563B  EB 0C 90 90 90                jmp 0000000EH@
08895640  66 0F BA 2D CC CC CC CC 03    bts word ptr [CCCCCCCCH], 3 ; %M110+32

#121		
#122			(* Alarms.5 := i_no_alm_ats; *)
#123			MOVE		i_no_alm_ats,Alarms.5	{LNXT:82|99|-1}
(*) BOOL
08895649  33 C0                         xor eax, eax
0889564B  8A 05 CC CC CC CC             mov al, [CCCCCCCCH] ; $$DATA$$+264
08895651  84 C0                         test al, al
08895653  90 75 11 90 90 90             jne 00000014H@
08895659  66 0F BA 35 CC CC CC CC 05    btr word ptr [CCCCCCCCH], 5 ; %M110+32
08895662  EB 0C 90 90 90                jmp 0000000EH@
08895667  66 0F BA 2D CC CC CC CC 05    bts word ptr [CCCCCCCCH], 5 ; %M110+32

#124		
#125		
#126			(* IF CMD.1 *)
#127			LD		CMD.1	{LNXT:99|-1|-1}
(*) UNDEF
08895670  33 C0                         xor eax, eax
08895672  66 8B 05 CC CC CC CC          mov ax, [CCCCCCCCH] ; %M110+34
08895679  C1 E8 01                      shr eax, 1
0889567C  25 01 00 00 00                and eax, 1

#128			JMPCN	$label7	{LNXT:99|100|2}
(-) BOOL
08895681  84 C0                         test al, al
08895683  90 74 33 90 90 90             je 088956B9H

#129		
#130			(* THEN *)
#131		
#132				(* Alarms := 0; *)
#133				MOVE		0,Alarms	{LNXT:100|101|-1}
(*) BOOL
08895689  B8 00 00 00 00                mov eax, 00H
0889568E  66 89 05 CC CC CC CC          mov [CCCCCCCCH], ax ; %M110+32

#134		
#135				(* CMD.1 := False; *)
#136				MOVE		False,CMD.1	{LNXT:101|2|-1}
(*) WORD
08895695  B8 00 00 00 00                mov eax, 00H
0889569A  84 C0                         test al, al
0889569C  90 75 11 90 90 90             jne 00000014H@
088956A2  66 0F BA 35 CC CC CC CC 01    btr word ptr [CCCCCCCCH], 1 ; %M110+34
088956AB  EB 0C 90 90 90                jmp 0000000EH@
088956B0  66 0F BA 2D CC CC CC CC 01    bts word ptr [CCCCCCCCH], 1 ; %M110+34

088956B9  61                            popad
088956BA  5D                            pop ebp

088956BB  C3                            ret

END_PROGRAM


**************************************************
	Target variable image generation
**************************************************


*** INPUT:
088956BC  55                            push ebp
088956BD  8B EC                         mov ebp, esp

088956BF  66 8B 0D CC CC CC CC          mov cx, [CCCCCCCCH] ; %I1+14
088956C6  66 89 0D CC CC CC CC          mov [CCCCCCCCH], cx ; $$DATA$$+64

088956CD  66 8B 0D CC CC CC CC          mov cx, [CCCCCCCCH] ; %I1+4
088956D4  66 89 0D CC CC CC CC          mov [CCCCCCCCH], cx ; $$DATA$$+232

088956DB  66 8B 0D CC CC CC CC          mov cx, [CCCCCCCCH] ; %I1+6
088956E2  66 89 0D CC CC CC CC          mov [CCCCCCCCH], cx ; $$DATA$$+234

088956E9  66 8B 0D CC CC CC CC          mov cx, [CCCCCCCCH] ; %I1+8
088956F0  66 89 0D CC CC CC CC          mov [CCCCCCCCH], cx ; $$DATA$$+236

088956F7  66 8B 0D CC CC CC CC          mov cx, [CCCCCCCCH] ; %I1+10
088956FE  66 89 0D CC CC CC CC          mov [CCCCCCCCH], cx ; $$DATA$$+238

08895705  8A 0D CC CC CC CC             mov cl, [CCCCCCCCH] ; %I0+0
0889570B  88 0D CC CC CC CC             mov [CCCCCCCCH], cl ; $$DATA$$+58

08895711  8A 0D CC CC CC CC             mov cl, [CCCCCCCCH] ; %I0+3
08895717  88 0D CC CC CC CC             mov [CCCCCCCCH], cl ; $$DATA$$+262

0889571D  8A 0D CC CC CC CC             mov cl, [CCCCCCCCH] ; %I0+4
08895723  88 0D CC CC CC CC             mov [CCCCCCCCH], cl ; $$DATA$$+263

08895729  8A 0D CC CC CC CC             mov cl, [CCCCCCCCH] ; %I0+6
0889572F  88 0D CC CC CC CC             mov [CCCCCCCCH], cl ; $$DATA$$+264

08895735  66 8B 0D CC CC CC CC          mov cx, [CCCCCCCCH] ; %I1+0
0889573C  66 89 0D CC CC CC CC          mov [CCCCCCCCH], cx ; $$DATA$$+270

08895743  8B E5                         mov esp, ebp
08895745  5D                            pop ebp

08895746  C3                            ret


*** OUTPUT:
08895747  55                            push ebp
08895748  8B EC                         mov ebp, esp

0889574A  8B E5                         mov esp, ebp
0889574C  5D                            pop ebp

0889574D  C3                            ret



**************************************************
	Task Timed init code
**************************************************

0889574E  55                            push ebp
0889574F  8B EC                         mov ebp, esp

Var init: V::SR_ATS_CTRL.TIME_SEC = 4000
08895751  66 C7 05 CC CC CC CC A0 0F    mov word ptr [CCCCCCCCH], 0FA0H ; $$DATA$$+230

0889575A  8B E5                         mov esp, ebp
0889575C  5D                            pop ebp

0889575D  C3                            ret



**************************************************
	Global init code
**************************************************

08895770  55                            push ebp
08895771  8B EC                         mov ebp, esp

Var init: V:EMBEDDEDELEMENTS:$$POUCBARRAY$$BACKGROUND = [?ATS_mdb.$$POUCB$$, 0]
08895773  B9 CC CC CC CC                mov ecx, CCCCCCCCH ; $$DATA$$+360
08895778  89 0D CC CC CC CC             mov [CCCCCCCCH], ecx ; $$DATA$$+308

Var init: V:EMBEDDEDELEMENTS:$$POUCBARRAY$$BOOT = [?sr_init_counters.$$POUCB$$, 0]
0889577E  B9 CC CC CC CC                mov ecx, CCCCCCCCH ; $$DATA$$+366
08895783  89 0D CC CC CC CC             mov [CCCCCCCCH], ecx ; $$DATA$$+316

Var init: V:EMBEDDEDELEMENTS:$$POUCBARRAY$$INIT = [?init_val.$$POUCB$$, 0]
08895789  B9 CC CC CC CC                mov ecx, CCCCCCCCH ; $$DATA$$+372
0889578E  89 0D CC CC CC CC             mov [CCCCCCCCH], ecx ; $$DATA$$+324

Var init: V:EMBEDDEDELEMENTS:$$POUCBARRAY$$SERV = [?InitParDB.$$POUCB$$, 0]
08895794  B9 CC CC CC CC                mov ecx, CCCCCCCCH ; $$DATA$$+378
08895799  89 0D CC CC CC CC             mov [CCCCCCCCH], ecx ; $$DATA$$+332

Var init: V:EMBEDDEDELEMENTS:$$POUCBARRAY$$TIMED = [?sr_pressure.$$POUCB$$, ?sr_counters.$$POUCB$$, ?sr_save_counters.$$POUCB$$, ?sr_ATS_Ctrl.$$POUCB$$, 0]
0889579F  B9 CC CC CC CC                mov ecx, CCCCCCCCH ; $$DATA$$+384
088957A4  89 0D CC CC CC CC             mov [CCCCCCCCH], ecx ; $$DATA$$+340
088957AA  B9 CC CC CC CC                mov ecx, CCCCCCCCH ; $$DATA$$+390
088957AF  89 0D CC CC CC CC             mov [CCCCCCCCH], ecx ; $$DATA$$+344
088957B5  B9 CC CC CC CC                mov ecx, CCCCCCCCH ; $$DATA$$+396
088957BA  89 0D CC CC CC CC             mov [CCCCCCCCH], ecx ; $$DATA$$+348
088957C0  B9 CC CC CC CC                mov ecx, CCCCCCCCH ; $$DATA$$+402
088957C5  89 0D CC CC CC CC             mov [CCCCCCCCH], ecx ; $$DATA$$+352

088957CB  8B E5                         mov esp, ebp
088957CD  5D                            pop ebp

088957CE  C3                            ret



**************************************************
	Global RETAIN init code
**************************************************

088957CF  55                            push ebp
088957D0  8B EC                         mov ebp, esp

088957D2  8B E5                         mov esp, ebp
088957D4  5D                            pop ebp

088957D5  C3                            ret



**************************************************
	Task $$VirtualTables init code
**************************************************

088957D6  55                            push ebp
088957D7  8B EC                         mov ebp, esp

088957D9  8B E5                         mov esp, ebp
088957DB  5D                            pop ebp

088957DC  C3                            ret



********************************************
MEMORY MAP
********************************************

Code area type:          		       main code
Start code area:          		0000000008890000h
End code area:            		00000000088961C4h
Code size:                		000061C4h

Start local data area:    		0000000008710000h
End local data area:      		0000000008710198h
Local data size:          		00000198h

Start retentive data area:		0000000000000000h
End retentive data area:  		0000000000000000h
Retentive data size:      		00000000h

Start bit data area:      		0000000000000000h
End bit data area:        		0000000000000000h
Bit data size:            		00000000h



********************************************
CODE ID:                                25B6003F
DEBUG MEMO ID:                          000034F7
FULL MEMO ID:                           000064F0
RELOCATION ADDR:                        0000000008890000
********************************************
